////////////////////////////////////////////////////////////////////////////////
//
//  MILLENIUM-STUDIO
//  Copyright 2016 Millenium-studio SARL
//  All Rights Reserved.
//
////////////////////////////////////////////////////////////////////////////////

#include "AnticheatMgr.h"
#include "Common.h"
#include "Language.h"
#include "DatabaseEnv.h"
#include "Log.h"
#include "Opcodes.h"
#include "SpellMgr.h"
#include "World.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "UpdateMask.h"
#include "Player.h"
#include "Vehicle.h"
#include "SkillDiscovery.h"
#include "QuestDef.h"
#include "GossipDef.h"
#include "UpdateData.h"
#include "Channel.h"
#include "ChannelMgr.h"
#include "MapManager.h"
#include "MapInstanced.h"
#include "InstanceSaveMgr.h"
#include "GridNotifiers.h"
#include "GridNotifiersImpl.h"
#include "CellImpl.h"
#include "ObjectMgr.h"
#include "GuildMgr.h"
#include "GroupMgr.h"
#include "ObjectAccessor.h"
#include "CreatureAI.h"
#include "Formulas.h"
#include "Group.h"
#include "Pet.h"
#include "Util.h"
#include "Transport.h"
#include "Weather.h"
#include "Battleground.h"
#include "BattlegroundAV.h"
#include "BattlegroundMgr.hpp"
#include "OutdoorPvP.h"
#include "OutdoorPvPMgr.h"
#include "Arena.h"
#include "Chat.h"
#include "Spell.h"
#include "SocialMgr.h"
#include "GameEventMgr.h"
#include "AchievementMgr.h"
#include "SpellAuras.h"
#include "SpellAuraEffects.h"
#include "ConditionMgr.h"
#include "DisableMgr.h"
#include "WeatherMgr.h"
#include "LFGMgr.h"
#include "InstanceScript.h"
#include "AccountMgr.h"
#include "DB2Stores.h"
#include "DBCStores.h"
#include "Battlefield.h"
#include "BattlefieldMgr.h"
#include "UpdateFieldFlags.h"
#include "SceneObject.h"
#include "PetBattle.h"
#include "MSCallback.hpp"
#include "Vignette.hpp"
#include "WowTime.hpp"

#ifndef CROSS
# include "CharacterDatabaseCleaner.h"
# include "TicketMgr.h"
# include "Guild.h"
# include "InterRealmOpcodes.h"
# include "GarrisonMgr.hpp"
# include "../../../scripts/Draenor/Garrison/GarrisonScriptData.hpp"
#else
# include "InterRealmMgr.h"
#endif


#define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)

enum SkillFieldOffset
{
    SKILL_OFFSET_LINEID     = 0 * 64,
    SKILL_OFFSET_STEP       = 1 * 64,
    SKILL_OFFSET_RANK       = 2 * 64,
    SKILL_OFFSET_UNK        = 3 * 64,
    SKILL_OFFSET_MAX_RANK   = 4 * 64,
    SKILL_OFFSET_MODIFIER   = 5 * 64,
    SKILL_OFFSET_TALENT     = 6 * 64,
};

enum CharacterFlags
{
    CHARACTER_FLAG_NONE                 = 0x00000000,
    CHARACTER_FLAG_UNK1                 = 0x00000001,
    CHARACTER_FLAG_UNK2                 = 0x00000002,
    CHARACTER_LOCKED_FOR_TRANSFER       = 0x00000004,
    CHARACTER_FLAG_UNK4                 = 0x00000008,
    CHARACTER_FLAG_UNK5                 = 0x00000010,
    CHARACTER_FLAG_UNK6                 = 0x00000020,
    CHARACTER_FLAG_UNK7                 = 0x00000040,
    CHARACTER_FLAG_UNK8                 = 0x00000080,
    CHARACTER_FLAG_UNK9                 = 0x00000100,
    CHARACTER_FLAG_UNK10                = 0x00000200,
    CHARACTER_FLAG_HIDE_HELM            = 0x00000400,
    CHARACTER_FLAG_HIDE_CLOAK           = 0x00000800,
    CHARACTER_FLAG_UNK13                = 0x00001000,
    CHARACTER_FLAG_GHOST                = 0x00002000,
    CHARACTER_FLAG_RENAME               = 0x00004000,
    CHARACTER_FLAG_UNK16                = 0x00008000,
    CHARACTER_FLAG_UNK17                = 0x00010000,
    CHARACTER_FLAG_UNK18                = 0x00020000,
    CHARACTER_FLAG_UNK19                = 0x00040000,
    CHARACTER_FLAG_UNK20                = 0x00080000,
    CHARACTER_FLAG_UNK21                = 0x00100000,
    CHARACTER_FLAG_UNK22                = 0x00200000,
    CHARACTER_FLAG_UNK23                = 0x00400000,
    CHARACTER_FLAG_UNK24                = 0x00800000,
    CHARACTER_FLAG_LOCKED_BY_BILLING    = 0x01000000,
    CHARACTER_FLAG_DECLINED             = 0x02000000,
    CHARACTER_FLAG_UNK27                = 0x04000000,
    CHARACTER_FLAG_UNK28                = 0x08000000,
    CHARACTER_FLAG_UNK29                = 0x10000000,
    CHARACTER_FLAG_UNK30                = 0x20000000,
    CHARACTER_FLAG_UNK31                = 0x40000000,
    CHARACTER_FLAG_UNK32                = 0x80000000
};

enum CharacterCustomizeFlags
{
    CHAR_CUSTOMIZE_FLAG_NONE            = 0x00000000,
    CHAR_CUSTOMIZE_FLAG_CUSTOMIZE       = 0x00000001,       // name, gender, etc...
    CHAR_CUSTOMIZE_FLAG_FACTION         = 0x00010000,       // name, gender, faction, etc...
    CHAR_CUSTOMIZE_FLAG_RACE            = 0x00100000        // name, gender, race, etc...
};

// corpse reclaim times
#define DEATH_EXPIRE_STEP (5*MINUTE)
#define MAX_DEATH_COUNT 3

static uint32 gCopseReclaimDelay[MAX_DEATH_COUNT] = { 30, 60, 120 };

bool PetQueryHolder::Initialize()
{
    SetSize(MAX_PET_LOGIN_QUERY);

    bool res = true;

#ifdef CROSS
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(m_RealmId)->GetDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif
    PreparedStatement* stmt = NULL;

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_AURA);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADAURA, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_AURA_EFFECT);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADAURAEFFECT, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_SPELL);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADSPELL, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_SPELL_COOLDOWN);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_LOADSPELLCOOLDOWN, stmt);

    stmt = l_Database->GetPreparedStatement(CHAR_SEL_PET_DECLINED_NAME);
    stmt->setUInt32(0, m_guid);
    res &= SetPreparedQuery(PET_LOGIN_QUERY_DECLINED_NAME, stmt);

    return res;
}

PreparedStatement* PetQueryHolder::GenerateFirstLoadStatement(uint32 p_PetEntry, uint32 p_PetNumber, uint32 p_OwnerID, bool p_CurrentPet, PetSlot p_SlotID, uint32 p_RealmID)
{
#ifdef CROSS
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(p_RealmID)->GetDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    PreparedStatement* l_Statement = nullptr;

    if (p_PetNumber)
    {
        // Known petnumber entry
        //        0     1      2       3       4     5       6        7     8       9        10        11       12       13           14          15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_PetNumber);
    }
    else if (p_CurrentPet && p_SlotID != PET_SLOT_UNK_SLOT)
    {
        // Current pet (slot 0)
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_SlotID);
    }
    else if (p_PetEntry)
    {
        // Known petentry entry (unique for summoned pet, but non unique for hunter pet (only from current or not stabled pets)
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT_2);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, p_PetEntry);
        l_Statement->setUInt32(2, PET_SLOT_HUNTER_FIRST);
        l_Statement->setUInt32(3, PET_SLOT_HUNTER_LAST);
        l_Statement->setUInt32(4, PET_SLOT_STABLE_LAST);
    }
    else
    {
        // Any current or other non-stabled pet (for hunter "call pet")
        //        0     1     2        3       4     5       6        7      8      9        10         11      12      13           14            15          16
        // SELECT id, entry, owner, modelid, level, exp, Reactstate, slot, name, renamed, curhealth, curmana, abdata, savetime, CreatedBySpell, PetType, specialization
        l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_SLOT);
        l_Statement->setUInt32(0, p_OwnerID);
        l_Statement->setUInt32(1, PET_SLOT_HUNTER_FIRST);
        l_Statement->setUInt32(2, PET_SLOT_HUNTER_LAST);
        l_Statement->setUInt32(3, p_SlotID);
    }

    return l_Statement;
}

#ifdef CROSS
# define RealmDatabase (*GetRealmDatabase())
#else
# define RealmDatabase CharacterDatabase
#endif

// == Player ====================================================
// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
Player::Player(WorldSession* session) : Unit(true), m_achievementMgr(this), m_reputationMgr(this), phaseMgr(this), m_archaeologyMgr(this), m_VignetteMgr(this)
{
#ifdef _MSC_VER
#pragma warning(default:4355)
#endif

    m_Garrison = nullptr;
    m_GarrisonUpdateTimer.SetInterval(2 * IN_MILLISECONDS);

    m_VoidStorageLoaded = false;

    CurrentPlayedMovie = 0;

    m_speakTime = 0;
    m_speakCount = 0;

    m_bgRoles = 0;

    m_lastPlayedEmote = 0;

    m_pmChatTime = 0;
    m_pmChatCount = 0;

    m_petSlotUsed = 0;
    m_currentPetSlot = PET_SLOT_DELETED;

    m_objectType |= TYPEMASK_PLAYER;
    m_objectTypeId = TYPEID_PLAYER;

    m_valuesCount = PLAYER_END;
    _dynamicValuesCount = PLAYER_DYNAMIC_END;

    m_session = session;

    m_divider = 0;

    m_ExtraFlags = 0;

    m_tokenCounter = 0;

    m_spellModTakingSpell = NULL;
    //m_pad = 0;

    // players always accept
    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        SetAcceptWhispers(true);

    m_curSelection = 0;
    m_lootGuid = 0;

    m_lootSpecId = 0;
    m_BonusRollFails = 0;

    m_RegenPowerTimer = 0;
    m_regenTimerCount = 0;
    m_holyPowerRegenTimerCount = 0;
    m_runicPowerRegenTimerCount = 0;
    m_chiPowerRegenTimerCount = 0;
    m_demonicFuryPowerRegenTimerCount = 0;
    m_soulShardsRegenTimerCount = 0;
    m_focusRegenTimerCount = 0;
    m_weaponChangeTimer = 0;

    m_zoneUpdateId = 0;
    m_zoneUpdateTimer = 0;

    m_areaUpdateId = 0;
    m_IsOutdoors = false;

    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    _resurrectionData = NULL;

    memset(m_items, 0, sizeof(Item*) * PLAYER_SLOTS_COUNT);

    m_social = NULL;

    // group is initialized in the reference constructor
    SetGroupInvite(0);
    m_groupUpdateMask = 0;
    m_auraRaidUpdateMask = 0;
    m_bPassOnGroupLoot = false;

    m_Duel = NULL;

    m_GuildIdInvited = 0;

    m_atLoginFlags = AT_LOGIN_NONE;

    mSemaphoreTeleport_Near = false;
    mSemaphoreTeleport_Far = false;

    m_DelayedOperations = 0;
    m_bCanDelayTeleport = false;
    m_bHasDelayedTeleport = false;
    m_isMoltenCored = false;
    m_teleport_options = 0;

    m_trade = NULL;
    m_ClientStateIndex = 0;

    m_cinematic = 0;

    PlayerTalkClass = new PlayerMenu(GetSession());
    m_currentBuybackSlot = BUYBACK_SLOT_START;

    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    for (uint8 i=0; i < MAX_TIMERS; i++)
        m_MirrorTimer[i] = DISABLED_MIRROR_TIMER;

    m_MirrorTimerFlags = UNDERWATER_NONE;
    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
    m_isInWater = false;
    m_drunkTimer = 0;
    m_restTime = 0;
    m_deathTimer = 0;
    m_deathExpireTime = 0;

    m_swingErrorMsg = 0;

    for (uint8 j = 0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; ++j)
    {
        m_bgBattlegroundQueueID[j].BgType = MS::Battlegrounds::BattlegroundType::None;
        m_bgBattlegroundQueueID[j].invitedToInstance = 0;
    }

    m_logintime = time(NULL);
    m_Last_tick = m_logintime;
    m_WeaponProficiency = 0;
    m_ArmorProficiency = 0;
    m_canParry = false;
    m_canBlock = false;
    m_canDualWield = false;
    m_canTitanGrip = false;

    m_temporaryUnsummonedPetNumber = 0;
    //cache for UNIT_FIELD_CREATED_BY_SPELL to allow
    //returning reagents for temporarily removed pets
    //when dying/logging out
    m_oldpetspell = 0;
    m_lastpetnumber = 0;

    ////////////////////Rest System/////////////////////
    time_inn_enter=0;
    inn_pos_mapid=0;
    inn_pos_x=0;
    inn_pos_y=0;
    inn_pos_z=0;
    m_rest_bonus=0;
    rest_type=REST_TYPE_NO;
    ////////////////////Rest System/////////////////////

    m_mailsUpdated = false;
    unReadMails = 0;
    m_nextMailDelivereTime = 0;

    m_itemUpdateQueueBlocked = false;

    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
        m_forced_speed_changes[i] = 0;

    m_stableSlots = 0;

    /////////////////// Instance System /////////////////////

    m_HomebindTimer = 0;
    m_InstanceValid = true;
    m_dungeonDifficulty = DifficultyNormal;
    m_raidDifficulty = DifficultyRaidNormal;
    m_LegacyRaidDifficulty = Difficulty10N;
    m_PrevMapDifficulty = DifficultyRaidNormal;

    m_LastPotion.m_LastPotionItemID = 0;
    m_LastPotion.m_LastPotionSpellID = 0;

    _talentMgr = new PlayerTalentInfo();

    m_glyphsChanged = false;

    for (uint8 i = 0; i < BASEMOD_END; ++i)
    {
        m_auraBaseMod[i][FLAT_MOD] = 0.0f;
        m_auraBaseMod[i][PCT_MOD] = 1.0f;
    }

    for (uint8 i = 0; i < MAX_COMBAT_RATING; i++)
        m_baseRatingValue[i] = 0;

    m_baseSpellPower = 0;
    m_baseManaRegen = 0;
    m_baseHealthRegen = 0;
    m_spellPenetrationItemMod = 0;

    // Honor System
    m_lastHonorUpdateTime = time(NULL);

    m_IsBGRandomWinner = false;

    // Player summoning
    m_summon_expire = 0;
    m_summon_mapid = 0;
    m_summon_x = 0.0f;
    m_summon_y = 0.0f;
    m_summon_z = 0.0f;

    m_mover = this;
    m_movedPlayer = this;
    m_seer = this;

    m_contestedPvPTimer = 0;

    m_declinedname = NULL;

    m_isActive = true;

    m_lastFallTime = 0;
    m_lastFallZ = 0;

    m_grantableLevels = 0;

    m_ControlledByPlayer = true;

#ifndef CROSS
    sWorld->IncreasePlayerCount();
#endif

    m_ChampioningFaction = 0;

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        m_powerFraction[i] = 0;

    isDebugAreaTriggers = false;

    m_IsDebugQuestLogs = false;

    m_WeeklyQuestChanged = false;

    m_MonthlyQuestChanged = false;

    m_SeasonalQuestChanged = false;

    SetPendingBind(0, 0);

    _activeCheats = CHEAT_NONE;
    _maxPersonalArenaRate = 0;

    _lastTargetedGO = 0;

    m_PersonnalXpRate = sWorld->getRate(RATE_XP_KILL);

    m_knockBackTimer = 0;

    m_CinematicSequence         = NULL;
    m_InCinematic               = false;
    m_CinematicClientStartTime  = 0;

    m_BattlePetSummon = 0;

    m_ignoreMovementCount = 0;

    m_groupUpdateDelay = 5000;

    m_emote = 0;

    memset(_voidStorageItems, 0, VOID_STORAGE_MAX_SLOT * sizeof(VoidStorageItem*));

    for (uint8 i = 0; i < MAX_PVP_SLOT; ++i)
    {
        m_ArenaPersonalRating[i] = sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING);
        m_BestRatingOfWeek[i] = 0;
        m_BestRatingOfSeason[i] = 0;
        m_ArenaMatchMakerRating[i] = sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING);
        m_WeekWins[i] = 0;
        m_PrevWeekWins[i] = 0;
        m_SeasonWins[i] = 0;
        m_WeekGames[i] = 0;
        m_SeasonGames[i] = 0;
    }

    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        prohibited[i] = prohibited_struct();
    }

    m_initializeCallback = false;

    m_needSummonPetAfterStopFlying = false;

    m_LastPlayedScene = NULL;

    m_PvPCombatTimer = 0;
    m_pvpCombat = false;

    for (int i = 0; i < INVENTORY_SLOT_BAG_END; i++)
        m_itemScale[i] = 0;

    m_LastSummonedBattlePet = 0;

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    ///////////////////////////////////////////////////////////

    m_WargameRequest = nullptr;

#ifdef CROSS
    m_NeedRemove  = false;
    m_PlayOnCross = false;
#endif

    m_PreviousLocationMapId = MAPID_INVALID;
    m_PreviousLocationX = 0;
    m_PreviousLocationY = 0;
    m_PreviousLocationZ = 0;
    m_PreviousLocationO = 0;

    for (uint8 l_I = 0; l_I < StoreCallback::MaxDelivery; l_I++)
        m_StoreDeliveryProcessed[l_I] = false;

    m_StoreDeliverySave = false;

#ifndef CROSS
    m_InterRealmPlayerState = InterRealmPlayerState::None;
    m_irZoneId = 0;
    m_irAreaId = 0;
    m_irMapId  = 0;
#endif

    m_BeaconOfFaithTargetGUID = 0;

    m_MasteryCache = 0.0f;
    m_BonusQuestTimer = 0;

    m_EndSalesTimestamp = 0;
}

Player::~Player()
{
    sLFGListMgr->RemovePlayerDueToLogout(GetGUIDLow());

#ifndef CROSS
    if (m_Garrison)
        delete m_Garrison;
#endif

    if (m_WargameRequest)
        delete m_WargameRequest;

    sSpellLogMgr->RemoveListener(this);

    // it must be unloaded already in PlayerLogout and accessed only for loggined player
    //m_social = NULL;

    // temp check
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
    {
        for (uint8 slot = 0; slot < PLAYER_SLOTS_COUNT; slot++)
        {
            if (m_items[slot] == NULL)
                continue;

            if (m_items[i] == m_items[slot] && slot != i)
            {
                sLog->outAshran("Player[%u] have same item pointer in two slot ! (slot: %u, copy slot: %u)", GetGUIDLow(), i, slot);
                m_items[i] = NULL;
            }
        }
    }

    // Note: buy back item already deleted from DB when player was saved
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        delete m_items[i];

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
        delete itr->second;

    delete _talentMgr;

    //all mailed items should be deleted, also all mail should be deallocated
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        delete *itr;

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated

    delete PlayerTalkClass;

    for (size_t x = 0; x < ItemSetEff.size(); x++)
        delete ItemSetEff[x];

    delete m_declinedname;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        delete _voidStorageItems[i];

    ClearResurrectRequestData();

#ifndef CROSS
    sWorld->DecreasePlayerCount();
#endif
}

void Player::CleanupsBeforeDelete(bool finalCleanup)
{
    TradeCancel(false);
    DuelComplete(DUEL_INTERRUPTED);

    Unit::CleanupsBeforeDelete(finalCleanup);

    if (m_transport)
        m_transport->RemovePassenger(this);

    // clean up player-instance binds, may unload some instance saves
    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
            itr->second.save->RemovePlayer(this);
}

bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
{
    // @FIXME: outfitId not used in player creating
    // TODO: need more checks against packet modifications
    // should check that skin, face, hair* are valid via DBC per race/class
    // also do it in Player::BuildEnumData, Player::LoadFromDB

    Object::_Create(guidlow, 0, HIGHGUID_PLAYER);
    CharacterTemplate const* l_Template = sObjectMgr->GetCharacterTemplate(createInfo->TemplateId);

    m_name = createInfo->Name;

    ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
    if (!cEntry)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DBC-files?)",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
        return false;
    }

    uint8 powertype = cEntry->DisplayPower;

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, DEFAULT_WORLD_OBJECT_SIZE);
    SetFloatValue(UNIT_FIELD_COMBAT_REACH, 1.5f);

    setFactionForRace(createInfo->Race);

    if (!IsValidGender(createInfo->Gender))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%hhu) - refusing to do so",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Gender);
        return false;
    }

    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
        return false;
    }

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        m_items[i] = NULL;

    if (l_Template && (GetTeam() == HORDE ? l_Template->m_HordeMapID != -1 : l_Template->m_AlianceMapID != -1))
    {
        if (GetTeam() == HORDE)
        {
            Relocate(l_Template->m_HordePos);
            SetMap(sMapMgr->CreateMap(l_Template->m_HordeMapID, this));
        }
        else
        {
            Relocate(l_Template->m_AliancePos);
            SetMap(sMapMgr->CreateMap(l_Template->m_AlianceMapID, this));
        }
    }
    else
    {
        Relocate(info->positionX, info->positionY, info->positionZ, info->orientation);
        SetMap(sMapMgr->CreateMap(info->mapId, this));
    }


    uint32 RaceClassPower = (createInfo->Race) | (createInfo->Class << 8) | (powertype << 16);

    SetUInt32Value(UNIT_FIELD_SEX, (RaceClassPower | (createInfo->Gender << 24)));
    SetUInt32Value(UNIT_FIELD_DISPLAY_POWER, powertype);
    InitDisplayIds();
    if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_PVP);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    }
    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);               // fix cast time showed in spell tooltip on client
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);            // default for players in 3.0.3
    SetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, 0.0f);
    SetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, 0.0f);

                                                            // -1 is default value
    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, uint32(-1));

    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_SKIN_ID, createInfo->Skin);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_FACE_ID, createInfo->Face);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_HAIR_STYLE_ID, createInfo->HairStyle);
    SetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_HAIR_COLOR_ID, createInfo->HairColor);

    SetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_FACIAL_STYLE, createInfo->FacialHair);
    SetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_REST_STATE, (GetSession()->IsARecruiter() || GetSession()->GetRecruiterId() != 0) ? REST_STATE_RAF_LINKED : REST_STATE_NOT_RAF_LINKED);

    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_3_OFFSET_GENDER, createInfo->Gender);
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_3_OFFSET_ARENA_FACTION, 0);               ///< BattlefieldArenaFaction (0 or 1)

    SetGuidValue(OBJECT_FIELD_DATA, 0);
    SetUInt32Value(PLAYER_FIELD_GUILD_RANK_ID, 0);
    SetGuildLevel(0);
    SetUInt32Value(PLAYER_FIELD_GUILD_TIME_STAMP, 0);
    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, g_RealmID);

    for (int i = 0; i < KNOWN_TITLES_SIZE; ++i)
        SetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i, 0);  // 0=disabled
    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);
    SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);

    // set starting level
    uint32 start_level = getClass() != CLASS_DEATH_KNIGHT
        ? sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL)
        : sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL);

    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
    {
        uint32 gm_level = sWorld->getIntConfig(CONFIG_START_GM_LEVEL);
        if (gm_level > start_level)
            start_level = gm_level;
    }

    if (l_Template)
    {
        SetUInt64Value(PLAYER_FIELD_COINAGE, l_Template->m_Money);
        SetUInt32Value(UNIT_FIELD_LEVEL, l_Template->m_Level);
    }
    else
    {
        SetUInt64Value(PLAYER_FIELD_COINAGE, sWorld->getIntConfig(CONFIG_START_PLAYER_MONEY));
        SetUInt32Value(UNIT_FIELD_LEVEL, start_level);
    }

    InitRunes();

    SetCurrency(CURRENCY_TYPE_HONOR_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_HONOR_POINTS));
    SetCurrency(CURRENCY_TYPE_JUSTICE_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_JUSTICE_POINTS));
    SetCurrency(CURRENCY_TYPE_CONQUEST_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_CONQUEST_POINTS));

    // start with every map explored
    if (sWorld->getBoolConfig(CONFIG_START_ALL_EXPLORED))
    {
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; i++)
            SetFlag(PLAYER_FIELD_EXPLORED_ZONES +i, 0xFFFFFFFF);
    }

    for (uint8 i = 0; i < MAX_PVP_SLOT; ++i)
    {
        SetArenaPersonalRating(i, sWorld->getIntConfig(CONFIG_ARENA_START_PERSONAL_RATING));
        SetArenaMatchMakerRating(i, sWorld->getIntConfig(CONFIG_ARENA_START_MATCHMAKER_RATING));
    }

    //Reputations if "StartAllReputation" is enabled, -- TODO: Fix this in a better way
    if (sWorld->getBoolConfig(CONFIG_START_ALL_REP))
    {
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(942), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(935), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(936), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1011), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(970), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(967), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(989), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(932), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(934), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1038), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1077), 42999);

        // Factions depending on team, like cities and some more stuff
        switch (GetTeam())
        {
            case ALLIANCE:
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(72), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(47), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(69), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(930), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(730), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(978), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(54), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(946), 42999);
                break;
            case HORDE:
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(76), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(68), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(81), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(911), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(729), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(941), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(530), 42999);
                GetReputationMgr().SetReputation(sFactionStore.LookupEntry(947), 42999);
                break;
            default:
                break;
        }
    }

    if (l_Template)
        for (auto& l_ReputationInfo : l_Template->m_TemplateFactions)
            if (FactionEntry const* l_Faction = sFactionStore.LookupEntry(l_ReputationInfo.m_FactionID))
                GetReputationMgr().SetReputation(l_Faction, l_ReputationInfo.m_Reputaion);

    // Played time
    m_Last_tick = time(NULL);
    m_Played_time[PLAYED_TIME_TOTAL] = 0;
    m_Played_time[PLAYED_TIME_LEVEL] = 0;

    // base stats and related field values
    InitStatsForLevel();
    InitTaxiNodesForLevel();
    InitGlyphsForLevel();
    InitTalentForLevel();

#ifndef CROSS
    InitSpellForLevel();
#endif

    InitPrimaryProfessions();                               // to max set before any spell added

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)
    SetFullHealth();
    if (getPowerType() == POWER_MANA)
    {
        UpdateMaxPower(POWER_MANA);                         // Update max Mana (for add bonus from intellect)
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    }

    if (getPowerType() == POWER_RUNIC_POWER)
    {
        SetPower(POWER_RUNES, 8);
        SetMaxPower(POWER_RUNES, 8);
        SetPower(POWER_RUNIC_POWER, 0);
        SetMaxPower(POWER_RUNIC_POWER, 1000);
    }

#ifndef CROSS
    if (l_Template)
        for (auto l_Spell : l_Template->m_SpellIDs)
            learnSpell(l_Spell, false);

    // original spells
    learnDefaultSpells();

    // original action bar
    for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
        addActionButton(action_itr->button, action_itr->action, action_itr->type);

    if (l_Template)
    {
        std::list<CharacterTemplate::TemplateItem const*> l_RemainingTemplates;
        for (auto& l_Item : l_Template->m_TemplateItems)
        {
            if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_Item.m_ItemID))
            {
                // Give bags first to the players, then the equipment
                if (l_Proto->Class == ITEM_CLASS_CONTAINER)
                {
                    if (!l_Item.m_Faction || (l_Item.m_Faction == 1 && GetTeam() == ALLIANCE) || (l_Item.m_Faction == 2 && GetTeam() == HORDE))
                        StoreNewItemInBestSlots(l_Item.m_ItemID, l_Item.m_Count);
                    continue;
                }
                else
                    l_RemainingTemplates.push_back(&l_Item);
            }
        }

        for (auto l_Item : l_RemainingTemplates)
        {
            if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_Item->m_ItemID))
            {
                if ((l_Proto->AllowableRace & getRaceMask()) == 0)
                    continue;

                if (!l_Item->m_Faction || (l_Item->m_Faction == 1 && GetTeam() == ALLIANCE) || (l_Item->m_Faction == 2 && GetTeam() == HORDE))
                {
                    ItemContext l_ItemContext = ItemContext::None;
                    switch (l_Item->m_Type)
                    {
                        case 1: ///< Shop PvE premade
                            l_ItemContext = ItemContext::RaidLfr;
                            break;
                        case 3: ///< PTR PvE templates
                            l_ItemContext = ItemContext::RaidNormal;
                            break;
                        default:
                            break;
                    }

                    if (l_ItemContext != ItemContext::None)
                        StoreNewItemInBestSlots(l_Item->m_ItemID, l_Item->m_Count, l_ItemContext);
                }
            }
        }
    }
    else
    {
        // original items
        CharStartOutfitEntry const* oEntry = NULL;
        for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
        {
            if (CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i))
            {
                if (entry->RaceID  == createInfo->Race  &&
                    entry->ClassID == createInfo->Class &&
                    entry->SexID   == createInfo->Gender)
                {
                    oEntry = entry;
                    break;
                }
            }
        }

        if (oEntry)
        {
            for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
            {
                if (oEntry->ItemId[j] <= 0)
                    continue;

                uint32 itemId = oEntry->ItemId[j];

                // just skip, reported in ObjectMgr::LoadItemTemplates
                ItemTemplate const* iProto = sObjectMgr->GetItemTemplate(itemId);
                if (!iProto)
                    continue;

                if (createInfo->OutfitId == 0)
                    continue;

                // BuyCount by default
                uint32 count = iProto->BuyCount;

                // @todo remove this, use data in dbc or player_createinfoitem.
                // special amount for food/drink
                if (iProto->Class == ITEM_CLASS_CONSUMABLE && iProto->SubClass == ITEM_SUBCLASS_FOOD_DRINK)
                {
                    switch (iProto->Spells[0].SpellCategory)
                    {
                        case SPELL_CATEGORY_FOOD:                                // food
                            count = getClass() == CLASS_DEATH_KNIGHT ? 10 : 4;
                            break;
                        case SPELL_CATEGORY_DRINK:                                // drink
                            count = 2;
                            break;
                    }
                    if (iProto->GetMaxStackSize() < count)
                        count = iProto->GetMaxStackSize();
                }

                switch(itemId)
                {
                    // This switch prevents these items (used next for a quest) to be added to a pandaren player at his creation.
                    case 73207:
                    case 73208:
                    case 73209:
                    case 73210:
                    case 73211:
                    case 73212:
                    case 73213:
                    case 76390:
                    case 76391:
                    case 76392:
                    case 76393:
                        continue;
                    default:
                        break;
                }

                StoreNewItemInBestSlots(itemId, count);
            }
        }
    }


    for (PlayerCreateInfoItems::const_iterator item_id_itr = info->item.begin(); item_id_itr != info->item.end(); ++item_id_itr)
        StoreNewItemInBestSlots(item_id_itr->item_id, item_id_itr->item_amount);

    // bags and main-hand weapon must equipped at this moment
    // now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
    // or ammo not equipped in special bag
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            uint16 eDest;
            // equip offhand weapon/shield if it attempt equipped before main-hand weapon
            InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false);
            if (msg == EQUIP_ERR_OK)
            {
                RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                EquipItem(eDest, pItem, true);
            }
            // move other items to more appropriate slots
            else
            {
                ItemPosCountVec sDest;
                msg = CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                    pItem = StoreItem(sDest, pItem, true); ///< pItem is never read 01/18/16
                }
            }
        }
    }
    // all item positions resolved
#endif

    // Pandaren's start quest
    if (createInfo->Race == RACE_PANDAREN_NEUTRAL)
    {
        Quest const* quest = NULL;
        switch (createInfo->Class)
        {
            case CLASS_WARRIOR: quest = sObjectMgr->GetQuestTemplate(30045); break;
            case CLASS_SHAMAN: quest = sObjectMgr->GetQuestTemplate(30044); break;
            case CLASS_ROGUE: quest = sObjectMgr->GetQuestTemplate(30043); break;
            case CLASS_PRIEST: quest = sObjectMgr->GetQuestTemplate(30042); break;
            case CLASS_HUNTER: quest = sObjectMgr->GetQuestTemplate(30041); break;
            case CLASS_MAGE: quest = sObjectMgr->GetQuestTemplate(30040); break;
            case CLASS_MONK: quest = sObjectMgr->GetQuestTemplate(30039); break;
            default: break;
        }

        if (quest)
        {
            this->AddQuest(quest, NULL);
            if (CanCompleteQuest(quest->GetQuestId()))
                CompleteQuest(quest->GetQuestId());
        }
    }

#ifndef CROSS
    if (WorldSession* l_Session = GetSession())
        l_Session->OnGMTicketGetTicketEvent();
#endif

    SetUInt32Value(EUnitFields::UNIT_FIELD_SCALE_DURATION, 500);
    return true;
}

bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount, ItemContext p_ItemContext)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Creating initial item, itemId = %u, count = %u", titem_id, titem_amount);

    // attempt equip by one
    while (titem_amount > 0)
    {
        uint16 eDest;
        InventoryResult msg = CanEquipNewItem(NULL_SLOT, eDest, titem_id, false);
        if (msg != EQUIP_ERR_OK)
            break;

        Item* l_Item = EquipNewItem(eDest, titem_id, true);

        if (l_Item && p_ItemContext != ItemContext::None)
        {
            std::vector<uint32> l_Bonus;
            Item::GenerateItemBonus(titem_id, p_ItemContext, l_Bonus);
            l_Item->AddItemBonuses(l_Bonus);
        }

        AutoUnequipOffhandIfNeed();
        --titem_amount;
    }

    if (titem_amount == 0)
        return true;                                        // equipped

    // attempt store
    ItemPosCountVec sDest;
    // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
    InventoryResult msg = CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, titem_id, titem_amount);
    if (msg == EQUIP_ERR_OK)
    {
        Item* l_Item = StoreNewItem(sDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id));

        if (l_Item && p_ItemContext != ItemContext::None)
        {
            std::vector<uint32> l_Bonus;
            Item::GenerateItemBonus(titem_id, p_ItemContext, l_Bonus);
            l_Item->AddItemBonuses(l_Bonus);
        }

        return true;                                        // stored
    }

    // item can't be added
    sLog->outError(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Can't equip or store initial item %u for race %u class %u, error msg = %u", titem_id, getRace(), getClass(), msg);
    return false;
}

void Player::RewardCurrencyAtKill(Unit* p_Victim)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (!p_Victim->ToCreature())
        return;

    if (!p_Victim->ToCreature()->GetEntry())
        return;

    if (uint32 l_TrackingQuestId = Vignette::GetTrackingQuestIdFromWorldObject(p_Victim))
    {
        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuestId);
        if (IsQuestBitFlaged(l_QuestBit))
            return;
    }

    CurrencyOnKillEntry const* l_Curr = sObjectMgr->GetCurrencyOnKillEntry(p_Victim->ToCreature()->GetEntry());
    if (!l_Curr)
        return;

    bool l_Result = true;
    if (p_Victim->ToCreature()->AI())
        p_Victim->ToCreature()->AI()->CurrenciesRewarder(l_Result);

    if (!l_Result)
        return;

    for (CurrencyOnKillEntry::const_iterator idx = l_Curr->begin(); idx != l_Curr->end(); ++idx)
    {
        // Players won't receive justice points from pre-MoP dungeons/raids when they are more than Cataclysm max level (85)
        if ((idx->first == CURRENCY_TYPE_JUSTICE_POINTS
            || idx->first == CURRENCY_TYPE_VALOR_POINTS)
            && p_Victim->GetMap()->Expansion() != EXPANSION_MISTS_OF_PANDARIA
            && getLevel() > 85)
            continue;

        int32 l_Pct = 100;
        Unit::AuraEffectList const& l_Auras = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_PCT);
        for (Unit::AuraEffectList::const_iterator i = l_Auras.begin(); i != l_Auras.end(); ++i)
        {
            if (idx->first == (*i)->GetMiscValue()) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                l_Pct += (*i)->GetAmount();
        }

        ModifyCurrency(idx->first, CalculatePct(idx->second, l_Pct));
    }
}
void Player::SendMirrorTimer(MirrorTimerType p_Type, uint32 p_MaxValue, uint32 p_CurrValue, int32 p_Regen)
{
    if (int(p_MaxValue) == DISABLED_MIRROR_TIMER)
    {
        if (int(p_CurrValue) != DISABLED_MIRROR_TIMER)
            StopMirrorTimer(p_Type);
        return;
    }

    WorldPacket l_Data(SMSG_START_MIRROR_TIMER, (21));
    uint32 l_SpellID = 0;

    l_Data << uint32(p_Type);
    l_Data << p_CurrValue;
    l_Data << p_MaxValue;
    l_Data << uint32(p_Regen);
    l_Data << uint32(l_SpellID);
    l_Data.WriteBit(0);
    GetSession()->SendPacket(&l_Data);
}

void Player::StopMirrorTimer(MirrorTimerType Type)
{
    m_MirrorTimer[Type] = DISABLED_MIRROR_TIMER;
    WorldPacket data(SMSG_STOP_MIRROR_TIMER, 4);
    data << uint32(Type);
    GetSession()->SendPacket(&data);
}

bool Player::IsImmuneToEnvironmentalDamage()
{
    // check for GM and death state included in isAttackableByAOE
    return (!isTargetableForAttack(false));
}

uint32 Player::EnvironmentalDamage(EnviromentalDamage p_Type, uint32 p_Damage)
{
    if (IsImmuneToEnvironmentalDamage())
        return 0;

    // Absorb, resist some environmental damage type
    uint32 l_Absorb = 0;
    uint32 l_Resist = 0;

    if (p_Type == DAMAGE_LAVA)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_FIRE, DIRECT_DAMAGE, p_Damage, &l_Absorb, &l_Resist);
    else if (p_Type == DAMAGE_SLIME)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE, p_Damage, &l_Absorb, &l_Resist);
    else if (p_Type == DAMAGE_FALL)
    {
        /// Handle falling damage disabling in some situations
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->IsPlayerImmuneToFallDamage(this))
                return 0;
        }

        /// Glyph of Falling Meteor - 56247
        if (getClass() == CLASS_WARLOCK && HasAura(109151) && HasAura(56247))
            AddPct(p_Damage, -95);

        // Percentage from SPELL_AURA_REDUCE_FALL_DAMAGE_PERCENT
        AuraEffectList const& mReduceFallDamagePct = GetAuraEffectsByType(SPELL_AURA_REDUCE_FALL_DAMAGE_PERCENT);
        for (AuraEffectList::const_iterator i = mReduceFallDamagePct.begin(); i != mReduceFallDamagePct.end(); ++i)
            AddPct(p_Damage, (*i)->GetAmount());
    }

    p_Damage -= l_Absorb + l_Resist;

    DealDamageMods(this, p_Damage, &l_Absorb);

    WorldPacket l_Data(SMSG_ENVIRONMENTAL_DAMAGE_LOG, (21));
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint8(p_Type != DAMAGE_FALL_TO_VOID ? p_Type : DAMAGE_FALL);
    l_Data << uint32(p_Damage);
    l_Data << uint32(l_Absorb);
    l_Data << uint32(l_Resist);

    l_Data.WriteBit(false);               ///< HasPowerData
    l_Data.FlushBits();

    SendMessageToSet(&l_Data, true);

    uint32 l_FinalDamage = DealDamage(this, p_Damage, NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);

    if (!isAlive())
    {
        if (p_Type == DAMAGE_FALL)                               ///< DealDamage not apply item durability loss at self damage
        {
            sLog->outDebug(LOG_FILTER_PLAYER, "We are fall to death, loosing 10 percents durability");

            DurabilityLossAll(0.10f, false);
            /// durability lost message
            SendDurabilityLoss(this, 10);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATHS_FROM, 1, p_Type);
    }

    return l_FinalDamage;
}

int32 Player::getMaxTimer(MirrorTimerType timer)
{
    switch (timer)
    {
        case FATIGUE_TIMER:
            return MINUTE * IN_MILLISECONDS;
        case BREATH_TIMER:
        {
            if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
                return DISABLED_MIRROR_TIMER;
            int32 UnderWaterTime = 3 * MINUTE * IN_MILLISECONDS;
            AuraEffectList const& mModWaterBreathing = GetAuraEffectsByType(SPELL_AURA_MOD_WATER_BREATHING);
            for (AuraEffectList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
                AddPct(UnderWaterTime, (*i)->GetAmount());
            return UnderWaterTime;
        }
        case FIRE_TIMER:
        {
            if (!isAlive())
                return DISABLED_MIRROR_TIMER;
            return 1 * IN_MILLISECONDS;
        }
        default:
            return 0;
    }
}

void Player::UpdateMirrorTimers()
{
    // Desync flags for update on next HandleDrowning
    if (m_MirrorTimerFlags)
        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
}

void Player::HandleDrowning(uint32 time_diff)
{
    if (!m_MirrorTimerFlags)
        return;

    // In water
    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
    {
        // Vash'jir zones
        if (m_zoneUpdateId == 4815 || m_zoneUpdateId == 4816 || m_zoneUpdateId == 5144 || m_zoneUpdateId == 5145|| m_zoneUpdateId == 5146)
            return;

        // Breath timer not activated - activate it
        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1);
        }
        else                                                              // If activated - do tick
        {
            m_MirrorTimer[BREATH_TIMER]-=time_diff;
            // Timer limit - need deal damage
            if (m_MirrorTimer[BREATH_TIMER] < 0)
            {
                m_MirrorTimer[BREATH_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                // @TODO: Check this formula
                uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
                EnvironmentalDamage(DAMAGE_DROWNING, damage);
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))      // Update time in client if need
                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)        // Regen timer
    {
        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);
        // Need breath regen
        m_MirrorTimer[BREATH_TIMER]+=10*time_diff;
        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !isAlive())
            StopMirrorTimer(BREATH_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10);
    }

    // In dark water
    if ((m_MirrorTimerFlags & UNDERWARER_INDARKWATER) && !GetVehicle())
    {
        // Fatigue timer not activated - activate it
        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1);
        }
        else
        {
            m_MirrorTimer[FATIGUE_TIMER]-=time_diff;
            // Timer limit - need deal damage or teleport ghost to graveyard
            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
            {
                m_MirrorTimer[FATIGUE_TIMER]+= 1*IN_MILLISECONDS;
                if (isAlive())                                              // Calculate and deal damage
                {
                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
                }
                else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))         // Teleport ghost to graveyard
                    RepopAtGraveyard();
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER))
                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)       // Regen timer
    {
        int32 DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
        m_MirrorTimer[FATIGUE_TIMER]+=10*time_diff;
        if (m_MirrorTimer[FATIGUE_TIMER] >= DarkWaterTime || !isAlive())
            StopMirrorTimer(FATIGUE_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
            SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
    }

    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
    {
        // Breath timer not activated - activate it
        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
        else
        {
            m_MirrorTimer[FIRE_TIMER] -= time_diff;
            if (m_MirrorTimer[FIRE_TIMER] < 0)
            {
                m_MirrorTimer[FIRE_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                // TODO: Check this formula
                uint32 damage = urand(600, 700);
                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
                    EnvironmentalDamage(DAMAGE_LAVA, damage);
                // need to skip Slime damage in Undercity,
                // maybe someone can find better way to handle environmental damage
                //else if (m_zoneUpdateId != 1497)
                //    EnvironmentalDamage(DAMAGE_SLIME, damage);
            }
        }
    }
    else
        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;

    // Recheck timers flag
    m_MirrorTimerFlags&=~UNDERWATER_EXIST_TIMERS;
    for (uint8 i = 0; i< MAX_TIMERS; ++i)
        if (m_MirrorTimer[i] != DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimerFlags|=UNDERWATER_EXIST_TIMERS;
            break;
        }
    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
}

///The player sobers by 1% every 9 seconds
void Player::HandleSobering()
{
    m_drunkTimer = 0;

    uint8 currentDrunkValue = GetDrunkValue();
    uint8 drunk = currentDrunkValue ? --currentDrunkValue : 0;
    SetDrunkValue(drunk);
}

DrunkenState Player::GetDrunkenstateByValue(uint8 value)
{
    if (value >= 90)
        return DRUNKEN_SMASHED;
    if (value >= 50)
        return DRUNKEN_DRUNK;
    if (value)
        return DRUNKEN_TIPSY;
    return DRUNKEN_SOBER;
}

void Player::SetDrunkValue(uint8 newDrunkValue, uint32 itemId /*= 0*/)
{
    bool isSobering = newDrunkValue < GetDrunkValue();
    uint32 oldDrunkenState = Player::GetDrunkenstateByValue(GetDrunkValue());
    if (newDrunkValue > 100)
        newDrunkValue = 100;

    // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
    int32 drunkPercent = std::max<int32>(newDrunkValue, GetTotalAuraModifier(SPELL_AURA_MOD_FAKE_INEBRIATE));
    if (drunkPercent)
    {
        m_invisibilityDetect.AddFlag(INVISIBILITY_DRUNK);
        m_invisibilityDetect.SetValue(INVISIBILITY_DRUNK, drunkPercent);
    }
    else if (!HasAuraType(SPELL_AURA_MOD_FAKE_INEBRIATE) && !newDrunkValue)
        m_invisibilityDetect.DelFlag(INVISIBILITY_DRUNK);

    uint32 newDrunkenState = Player::GetDrunkenstateByValue(newDrunkValue);
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_3_OFFSET_INEBRIATION, newDrunkValue);
    UpdateObjectVisibility();

    if (!isSobering)
        m_drunkTimer = 0;   // reset sobering timer

    if (newDrunkenState == oldDrunkenState)
        return;

    WorldPacket l_Data(SMSG_CROSSED_INEBRIATION_THRESHOLD, (8+4+4));
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(itemId);
    l_Data << uint32(newDrunkenState);
    SendMessageToSet(&l_Data, true);
}

void Player::Update(uint32 p_time)
{
    if (!IsInWorld())
        return;

    if (!m_initializeCallback)
    {
        PreparedStatement* stmt;

        stmt = RealmDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PET_BY_ENTRY_AND_SLOT);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, m_currentPetSlot);
        _petPreloadCallback = RealmDatabase.AsyncQuery(stmt);

        m_initializeCallback = true;
    }

    // Process player callback
    {
        PreparedQueryResult result;

        if (_petPreloadCallback.ready())
        {
            _petPreloadCallback.get(result);
            LoadPet(result);
            _petPreloadCallback.cancel();
        }

        if (_petLoginCallback.ready())
        {
            SQLQueryHolder* param;
            _petLoginCallback.get(param);

            Pet* pet = new Pet(this);
            pet->LoadPetFromDB(this, 0, 0, true, PET_SLOT_ACTUAL_PET_SLOT, false, (PetQueryHolder*)param, [param](Pet* p_Pet, bool p_Result) -> void
            {
                if (!p_Result)
                    delete p_Pet;

                delete param;
            });

            _petLoginCallback.cancel();
        }
    }

    // Zone Skip Update
    if ((sObjectMgr->IsSkipZoneEnabled() && sObjectMgr->IsSkipZone(GetZoneId())) || isAFK())
    {
        _skipCount++;
        _skipDiff += p_time;

        if (_skipCount < sObjectMgr->GetSkipUpdateCount())
            return;

        p_time = _skipDiff;
        _skipCount = 0;
        _skipDiff = 0;
    }

    if (m_InCinematic && m_CinematicSequence)
    {
        bool l_StartedAtClient = getMSTime() > m_CinematicClientStartTime;
        uint32 l_Time = getMSTime() - m_CinematicClientStartTime;

        if (l_StartedAtClient)
        {
            if (l_Time > m_CinematicSequence->Duration)
                StopCinematic();
            else if (l_StartedAtClient)
            {
                Position l_NewPosition;
                m_CinematicSequence->GetPositionAtTime(l_Time, &l_NewPosition.m_positionX, &l_NewPosition.m_positionY, &l_NewPosition.m_positionZ);

                Unit::UpdatePosition(l_NewPosition.m_positionX, l_NewPosition.m_positionY, l_NewPosition.m_positionZ, 0, true);
                SetFall(false);
            }
        }
    }

    // undelivered mail
    if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
    {
        SendNewMail();
        ++unReadMails;

        // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
        m_nextMailDelivereTime = 0;
    }

    // If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
    // Having this would prevent more aura charges to be dropped, so let's crash
    //ASSERT (!m_spellModTakingSpell);
    if (m_spellModTakingSpell)
    {
        //sLog->outFatal(LOG_FILTER_PLAYER, "Player has m_pad %u during update!", m_pad);
        //if (m_spellModTakingSpell)
        sLog->outFatal(LOG_FILTER_SPELLS_AURAS, "Player has m_spellModTakingSpell %u during update!", m_spellModTakingSpell->m_spellInfo->Id);
        m_spellModTakingSpell = NULL;
    }

    //used to implement delayed far teleports
    SetCanDelayTeleport(true);
    Unit::Update(p_time);
    SetCanDelayTeleport(false);

    time_t now = time(nullptr);

    if (m_WargameRequest != nullptr && (m_WargameRequest->CreationDate + 60) < now)
    {
        delete m_WargameRequest;
        m_WargameRequest = nullptr;
    }

    UpdatePvPFlag(now);

    UpdateContestedPvP(p_time);

    UpdateDuelFlag(now);

    CheckDuelDistance(now);

    UpdateAfkReport(now);

    UpdatePvP(p_time);

    if (isCharmed())
        if (Unit* charmer = GetCharmer())
            if (charmer->GetTypeId() == TYPEID_UNIT && charmer->isAlive())
                UpdateCharmedAI();

    // Update items that have just a limited lifetime
    if (now > m_Last_tick)
        UpdateItemDuration(uint32(now - m_Last_tick));

    // check every second
    if (now > m_Last_tick + 1000)
        UpdateSoulboundTradeItems();

    if (_petBattleJournalCallback.ready())
    {
        PreparedQueryResult l_Result;
        _petBattleJournalCallback.get(l_Result);
        bool l_ResultRes = _LoadPetBattles(std::move(l_Result));
        _petBattleJournalCallback.cancel();

        if (!l_ResultRes)
            ReloadPetBattles();
    }

    if (!m_timedquests.empty())
    {
        QuestSet::iterator iter = m_timedquests.begin();
        while (iter != m_timedquests.end())
        {
            QuestStatusData& q_status = m_QuestStatus[*iter];
            if (q_status.Timer <= p_time)
            {
                uint32 quest_id  = *iter;
                ++iter;                                     // current iter will be removed in FailQuest
                FailQuest(quest_id);
            }
            else
            {
                q_status.Timer -= p_time;
                m_QuestStatusSave[*iter] = true;
                ++iter;
            }
        }
    }

    GetAchievementMgr().UpdateTimedAchievements(p_time);

    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
    {
        if (Unit* victim = getVictim())
        {
            // default combat reach 10
            // TODO add weapon, skill check

            bool l_MustCheckO = true;

            /// Can attack own vehicle in any direction
            if (m_vehicle)
            {
                if (IsOnVehicle(victim) || (m_vehicle->GetBase() && m_vehicle->GetBase()->IsOnVehicle(victim)))
                    l_MustCheckO = false;
            }

            if (isAttackReady(WeaponAttackType::BaseAttack))
            {
                if (!IsWithinMeleeRange(victim) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                {
                    setAttackTimer(WeaponAttackType::BaseAttack, 100);
                    if (m_swingErrorMsg != 1)               // send single time (client auto repeat)
                    {
                        SendAttackSwingError(ATTACKSWINGERR_NOT_IN_RANGE);
                        m_swingErrorMsg = 1;
                    }
                }
                //120 degrees of radiant range, if player is not in boundary radius
                else if (!IsWithinBoundaryRadius(victim) && l_MustCheckO && !HasInArc(2 * M_PI / 3, victim))
                {
                    setAttackTimer(WeaponAttackType::BaseAttack, 100);
                    if (m_swingErrorMsg != 2)               // send single time (client auto repeat)
                    {
                        SendAttackSwingError(ATTACKSWINGERR_BAD_FACING);
                        m_swingErrorMsg = 2;
                    }
                }
                else
                {
                    m_swingErrorMsg = 0;                    // reset swing error state

                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (haveOffhandWeapon())
                        if (getAttackTimer(WeaponAttackType::OffAttack) < ATTACK_DISPLAY_DELAY)
                            setAttackTimer(WeaponAttackType::OffAttack, ATTACK_DISPLAY_DELAY);

                    // do attack if player doesn't have Shadow Blades or SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL
                    if (!HasAura(121471) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    {
                        AttackerStateUpdate(victim, WeaponAttackType::BaseAttack);
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }
                    else if (HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        // Should have only one aura of this type at the same time
                        AuraEffectList const& mOverrideAutoAttacks = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL);
                        for (AuraEffectList::const_iterator i = mOverrideAutoAttacks.begin(); i != mOverrideAutoAttacks.end(); ++i)
                        {
                            CastSpell(victim, (*i)->GetTriggerSpell(), true);
                            resetAttackTimer(WeaponAttackType::BaseAttack);
                            break;
                        }
                    }
                    // Shadow Blade - Main Hand
                    else if (getClass() == CLASS_ROGUE && HasAura(121471) && !HasAura(137586) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        CastSpell(victim, 121473, true);
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }
                    else if (getClass() == CLASS_ROGUE && HasAura(137586) && HasAura(121471) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        CastSpell(victim, 140308, true); // Shadow Shuriken Toss
                        resetAttackTimer(WeaponAttackType::BaseAttack);
                    }
                }
            }

            if (haveOffhandWeapon() && isAttackReady(WeaponAttackType::OffAttack))
            {
                if (!IsWithinMeleeRange(victim) && !HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    setAttackTimer(WeaponAttackType::OffAttack, 100);
                else if (!IsWithinBoundaryRadius(victim) && l_MustCheckO && !HasInArc(2 * M_PI / 3, victim))
                    setAttackTimer(WeaponAttackType::OffAttack, 100);
                else
                {
                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (getAttackTimer(WeaponAttackType::BaseAttack) < ATTACK_DISPLAY_DELAY)
                        setAttackTimer(WeaponAttackType::BaseAttack, ATTACK_DISPLAY_DELAY);

                    // do attack if player doesn't have Shadow Blades or SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL
                    if (!HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL))
                    {
                        AttackerStateUpdate(victim, WeaponAttackType::OffAttack);
                        resetAttackTimer(WeaponAttackType::OffAttack);
                    }
                    else if (HasAuraType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL) && IsWithinLOSInMap(victim))
                    {
                        if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
                            return;

                        // Should have only one aura of this type at the same time
                        AuraEffectList const& mOverrideAutoAttacks = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_AUTO_ATTACKS_BY_SPELL);
                        for (AuraEffectList::const_iterator i = mOverrideAutoAttacks.begin(); i != mOverrideAutoAttacks.end(); ++i)
                        {
                            CastSpell(victim, (*i)->GetMiscValue(), true);
                            resetAttackTimer(WeaponAttackType::OffAttack);
                            break;
                        }
                    }
                }
            }
        }
    }

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
    {
        if (roll_chance_i(3) && GetTimeInnEnter() > 0)      // freeze update
        {
            time_t time_inn = time(NULL)-GetTimeInnEnter();
            if (time_inn >= 10)                             // freeze update
            {
                float bubble = 0.125f*sWorld->getRate(RATE_REST_INGAME);
                                                            // speed collect rest bonus (section/in hour)
                SetRestBonus(GetRestBonus()+ time_inn*((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)/72000)*bubble);
                UpdateInnerTime(time(NULL));
            }
        }
    }

    if (m_weaponChangeTimer > 0)
    {
        if (p_time >= m_weaponChangeTimer)
            m_weaponChangeTimer = 0;
        else
            m_weaponChangeTimer -= p_time;
    }

    if (m_zoneUpdateTimer > 0)
    {
        if (p_time >= m_zoneUpdateTimer)
        {
            uint32 newzone, newarea;
            GetZoneAndAreaId(newzone, newarea, true);

            if (m_zoneUpdateId != newzone)
                UpdateZone(newzone, newarea);                // also update area
            else
            {
                // use area updates as well
                // needed for free far all arenas for example
                if (m_areaUpdateId != newarea)
                    UpdateArea(newarea);

                m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
            }

#ifndef CROSS
            /// Shipyard map has broken area settings
            if (IsInShipyard())
            {
                uint64 l_Guid = GetGUID();
                Map * l_Map = sMapMgr->FindBaseNonInstanceMap(MS::Garrison::Globals::BaseMap);

                if (!l_Map)
                    l_Map = sMapMgr->CreateBaseMap(MS::Garrison::Globals::BaseMap);

                if (l_Map)
                {
                    uint32 l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area;

                    l_Map->GetZoneAndAreaId(l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area, m_positionX, m_positionY, m_positionZ);
                    const GarrSiteLevelEntry * l_GarrisonSiteEntry = m_Garrison->GetGarrisonSiteLevelEntry(); ///< l_garrisonSiteEntry is never read 01/18/16

                    if (l_DraenorBaseMap_Area != MS::Garrison::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()])
                    {
                        sMapMgr->AddCriticalOperation([l_Guid]() -> bool
                        {
                            Player * l_Player = sObjectAccessor->FindPlayer(l_Guid);

                            if (l_Player && l_Player->IsInWorld())
                            {
                                l_Player->_SetOutOfShipyard();
                                return true;
                            }

                            return false;
                        });
                    }
                }
            }
#endif
        }
        else
            m_zoneUpdateTimer -= p_time;
    }

    if (m_timeSyncTimer > 0)
    {
        if (p_time >= m_timeSyncTimer)
            SendTimeSync();
        else
            m_timeSyncTimer -= p_time;
    }

    if (isAlive())
    {
        m_RegenPowerTimer += p_time;
        RegenerateAll();
    }

    if (m_deathState == JUST_DIED)
        KillPlayer();

    if (m_nextSave > 0)
    {
        if (p_time >= m_nextSave)
        {
            // m_nextSave reseted in SaveToDB call
            SaveToDB();
            sLog->outDebug(LOG_FILTER_PLAYER, "Player '%s' (GUID: %u) saved", GetName(), GetGUIDLow());
        }
        else
            m_nextSave -= p_time;
    }

    //Handle Water/drowning
    HandleDrowning(p_time);

    // Played time
    if (now > m_Last_tick)
    {
        uint32 elapsed = uint32(now - m_Last_tick);
        m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
        m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
        m_Last_tick = now;
    }

    if (GetDrunkValue())
    {
        m_drunkTimer += p_time;
        if (m_drunkTimer > 9 * IN_MILLISECONDS)
            HandleSobering();
    }

    if (HasPendingBind())
    {
        if (_pendingBindTimer <= p_time)
        {
            // Player left the instance
            if (_pendingBindId == GetInstanceId())
                BindToInstance();
            SetPendingBind(0, 0);
        }
        else
            _pendingBindTimer -= p_time;
    }

    // not auto-free ghost from body in instances
    if (m_deathTimer > 0 && !GetBaseMap()->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
    {
        if (p_time >= m_deathTimer)
        {
            m_deathTimer = 0;
            BuildPlayerRepop();
            RepopAtGraveyard();
        }
        else
            m_deathTimer -= p_time;
    }

    if (m_knockBackTimer)
    {
        if ( m_knockBackTimer + 2000 < getMSTime())
            m_knockBackTimer = 0;
    }

    UpdateEnchantTime(p_time);
    UpdateHomebindTime(p_time);

    if (!_instanceResetTimes.empty())
    {
        for (InstanceTimeMap::iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end();)
        {
            if (itr->second < now)
                _instanceResetTimes.erase(itr++);
            else
                ++itr;
        }
    }

    // group update
    // Avoid spam of SMSG_PARTY_MEMBER_STAT
    if (m_groupUpdateDelay < p_time)
    {
        SendUpdateToOutOfRangeGroupMembers();
        m_groupUpdateDelay = 5000;
    }
    else
        m_groupUpdateDelay -= p_time;

    Pet* pet = GetPet();
    if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange()) && !pet->isPossessed())
        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true, pet->m_Stampeded);

    if (pet && IsFlying() && !pet->isPossessed())
    {
        UnsummonPetTemporaryIfAny();
        m_needSummonPetAfterStopFlying = true;
    }
    else if (!IsFlying() && m_needSummonPetAfterStopFlying)
    {
        ResummonPetTemporaryUnSummonedIfAny();
        m_needSummonPetAfterStopFlying = false;
    }

    //we should execute delayed teleports only for alive(!) players
    //because we don't want player's ghost teleported from graveyard
    if (IsHasDelayedTeleport())
        TeleportTo(m_teleport_dest, m_teleport_options);

#ifndef CROSS
    m_GarrisonUpdateTimer.Update(p_time);

    if (m_GarrisonUpdateTimer.Passed())
    {
        if (m_Garrison)
            m_Garrison->Update();

        m_GarrisonUpdateTimer.Reset();
    }

#endif /* not CROSS */
    m_VignetteMgr.Update();

    sScriptMgr->OnPlayerUpdate(this, p_time);

    m_CriticalOperationLock.acquire();

    std::queue<std::function<bool()>> l_CriticalOperationFallBack;
    while (!m_CriticalOperation.empty())
    {
        if (m_CriticalOperation.front())
        {
            if (!(m_CriticalOperation.front()()))
                l_CriticalOperationFallBack.push(m_CriticalOperation.front());
        }

        m_CriticalOperation.pop();
    }

    while (!l_CriticalOperationFallBack.empty())
    {
        m_CriticalOperation.push(l_CriticalOperationFallBack.front());
        l_CriticalOperationFallBack.pop();
    }

    m_CriticalOperationLock.release();
#ifdef CROSS

    while (!m_ItemToGuidSync.empty())
    {
        uint32 l_LocalItemGuid = InterRealmClient::GetIRClient(this)->GenerateLocalRealmLowGuid(HIGHGUID_ITEM);
        if (l_LocalItemGuid == 0)
            break;

        if (Item* l_Item = GetItemByGuid(m_ItemToGuidSync.front()))
            l_Item->SetRealGUID(MAKE_NEW_GUID(l_LocalItemGuid, 0, HIGHGUID_ITEM));

        m_ItemToGuidSync.pop();
    }
#endif /* CROSS */
}

void Player::setDeathState(DeathState s)
{
    uint32 ressSpellId = 0;

    bool cur = isAlive();

    if (s == JUST_DIED)
    {
        if (!cur)
        {
            sLog->outError(LOG_FILTER_PLAYER, "setDeathState: attempt to kill a dead player %s(%d)", GetName(), GetGUIDLow());
            return;
        }

        // drunken state is cleared on death
        SetDrunkValue(0);

        ClearResurrectRequestData();

        if (Pet* pet = GetPet())
            RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true, pet->m_Stampeded);
        else
            RemovePet(NULL, PET_SLOT_ACTUAL_PET_SLOT, true, GetPet() ? GetPet()->m_Stampeded : true);

        // save value before aura remove in Unit::setDeathState
        ressSpellId = GetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL);

        // passive spell
        if (!ressSpellId)
            ressSpellId = GetResurrectionSpellId();
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_AT_MAP, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_IN_DUNGEON, 1);
        GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
        GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
        GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
    }
    else if (s == ALIVE)
    {
        if (HasAura(84559))
            RemoveAurasDueToSpell(84559); // The Quick and the Dead
    }

    Unit::setDeathState(s);

    // restore resurrection spell id for player after aura remove
    if (s == JUST_DIED && cur && ressSpellId)
        SetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL, ressSpellId);

    if (isAlive() && !cur)
        //clear aura case after resurrection by another way (spells will be applied before next death)
        SetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL, 0);
}

bool Player::BuildEnumData(PreparedQueryResult p_Result, ByteBuffer* p_Data)
{
    //             0               1                2                3                 4                  5                       6                        7
    //    "SELECT characters.guid, characters.name, characters.race, characters.class, characters.gender, characters.playerBytes, characters.playerBytes2, characters.level, "
    //     8                9               10                     11                     12                     13                    14
    //    "characters.zone, characters.map, characters.position_x, characters.position_y, characters.position_z, guild_member.guildid, characters.playerFlags, "
    //    15                    16                   17                     18                   19               20                     21               22
    //    "characters.at_login, character_pet.entry, character_pet.modelid, character_pet.level, characters.data, character_banned.guid, characters.slot, character_declinedname.genitive"

    Field* l_Fields = p_Result->Fetch();

    /// Character visual
    uint8 l_CharacterRace       = l_Fields[2].GetUInt8();
    uint8 l_CharacterClass      = l_Fields[3].GetUInt8();
    uint8 l_CharacterGender     = l_Fields[4].GetUInt8();
    uint8 l_CharacterSkin       = uint8( l_Fields[5].GetUInt32() & 0xFF);
    uint8 l_CharacterFace       = uint8((l_Fields[5].GetUInt32() >> 8)  & 0xFF);
    uint8 l_CharacterHairStyle  = uint8((l_Fields[5].GetUInt32() >> 16) & 0xFF);
    uint8 l_CharacterHairColor  = uint8((l_Fields[5].GetUInt32() >> 24) & 0xFF);
    uint8 l_CharacterFacialHair = uint8( l_Fields[6].GetUInt32() & 0xFF);

    /// Character informations
    uint64      l_CharacterGuid         = MAKE_NEW_GUID(l_Fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
    std::string l_CharacterName         = l_Fields[1].GetString();
    uint32      l_CharacterLoginFlags   = l_Fields[15].GetUInt16();
    uint32      l_CharacterGuildID      = l_Fields[13].GetUInt32();
    uint8       l_CharacterOrder        = l_Fields[21].GetUInt8();
    uint8       l_CharacterLevel        = l_Fields[7].GetUInt8();
    uint64      l_CharacterGuildGuid    = MAKE_NEW_GUID(l_CharacterGuildID, 0, l_CharacterGuildID ? uint32(HIGHGUID_GUILD) : 0);
    Tokenizer   l_CharacterEquipment(l_Fields[19].GetString(), ' ');

    /// Character location
    uint32  l_CharacterZoneID       = l_Fields[8].GetUInt16();
    uint32  l_CharacterMapID        = uint32(l_Fields[9].GetUInt16());
    float   l_CharacterPositionX    = l_Fields[10].GetFloat();
    float   l_CharacterPositionY    = l_Fields[11].GetFloat();
    float   l_CharacterPositionZ    = l_Fields[12].GetFloat();

    uint32 l_PlayerFlags = l_Fields[14].GetUInt32();
    uint32 l_CharacterFlags = 0;

    if (l_PlayerFlags & PLAYER_FLAGS_HIDE_HELM)
        l_CharacterFlags |= CHARACTER_FLAG_HIDE_HELM;

    if (l_PlayerFlags & PLAYER_FLAGS_HIDE_CLOAK)
        l_CharacterFlags |= CHARACTER_FLAG_HIDE_CLOAK;

    if (l_PlayerFlags & PLAYER_FLAGS_GHOST)
        l_CharacterFlags |= CHARACTER_FLAG_GHOST;

    if (l_CharacterLoginFlags & AT_LOGIN_RENAME)
        l_CharacterFlags |= CHARACTER_FLAG_RENAME;

    if (l_Fields[20].GetUInt32())
        l_CharacterFlags |= CHARACTER_FLAG_LOCKED_BY_BILLING;

    if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED))
    {
        if (!l_Fields[22].GetString().empty())
            l_CharacterFlags |= CHARACTER_FLAG_DECLINED;
    }
    else
        l_CharacterFlags |= CHARACTER_FLAG_DECLINED;

    if (l_CharacterLoginFlags & AT_LOGIN_LOCKED_FOR_TRANSFER)
        l_CharacterFlags |= CHARACTER_LOCKED_FOR_TRANSFER;

    bool l_CharacterFirstLogin = l_CharacterLoginFlags & AT_LOGIN_FIRST;

    uint32 l_CharacterCustomizationFlags = 0;

    if (l_CharacterLoginFlags & AT_LOGIN_CUSTOMIZE)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_CUSTOMIZE;
    else if (l_CharacterLoginFlags & AT_LOGIN_CHANGE_FACTION)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_FACTION;
    else if (l_CharacterLoginFlags & AT_LOGIN_CHANGE_RACE)
        l_CharacterCustomizationFlags = CHAR_CUSTOMIZE_FLAG_RACE;

    uint32 l_CharacterPetDisplayId  = 0;
    uint32 l_CharacterPetLevel      = 0;
    uint32 l_CharacterPetFamily     = CREATURE_FAMILY_NONE;

    /// show pet at selection character in character list only for non-ghost character
    if (p_Result && !(l_PlayerFlags & PLAYER_FLAGS_GHOST) && (l_CharacterClass == CLASS_WARLOCK || l_CharacterClass == CLASS_HUNTER || l_CharacterClass == CLASS_DEATH_KNIGHT))
    {
        uint32 l_PetEntry = l_Fields[16].GetUInt32();

        if (CreatureTemplate const* l_CreatureTemplate = sObjectMgr->GetCreatureTemplate(l_PetEntry))
        {
            l_CharacterPetDisplayId = l_Fields[17].GetUInt32();
            l_CharacterPetLevel     = l_Fields[18].GetUInt16();
            l_CharacterPetFamily    = l_CreatureTemplate->family;
        }
    }

    if (l_CharacterLoginFlags & AT_LOGIN_CHANGE_RESET_FACTION_DATA)
    {
        std::string l_KnownTitles = l_Fields[22].GetString();
        Player::HandleFactionChangeActions(l_KnownTitles.c_str(), l_CharacterGuid, l_CharacterRace, false);
        Player::RemoveAtLoginFlagFromDB(l_Fields[0].GetUInt32(), AtLoginFlags(l_CharacterLoginFlags));
    }

    p_Data->appendPackGUID(l_CharacterGuid);                ///< Character GUID
    *p_Data << uint8(l_CharacterOrder);                     ///< List order
    *p_Data << uint8(l_CharacterRace);                      ///< Race
    *p_Data << uint8(l_CharacterClass);                     ///< Class
    *p_Data << uint8(l_CharacterGender);                    ///< Gender
    *p_Data << uint8(l_CharacterSkin);                      ///< Skin
    *p_Data << uint8(l_CharacterFace);                      ///< Face
    *p_Data << uint8(l_CharacterHairStyle);                 ///< Hair style
    *p_Data << uint8(l_CharacterHairColor);                 ///< Hair color
    *p_Data << uint8(l_CharacterFacialHair);                ///< Facial hair
    *p_Data << uint8(l_CharacterLevel);                     ///< Level
    *p_Data << uint32(l_CharacterZoneID);                   ///< Zone id
    *p_Data << uint32(l_CharacterMapID);                    ///< Map Id
    *p_Data << float(l_CharacterPositionX);                 ///< X
    *p_Data << float(l_CharacterPositionY);                 ///< Y
    *p_Data << float(l_CharacterPositionZ);                 ///< Z
    p_Data->appendPackGUID(l_CharacterGuildGuid);           ///< Character guild GUID
    *p_Data << uint32(l_CharacterFlags);                    ///< Character flags
    *p_Data << uint32(l_CharacterCustomizationFlags);       ///< atLoginFlags
    *p_Data << uint32(0);                                   ///< Character Boost
    *p_Data << uint32(l_CharacterPetDisplayId);             ///< Pet DisplayID
    *p_Data << uint32(l_CharacterPetLevel);                 ///< Pet level
    *p_Data << uint32(l_CharacterPetFamily);                ///< Pet family
    *p_Data << uint32(0);                                   ///< Profession 1
    *p_Data << uint32(0);                                   ///< Profession 2

    /// Character visible equipment
    bool l_IsOld = l_CharacterEquipment.size() != (InventorySlots::INVENTORY_SLOT_BAG_END * 3);

    for (uint8 l_EquipmentSlot = 0; l_EquipmentSlot < INVENTORY_SLOT_BAG_END; ++l_EquipmentSlot)
    {
        uint32 l_Visualbase = l_EquipmentSlot * 3;

        /// Every time you change the storage (adding or removing a value from the array), put the ancient loading here
        if (l_IsOld)
        {
            uint64 l_ItemDatas = GetUInt64ValueFromArray(l_CharacterEquipment, l_Visualbase);
            uint32 l_ItemID = ((uint32*)(&l_ItemDatas))[0];
            uint32 l_DisplayID = ((uint32*)(&l_ItemDatas))[1];

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_ItemID);
            if (!l_ItemTemplate)
            {
                *p_Data << uint32(0);                           ///< Item display ID
                *p_Data << uint32(0);                           ///< Enchantment aura ID
                *p_Data << uint8(0);                            ///< Inventory type
                continue;
            }

            SpellItemEnchantmentEntry const* l_ItemEnchantmentEntry = nullptr;

            uint32 l_EnchantmentData = GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 1);

            for (uint8 l_EnchantmentSlot = PERM_ENCHANTMENT_SLOT; l_EnchantmentSlot <= TEMP_ENCHANTMENT_SLOT; ++l_EnchantmentSlot)
            {
                /// Values stored in 2 uint16
                uint32 l_EnchantmentID = 0x0000FFFF & (l_EnchantmentData >> l_EnchantmentSlot * 16);
                if (!l_EnchantmentID)
                    continue;

                l_ItemEnchantmentEntry = sSpellItemEnchantmentStore.LookupEntry(l_EnchantmentID);

                if (l_ItemEnchantmentEntry)
                    break;
            }

            *p_Data << uint32(l_DisplayID ? l_DisplayID : l_ItemTemplate->DisplayInfoID);           ///< Item display ID
            *p_Data << uint32(l_ItemEnchantmentEntry ? l_ItemEnchantmentEntry->itemVisualID : 0);   ///< Enchantment aura ID
            *p_Data << uint8(l_ItemTemplate->InventoryType);                                        ///< Inventory type
        }
        else
        {
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase));
            if (!l_ItemTemplate)
            {
                *p_Data << uint32(0);                           ///< Item display ID
                *p_Data << uint32(0);                           ///< Enchantment aura ID
                *p_Data << uint8(0);                            ///< Inventory type
                continue;
            }

            *p_Data << uint32(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 1)); ///< Item display ID
            *p_Data << uint32(GetUInt32ValueFromArray(l_CharacterEquipment, l_Visualbase + 2)); ///< Enchantment aura ID
            *p_Data << uint8(l_ItemTemplate->InventoryType);                                    ///< Inventory type
        }
    }

    p_Data->WriteBits(l_CharacterName.size(), 6);           ///< Character name
    p_Data->WriteBit(l_CharacterFirstLogin);                ///< Is character first login
    p_Data->WriteBit(0);                                    ///< Boosted to level 90
    p_Data->WriteBits(0, 5);                                ///< Unk 19508
    p_Data->FlushBits();
    p_Data->WriteString(l_CharacterName);                   ///< Character name

    return true;
}

bool Player::ToggleAFK()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    bool state = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    // afk player not allowed in battleground
#ifndef CROSS
    if (state && InBattleground() && !InArena())
        LeaveBattleground();
#else /* CROSS */
    if (isAFK() && InBattleground() && !InArena())
    {
        if (Battleground* bg = GetBattleground())
        {
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
            bg->RemoveFromInterRealm(GetGUID());
        }
    }
#endif /* CROSS */

    return state;
}

bool Player::ToggleDND()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);

    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
}

uint8 Player::GetChatTag() const
{
    uint8 tag = CHAT_TAG_NONE;

    if (isGMChat())
        tag |= CHAT_TAG_GM;
    if (isDND())
        tag |= CHAT_TAG_DND;
    if (isAFK())
        tag |= CHAT_TAG_AFK;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
        tag |= CHAT_TAG_DEV;

    return tag;
}

bool Player::TeleportTo(uint32 p_MapID, float p_X, float p_Y, float p_Z, float p_O, uint32 p_Options)
{
    if (!MapManager::IsValidMapCoord(p_MapID, p_X, p_Y, p_Z, p_O))
    {
        sLog->outError(LogFilterType::LOG_FILTER_MAPS, "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
            p_MapID, p_X, p_Y, p_Z, p_O, GetGUIDLow(), GetName(), GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        return false;
    }

    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && DisableMgr::IsDisabledFor(DisableType::DISABLE_TYPE_MAP, p_MapID, this))
    {
        sLog->outError(LogFilterType::LOG_FILTER_MAPS, "Player (GUID: %u, name: %s) tried to enter a forbidden map %u", GetGUIDLow(), GetName(), p_MapID);
        SendTransferAborted(p_MapID, TRANSFER_ABORT_MAP_NOT_ALLOWED);
        return false;
    }

    /// Preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
    Pet* l_Pet = GetPet();

    MapEntry const* l_MapEntry = sMapStore.LookupEntry(p_MapID);

    /// Don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
    /// Don't let gm level > 1 either
    if (!InBattleground() && l_MapEntry->IsBattlegroundOrArena())
        return false;

    /// Client without expansion support
    if (GetSession()->Expansion() < l_MapEntry->Expansion())
    {
        sLog->outDebug(LogFilterType::LOG_FILTER_MAPS, "Player %s using client without required expansion tried teleport to non accessible map %u", GetName(), p_MapID);

        if (GetTransport())
        {
            m_transport->RemovePassenger(this);
            m_transport = nullptr;
            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
            m_movementInfo.t_time = 0;
            m_movementInfo.t_seat = -1;

            /// Teleport to near graveyard if on transport, looks blizz like :)
            RepopAtGraveyard();
        }

        SendTransferAborted(p_MapID, TRANSFER_ABORT_INSUF_EXPAN_LVL, l_MapEntry->Expansion());
        /// Normal client can't teleport to this map...
        return false;
    }
    else
        sLog->outDebug(LogFilterType::LOG_FILTER_MAPS, "Player %s is being teleported to map %u", GetName(), p_MapID);

    if (m_vehicle)
        ExitVehicle();

    /// Reset movement flags at teleport, because player will continue move with these flags after teleport
    SetUnitMovementFlags(GetUnitMovementFlags() & MOVEMENTFLAG_MASK_HAS_PLAYER_STATUS_OPCODE);
    m_movementInfo.ResetJump();
    DisableSpline();

    if (m_transport)
    {
        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_LEAVE_TRANSPORT))
        {
            m_transport->RemovePassenger(this);
            m_transport = nullptr;
            m_movementInfo.t_pos.Relocate(0.0f, 0.0f, 0.0f, 0.0f);
            m_movementInfo.t_time = 0;
            m_movementInfo.t_seat = -1;
            m_movementInfo.t_guid = 0;
        }
    }

    /// The player was ported to another map and loses the duel immediately.
    /// We have to perform this check before the teleport, otherwise the
    /// ObjectAccessor won't find the flag.
    if (m_Duel && GetMapId() != p_MapID && GetMap()->GetGameObject(GetGuidValue(EPlayerFields::PLAYER_FIELD_DUEL_ARBITER)))
        DuelComplete(DuelCompleteType::DUEL_FLED);

    /// Save previous location
    m_PreviousLocationMapId = GetMapId();
    m_PreviousLocationX     = GetPositionX();
    m_PreviousLocationY     = GetPositionY();
    m_PreviousLocationZ     = GetPositionZ();
    m_PreviousLocationO     = GetOrientation();

    if (GetMapId() == p_MapID)
    {
        /// Lets reset far teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportFar(false);
        /// Setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());
        /// If teleport spell is casted in Unit::Update() func
        /// Then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetSemaphoreTeleportNear(true);
            /// Lets save teleport destination for player
            m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
            m_teleport_options = p_Options;
            return true;
        }

        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_UNSUMMON_PET))
        {
            /// Same map, only remove pet if out of range for new position
            if (l_Pet && !l_Pet->IsWithinDist3d(p_X, p_Y, p_Z, GetMap()->GetVisibilityRange()))
            {
                UnsummonPetTemporaryIfAny();
                UnsummonCurrentBattlePetIfAny(true);
            }
        }

        if (!(p_Options & TeleportToOptions::TELE_TO_NOT_LEAVE_COMBAT))
            CombatStop();

        /// This will be used instead of the current location in SaveToDB
        m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
        SetFallInformation(0, p_Z);

        /// Code for finish transfer called in WorldSession::HandleMovementOpcodes()
        /// At client packet CMSG_MOVE_TELEPORT_ACK
        SetSemaphoreTeleportNear(true);
        /// Near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
        if (!GetSession()->PlayerLogout())
            SendTeleportPacket(m_teleport_dest);
    }
    else
    {
        /// Pandaria
        if (p_MapID == 870  && getLevel() < 85 && getClass() != Classes::CLASS_MONK  && !isGameMaster())
            return false;

        /// Deepholm
        if (p_MapID == 646  && getLevel() < 80 && !isGameMaster())
            return false;

        if (GetMapId() == 860 && GetTeamId() == TeamId::TEAM_NEUTRAL)
            return false;

        /// Far teleport to another map
        Map* l_OldMap = IsInWorld() ? GetMap() : nullptr;
        /// Check if we can enter before stopping combat / removing pet / totems / interrupting spells

        /// Check enter rights before map getting to avoid creating instance copy for player
        /// This check not dependent from map instance copy and same for all instance copies of selected map
        if (!sMapMgr->CanPlayerEnter(p_MapID, this, false))
            return false;

        if (Group* l_Group = GetGroup())
        {
            if (l_MapEntry->IsDungeon())
                l_Group->IncrementPlayersInInstance();
            else
                l_Group->DecrementPlayersInInstance();
        }

        /// I think this always returns true. Correct me if I am wrong.
        /// If the map is not created, assume it is possible to enter it.
        /// It will be created in the WorldPortAck.
        /// Lets reset near teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportNear(false);

        /// Setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());

        /// If teleport spell is casted in Unit::Update() func
        /// Then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetSemaphoreTeleportFar(true);

            /// Lets save teleport destination for player
            m_teleport_dest = WorldLocation(p_MapID, p_X, p_Y, p_Z, p_O);
            m_teleport_options = p_Options;
            return true;
        }

        SetSelection(0);
        CombatStop();
        ResetContestedPvP();

        /// Remove player from battleground on far teleport (when changing maps)
        if (Battleground const* l_Battleground = GetBattleground())
        {
            /// Note: at battleground join battleground id set before teleport
            /// And we already will found "current" battleground
            /// Just need check that this is targeted map or leave

            /// Don't teleport to entry point
            if (l_Battleground->GetMapId() != p_MapID)
#ifdef CROSS
            {
#endif /* CROSS */
                LeaveBattleground(false);
#ifdef CROSS
                SetSemaphoreTeleportFar(true);
                return true;
            }
#endif /* CROSS */
        }

        /// Remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
        if (l_MapEntry->IsBattleArena())
        {
            RemoveArenaSpellCooldowns(true);
            RemoveArenaAuras();

            if (l_Pet)
                l_Pet->RemoveArenaAuras();
        }

        /// Remove pet on map change
        if (l_Pet)
            UnsummonPetTemporaryIfAny();

        UnsummonCurrentBattlePetIfAny(true);

        /// Remove stealth on map change
        if (HasAuraType(AuraType::SPELL_AURA_MOD_STEALTH))
        {
            RemoveAurasByType(AuraType::SPELL_AURA_MOD_STEALTH);

            switch (getClass())
            {
                case Classes::CLASS_ROGUE:
                    RemoveSpellCooldown(1784);
                    RemoveSpellCooldown(115191);
                    break;
                case Classes::CLASS_DRUID:
                    RemoveSpellCooldown(5215);
                    break;
                default:
                    break;
            }
        }

        /// Remove all dyn objects and AreaTrigger
        RemoveAllDynObjects();
        RemoveAllAreasTrigger();

        /// Stop spellcasting
        /// Not attempt interrupt teleportation spell at caster teleport
        if (!(p_Options & TeleportToOptions::TELE_TO_SPELL))
        {
            if (IsNonMeleeSpellCasted(true))
                InterruptNonMeleeSpells(true);
        }

        /// Remove auras before removing from map...
        RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_CHANGE_MAP | SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_MOVE | SpellAuraInterruptFlags::AURA_INTERRUPT_FLAG_TURNING);

        if (!GetSession()->PlayerLogout())
        {
            /// Send transfer packets
            bool l_TransferSpellID = false;

            WorldPacket l_Data(Opcodes::SMSG_TRANSFER_PENDING, 50);

            l_Data << uint32(p_MapID);
            l_Data.WriteBit(m_transport != nullptr);
            l_Data.WriteBit(0);
            l_Data.FlushBits();

            if (m_transport)
                l_Data << m_transport->GetEntry() << GetMapId();

            if (l_TransferSpellID)
                l_Data << uint32(0);

            GetSession()->SendPacket(&l_Data);
        }

        /// Remove from old map now
        if (l_OldMap)
            l_OldMap->RemovePlayerFromMap(this, false);

        /// New final coordinates
        float l_FinalX = p_X;
        float l_FinalY = p_Y;
        float l_FinalZ = p_Z;
        float l_FinalO = p_O;

        if (m_transport)
        {
            l_FinalX += m_movementInfo.t_pos.GetPositionX();
            l_FinalY += m_movementInfo.t_pos.GetPositionY();
            l_FinalZ += m_movementInfo.t_pos.GetPositionZ();
            l_FinalO += m_movementInfo.t_pos.GetOrientation();
        }

        m_teleport_dest = WorldLocation(p_MapID, l_FinalX, l_FinalY, l_FinalZ, l_FinalO);
        SetFallInformation(0, l_FinalZ);

        /// If the player is saved before worldportack (at logout for example)
        /// This will be used instead of the current location in SaveToDB
        if (!GetSession()->PlayerLogout())
        {
            WorldPacket l_Data(Opcodes::SMSG_NEW_WORLD, 4 + 4 + 4 + 4 + 4 + 4);
            l_Data << uint32(p_MapID);                                  ///< uint32
            l_Data << float(m_teleport_dest.GetPositionX());            ///< float
            l_Data << float(m_teleport_dest.GetPositionY());            ///< float
            l_Data << float(m_teleport_dest.GetPositionZ());            ///< float
            l_Data << float(m_teleport_dest.GetOrientation());          ///< float
            l_Data << uint32(0);                                        ///< uint32 => TransferSpellID
            GetSession()->SendPacket(&l_Data);

            SendSavedInstances();
        }

        /// Move packet sent by client always after far teleport
        /// Code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
        SetSemaphoreTeleportFar(true);
    }

    return true;
}

/// MUST be call with "sMapMgr::AddCriticalOperation"
void Player::SwitchToPhasedMap(uint32 p_MapID)
{
    MapEntry const* l_MapEntry = sMapStore.LookupEntry(p_MapID);
    if (!l_MapEntry)
        return;

    // Check enter rights before map getting to avoid creating instance copy for player
    // this check not dependent from map instance copy and same for all instance copies of selected map
    if (!sMapMgr->CanPlayerEnter(p_MapID, this, false))
        return;

    if (Group* l_Group = GetGroup())
    {
        if (l_MapEntry->IsDungeon())
            l_Group->IncrementPlayersInInstance();
        else
            l_Group->DecrementPlayersInInstance();
    }

    SetSelection(0);
    CombatStop();
    ResetContestedPvP();

#ifndef CROSS
    // Remove player from battleground on far teleport (when changing maps)
    if (Battleground const* l_Battleground = GetBattleground())
    {
        if (l_Battleground->GetMapId() != p_MapID)
            LeaveBattleground(false);
    }
#endif

    // Remove pet on map change
    if (Pet* l_Pet = GetPet()) ///< l_Pet is unused
        UnsummonPetTemporaryIfAny();

    UnsummonCurrentBattlePetIfAny(true);

    // Remove all dynamic objects and AreaTrigger
    RemoveAllDynObjects();
    RemoveAllAreasTrigger();

    // Stop spellcasting
    // Not attempt interrupt teleportation spell at caster teleport
    if (IsNonMeleeSpellCasted(true))
        InterruptNonMeleeSpells(true);

    // Remove auras before removing from map...
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING);

    // Remove from old map now
    if (Map* l_OldMap = IsInWorld() ? GetMap() : NULL)
#ifdef CROSS
    {
        SetMapSwitchDestination(p_MapID);
#endif /* CROSS */
        l_OldMap->RemovePlayerFromMap(this, false);
#ifdef CROSS
    }
#endif /* CROSS */

    // Relocate the player to the teleport destination
    Map* l_NewMap = sMapMgr->CreateMap(p_MapID, this);
    if (!l_NewMap || !l_NewMap->CanEnter(this))
        return;

    // New final coordinates
    float l_X = GetPositionX();
    float l_Y = GetPositionY();
    float l_Z = GetPositionZ();
    float l_Orientation = GetOrientation();
    m_teleport_dest = WorldLocation(p_MapID, l_X, l_Y, l_Z, l_Orientation);
    SetFallInformation(0, l_Z);
    WorldLocation const l_NewLoc = GetTeleportDest();

    Relocate(&l_NewLoc);
    ResetMap();
    SetMap(l_NewMap);

    if (!GetSession()->PlayerLogout())
    {
        WorldPacket l_Data(SMSG_NEW_WORLD, 4 + 4 + 4 + 4 + 4 + 4);

        l_Data << uint32(p_MapID);                                  ///< uint32
        l_Data << float(m_teleport_dest.GetPositionX());            ///< float
        l_Data << float(m_teleport_dest.GetPositionY());            ///< float
        l_Data << float(m_teleport_dest.GetPositionZ());            ///< float
        l_Data << float(m_teleport_dest.GetOrientation());          ///< float
        l_Data << uint32(21);                                       ///< Reason

        GetSession()->SendPacket(&l_Data);
    }

    GetMap()->AddPlayerToMap(this, true);
#ifdef CROSS
    SetMapSwitchDestination(-1);
#endif /* CROSS */

    // Update zone immediately, otherwise leave channel will cause crash in mtmap
    uint32 l_NewZone, l_NewArea;
    GetZoneAndAreaId(l_NewZone, l_NewArea, true);
    UpdateZone(l_NewZone, l_NewArea);
}

bool Player::TeleportToBGEntryPoint(bool inter_realm /*= false*/)
{
    if (m_bgData.joinPos.m_mapId == MAPID_INVALID)
        return false;

    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
    return TeleportTo(m_bgData.joinPos, 0);
}

void Player::ProcessDelayedOperations()
{
    if (m_DelayedOperations == 0)
        return;

    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER)
    {
        ResurrectPlayer(0.0f, false);

        if (GetMaxHealth() > _resurrectionData->Health)
            SetHealth(_resurrectionData->Health);
        else
            SetFullHealth();

        if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
            SetPower(POWER_MANA, _resurrectionData->Mana);
        else
            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

        SetPower(POWER_RAGE, 0);
        SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
        SetPower(POWER_ECLIPSE, 0);

        if (uint32 aura = _resurrectionData->Aura)
            CastSpell(this, aura, true, NULL, nullptr, _resurrectionData->GUID);

        SpawnCorpseBones();

        /// Resurrecting - 60s aura preventing client from new res spells
        RemoveAura(160029);
    }

    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
        SaveToDB();

    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
        CastSpell(this, 26013, true);               // Deserter

    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
    {
        if (m_bgData.mountSpell)
        {
            CastSpell(this, m_bgData.mountSpell, true);
            m_bgData.mountSpell = 0;
        }
    }

    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
    {
        if (m_bgData.HasTaxiPath())
        {
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
            m_bgData.ClearTaxiPath();

            ContinueTaxiFlight();
        }
    }

    if (m_DelayedOperations & DELAYED_BG_GROUP_RESTORE)
    {
        if (Group *g = GetGroup())
            g->SendUpdateToPlayer(GetGUID());
    }

    if (m_DelayedOperations & DELAYED_PET_BATTLE_INITIAL)
    {
        if (PetBattle* l_Battle = sPetBattleSystem->GetBattle(_petBattleId))
        {
            uint8 l_TeamID = l_Battle->Teams[PETBATTLE_TEAM_1]->OwnerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

            PetBattleRequest l_Request;
            memcpy(&l_Request, &l_Battle->PvPMatchMakingRequest, sizeof(PetBattleRequest));

            if (l_TeamID == PETBATTLE_TEAM_2)
            {
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][0], l_Request.TeamPosition[PETBATTLE_TEAM_2][0]);
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][1], l_Request.TeamPosition[PETBATTLE_TEAM_2][1]);
                std::swap(l_Request.TeamPosition[PETBATTLE_TEAM_1][2], l_Request.TeamPosition[PETBATTLE_TEAM_2][2]);
            }

            l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[2] = GetMap()->GetHeight(l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[0], l_Battle->PvPMatchMakingRequest.PetBattleCenterPosition[1], MAX_HEIGHT);

            GetSession()->SendPetBattleFinalizeLocation(&l_Request);

            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED | UNIT_FLAG_IMMUNE_TO_NPC);
            SetFacingTo(GetAngle(l_Battle->PvPMatchMakingRequest.TeamPosition[!l_TeamID][0], l_Battle->PvPMatchMakingRequest.TeamPosition[!l_TeamID][1]));
            SetRooted(true);

            if (!l_Battle->PvPMatchMakingRequest.IsPvPReady[l_TeamID])
                l_Battle->PvPMatchMakingRequest.IsPvPReady[l_TeamID] = true;

            if (l_Battle->PvPMatchMakingRequest.IsPvPReady[PETBATTLE_TEAM_1] == true && l_Battle->PvPMatchMakingRequest.IsPvPReady[PETBATTLE_TEAM_2] == true)
                l_Battle->Begin();
        }
    }

    //we have executed ALL delayed ops, so clear the flag
    m_DelayedOperations = 0;
}

void Player::AddToWorld()
{
    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be added when logging in
    Unit::AddToWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->AddToWorld();
}

void Player::RemoveFromWorld()
{
    // cleanup
    if (IsInWorld())
    {
        ///- Release charmed creatures, unsummon totems and remove pets/guardians
        StopCastingCharm();
        StopCastingBindSight();
        UnsummonPetTemporaryIfAny();
        UnsummonCurrentBattlePetIfAny(true);
        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
    }

    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be removed when logging out
    Unit::RemoveFromWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
    {
        if (m_items[i])
            m_items[i]->RemoveFromWorld();
    }

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        iter->second->RemoveFromWorld();

    if (m_uint32Values)
    {
        if (WorldObject* viewpoint = GetViewpoint())
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s has viewpoint %u %u when removed from world", GetName(), viewpoint->GetEntry(), viewpoint->GetTypeId());
            SetViewpoint(viewpoint, false);
        }
    }
}

void Player::RegenerateAll()
{
    m_regenTimerCount += m_RegenPowerTimer;

    Classes l_Class = (Classes)getClass();
    switch (l_Class)
    {
        case Classes::CLASS_PALADIN:
            m_holyPowerRegenTimerCount += m_RegenPowerTimer;
            break;
        case Classes::CLASS_MONK:
            m_chiPowerRegenTimerCount += m_RegenPowerTimer;
            break;
        case Classes::CLASS_HUNTER:
            m_focusRegenTimerCount += m_RegenPowerTimer;
            break;
        case Classes::CLASS_WARLOCK:
        {
            switch (GetSpecializationId())
            {
                case SpecIndex::SPEC_WARLOCK_DEMONOLOGY:
                    m_demonicFuryPowerRegenTimerCount += m_RegenPowerTimer;
                    break;
                case SpecIndex::SPEC_WARLOCK_AFFLICTION:
                    m_soulShardsRegenTimerCount += m_RegenPowerTimer;
                    break;
                default:
                    break;
            }
            break;
        }
        case Classes::CLASS_DEATH_KNIGHT:   ///< Runes act as cooldowns, and they don't need to send any data
        {
            m_runicPowerRegenTimerCount += m_RegenPowerTimer;

            for (uint8 l_I = 0; l_I < MAX_RUNES; l_I += 2)
            {
                uint8 l_RuneToRegen = l_I;
                uint32 l_Cooldown = GetRuneCooldown(l_I);
                uint32 l_SecondRuneCooldown = GetRuneCooldown(l_I + 1);
                // Regenerate second rune of the same type only after first rune is off the cooldown
                if (l_SecondRuneCooldown && (l_Cooldown > l_SecondRuneCooldown || !l_Cooldown))
                {
                    l_RuneToRegen = l_I + 1;
                    l_Cooldown = l_SecondRuneCooldown;
                }

                if (l_Cooldown)
                    SetRuneCooldown(l_RuneToRegen, (l_Cooldown > m_RegenPowerTimer) ? l_Cooldown - m_RegenPowerTimer : 0);
            }
            break;
        }
        default:
            break;
    }

    Regenerate(POWER_MANA);
    Regenerate(POWER_ENERGY);

    if (m_regenTimerCount >= 2000)
    {
        // Not in combat or they have regeneration
        if (!isInCombat() || IsPolymorphed() || m_baseHealthRegen ||
            HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) ||
            HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT))
        {
            RegenerateHealth();
        }

        Regenerate(POWER_RAGE);

        m_regenTimerCount -= 2000;
    }

    if (m_focusRegenTimerCount >= 1000)
    {
        if (l_Class == CLASS_HUNTER)
            Regenerate(POWER_FOCUS);

        m_focusRegenTimerCount -= 1000;
    }

    if (m_holyPowerRegenTimerCount >= 10000 && l_Class == CLASS_PALADIN)
    {
        Regenerate(POWER_HOLY_POWER);
        m_holyPowerRegenTimerCount -= 10000;
    }

    if (m_runicPowerRegenTimerCount >= 1000 && l_Class == CLASS_DEATH_KNIGHT)
    {
        Regenerate(POWER_RUNIC_POWER);
        m_runicPowerRegenTimerCount -= 1000;
    }

    if (m_chiPowerRegenTimerCount >= 15000 && l_Class == CLASS_MONK)
    {
        Regenerate(POWER_CHI);
        m_chiPowerRegenTimerCount -= 15000;
    }

    if (m_demonicFuryPowerRegenTimerCount >= 100 && l_Class == CLASS_WARLOCK && (GetSpecializationId() == SPEC_WARLOCK_DEMONOLOGY))
    {
        Regenerate(POWER_DEMONIC_FURY);
        m_demonicFuryPowerRegenTimerCount -= 100;
    }

    if (m_soulShardsRegenTimerCount >= 20000 && l_Class == CLASS_WARLOCK && (GetSpecializationId() == SPEC_WARLOCK_AFFLICTION))
    {
        Regenerate(POWER_SOUL_SHARDS);
        m_soulShardsRegenTimerCount -= 20000;
    }

    m_RegenPowerTimer = 0;
}

void Player::Regenerate(Powers power)
{
    int32 maxValue = GetMaxPower(power);
    if (!maxValue)
        return;

    int32 curValue = GetPower(power);

    /// @Todo: possible use of miscvalueb instead of amount
    if (HasAuraTypeWithValue(SPELL_AURA_PREVENT_REGENERATE_POWER, power))
        return;

    /// Skip regeneration for power type we cannot have // Custom MoP script
    uint32 powerIndex = GetPowerIndex(power, getClass());
    if (powerIndex == MAX_POWERS)
        return;

    float addvalue = 0.0f;

    /// Powers now benefit from haste.
    float HastePct = 2.0f - GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);

    bool l_PreventDefault = false;
    sScriptMgr->OnPlayerRegenPower(this, power, addvalue, l_PreventDefault);

    if (!l_PreventDefault)
    {
        switch (power)
        {
            /// Regenerate Mana
            case POWER_MANA:
            {
                float ManaIncreaseRate = sWorld->getRate(RATE_POWER_MANA);

                if (isInCombat())
                    addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_RegenPowerTimer) + CalculatePct(0.001f, HastePct));
                else
                    addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) *  ManaIncreaseRate * ((0.001f * m_RegenPowerTimer) + CalculatePct(0.001f, HastePct));
                break;
            }
            /// Regenerate Rage
            case POWER_RAGE:
            {
                if (!isInCombat() && !HasAuraType(SPELL_AURA_INTERRUPT_REGEN))
                {
                    float RageDecreaseRate = sWorld->getRate(RATE_POWER_RAGE_LOSS);
                    addvalue += (-25 * RageDecreaseRate / HastePct); ///< 2.5 rage by tick (= 2 seconds => 1.25 rage/sec)
                }
                break;
            }
            /// Regenerate Focus
            case POWER_FOCUS:
            {
                float l_HastePct = 1.0f / GetFloatValue(UNIT_FIELD_MOD_HASTE);
                addvalue += 4.0f * l_HastePct * sWorld->getRate(RATE_POWER_FOCUS);
                break;
            }
            /// Regenerate Energy
            case POWER_ENERGY:
                addvalue += ((0.01f * m_RegenPowerTimer) * sWorld->getRate(RATE_POWER_ENERGY) * HastePct);
                break;
            /// Regenerate Runic Power
            case POWER_RUNIC_POWER:
            {
                float RunicPowerDecreaseRate = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
                if (!isInCombat() && !HasAuraType(SPELL_AURA_INTERRUPT_REGEN))
                {
                    addvalue += (-15 * RunicPowerDecreaseRate / HastePct); ///< 1.5 RunicPower by tick
                }
                if (isInCombat() && HasAura(50029))
                    addvalue += 10.0f * RunicPowerDecreaseRate; ///< 1 RunicPower by tick

                break;
            }
            /// Regenerate Holy Power
            case POWER_HOLY_POWER:
            {
                if (!isInCombat())
                    addvalue += -1.0f; ///< remove 1 each 10 sec
                break;
            }
            /// Regenerate Chi
            case POWER_CHI:
            {
                if (!isInCombat())
                    addvalue += -1.0f; ///< remove 1 each 10 sec
                break;
            }
            /// Regenerate Demonic Fury
            case POWER_DEMONIC_FURY:
            {
                if (!isInCombat() && GetPower(POWER_DEMONIC_FURY) >= 300 && GetShapeshiftForm() != FORM_METAMORPHOSIS)
                    addvalue += -1.0f;    ///< remove 1 each 100ms
                else if (!isInCombat() && GetPower(POWER_DEMONIC_FURY) < 200 && GetShapeshiftForm() != FORM_METAMORPHOSIS)
                    addvalue += 1.0f;     ///< give 1 each 100ms while player has less than 200 demonic fury

                if (!HasAura(114168))
                {
                    if (GetPower(POWER_DEMONIC_FURY) <= 40)
                    {
                        if (HasAura(103958))
                            RemoveAura(103958);

                        if (HasAura(54879))
                            RemoveAura(54879);
                    }
                }

                /// Demonic Fury visuals
                if (GetPower(POWER_DEMONIC_FURY) == 1000)
                    CastSpell(this, 131755, true);
                else if (GetPower(POWER_DEMONIC_FURY) >= 500)
                {
                    CastSpell(this, 122738, true);

                    if (HasAura(131755))
                        RemoveAura(131755);
                }
                else
                {
                    if (HasAura(122738))
                        RemoveAura(122738);
                    if (HasAura(131755))
                        RemoveAura(131755);
                }

                break;
            }
            /// Regenerate Soul Shards
            case POWER_SOUL_SHARDS:
            {
                /// If isn't in combat, gain 1 shard every 20s
                if (!isInCombat())
                    SetPower(POWER_SOUL_SHARDS, GetPower(POWER_SOUL_SHARDS) + 100, true);

                if (HasAura(56241))
                {
                    if (GetPower(POWER_SOUL_SHARDS) < 200 && GetPower(POWER_SOUL_SHARDS) >= 100)
                    {
                        RemoveAura(123730);            ///< 2 shards visual
                        CastSpell(this, 123728, true); ///< 1 shard visual
                    }
                    else if (GetPower(POWER_SOUL_SHARDS) < 300)
                    {
                        CastSpell(this, 123728, true); ///< 1 shard visual
                        CastSpell(this, 123730, true); ///< 2 shards visual
                        RemoveAura(123731);            ///< 3 shards visual
                    }
                    else if (GetPower(POWER_SOUL_SHARDS) < 400)
                    {
                        CastSpell(this, 123728, true); ///< 1 shard visual
                        CastSpell(this, 123730, true); ///< 2 shards visual
                        CastSpell(this, 123731, true); ///< 3 shards visual
                    }
                }
                break;
            }
            default:
                break;
        }
    }

    /// Mana regen calculated in Player::UpdateManaRegen()
    if (power != POWER_MANA && power != POWER_CHI && power != POWER_HOLY_POWER && power != POWER_SOUL_SHARDS && power != POWER_BURNING_EMBERS && power != POWER_DEMONIC_FURY)
    {
        AuraEffectList const& ModPowerRegenPCTAuras = GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
        for (AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
            if (Powers((*i)->GetMiscValue()) == power)
                AddPct(addvalue, (*i)->GetAmount());

        // Butchery requires combat for this effect
        if (power != POWER_RUNIC_POWER || isInCombat())
            addvalue += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, power) * ((power != POWER_ENERGY) ? m_regenTimerCount : m_RegenPowerTimer) / (5 * IN_MILLISECONDS);
    }

    if (addvalue < 0.0f)
    {
        if (curValue == 0)
            return;
    }
    else if (addvalue > 0.0f)
    {
        if (curValue == maxValue)
            return;
    }
    else
        return;

    addvalue += m_powerFraction[powerIndex];

    int32 integerValue = uint32(fabs(addvalue));

    if (addvalue < 0.0f)
    {
        if (curValue > integerValue)
        {
            curValue -= integerValue;
            m_powerFraction[powerIndex] = addvalue + integerValue;
        }
        else
        {
            curValue = 0;
            m_powerFraction[powerIndex] = 0;
        }
    }
    else
    {
        curValue += integerValue;

        if (curValue > maxValue)
        {
            curValue = maxValue;
            m_powerFraction[powerIndex] = 0;
        }
        else
            m_powerFraction[powerIndex] = addvalue - integerValue;
    }

    SetPower(power, curValue, true);
}

void Player::RegenerateHealth()
{
    uint32 curValue = GetHealth();
    uint32 maxValue = GetMaxHealth();

    if (curValue >= maxValue)
        return;

    float HealthIncreaseRate = sWorld->getRate(RATE_HEALTH);

    float addvalue = 0.0f;
    bool inFight = isInCombat();

    // polymorphed case
    if (IsPolymorphed())
        addvalue = (float)GetMaxHealth()/3;
    // normal regen case (maybe partly in combat case)
    else if (!inFight || HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
    {
        addvalue = HealthIncreaseRate; ///< addvalue is never read 01/18/16
        if (getLevel() < 15)
            addvalue = (0.20f*((float)GetMaxHealth())/getLevel()*HealthIncreaseRate);
        else
            addvalue = 0.015f*((float)GetMaxHealth())*HealthIncreaseRate;

        AuraEffectList const& mModHealthRegenPct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
        for (AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
            AddPct(addvalue, (*i)->GetAmount());

        addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * 2 * IN_MILLISECONDS / (5 * IN_MILLISECONDS);

        if (inFight)
            ApplyPct(addvalue, GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));

        if (!IsStandState())
            addvalue *= 1.5f;
    }

    // always regeneration bonus (including combat)
    addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
    addvalue += m_baseHealthRegen / 2.5f;

    if (addvalue < 0)
        addvalue = 0;

    ModifyHealth(int32(addvalue));
}

void Player::ResetAllPowers()
{
    if (getClass() == CLASS_ROGUE || getClass() == CLASS_DRUID)
        ClearComboPoints();

    SetHealth(GetMaxHealth());
    SetPower(POWER_BURNING_EMBERS, 10);
    SetPower(POWER_CHI, 0);
    SetPower(POWER_DEMONIC_FURY, 200);
    SetPower(POWER_ECLIPSE, 0);
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_RAGE, 0);
    SetPower(POWER_RUNIC_POWER, 0);
    SetPower(POWER_SHADOW_ORB, 0);
    SetPower(POWER_SOUL_SHARDS, 400);
}

bool Player::CanInteractWithQuestGiver(Object* questGiver)
{
    switch (questGiver->GetTypeId())
    {
        case TYPEID_UNIT:
            return GetNPCIfCanInteractWith(questGiver->GetGUID(), UNIT_NPC_FLAG_QUESTGIVER) != NULL;
        case TYPEID_GAMEOBJECT:
            return GetGameObjectIfCanInteractWith(questGiver->GetGUID(), GAMEOBJECT_TYPE_QUESTGIVER) != NULL;
        case TYPEID_PLAYER:
            return isAlive() && questGiver->ToPlayer()->isAlive();
        case TYPEID_ITEM:
            return isAlive();
        default:
            break;
    }
    return false;
}

/// Temp enum, need more reverse work on LogicOpperators in CGPlayer_C::MatchesCondition
enum
{
    LOGIC_FLAG_01                       = 0x00000001,
    LOGIC_FLAG_02                       = 0x00000002,
    LOGIC_FLAG_03                       = 0x00000004,
    LOGIC_FLAG_04                       = 0x00000008,
    LOGIC_FLAG_05                       = 0x00000010,
    LOGIC_FLAG_06                       = 0x00000020,
    LOGIC_FLAG_COL_0_XOR_RESULT_TRUE    = 0x00010000,
    LOGIC_FLAG_COL_1_XOR_RESULT_TRUE    = 0x00020000,
    LOGIC_FLAG_COL_2_XOR_RESULT_TRUE    = 0x00040000,
    LOGIC_FLAG_COL_3_XOR_RESULT_TRUE    = 0x00080000,
};

std::pair<bool, std::string> Player::EvalPlayerCondition(uint32 p_ConditionsID, bool /*p_FailIfConditionNotFound*/) const
{
    PlayerConditionEntry const* l_Entry = sPlayerConditionStore.LookupEntry(p_ConditionsID);

    if (!l_Entry && !sScriptMgr->HasPlayerConditionScript(p_ConditionsID))
        return std::pair<bool, std::string>(false, "Condition entry not found");

    if (sScriptMgr->HasPlayerConditionScript(p_ConditionsID))
    {
        if (!sScriptMgr->EvalPlayerConditionScript(p_ConditionsID, l_Entry, this))
            return std::pair<bool, std::string>(false, "Condition script failed");

        return std::pair<bool, std::string>(true, "");
    }

    auto EvalMatch = [](bool * p_Matches, uint32 p_Flags) -> bool
    {
        bool l_Result = p_Matches[0] && p_Matches[1] && p_Matches[2] && p_Matches[3];
        bool l_FirstMatchFlagMatch  = (!!(p_Flags & LOGIC_FLAG_COL_0_XOR_RESULT_TRUE)) ^ p_Matches[0];
        bool l_SecondMatchFlagMatch = (!!(p_Flags & LOGIC_FLAG_COL_1_XOR_RESULT_TRUE)) ^ p_Matches[1];
        bool l_ThirdMatchFlagMatch  = (!!(p_Flags & LOGIC_FLAG_COL_2_XOR_RESULT_TRUE)) ^ p_Matches[2];
        bool l_FourthMatchFlagMatch = (!!(p_Flags & LOGIC_FLAG_COL_3_XOR_RESULT_TRUE)) ^ p_Matches[3];

        if (p_Flags & LOGIC_FLAG_01)
        {
            if (l_FirstMatchFlagMatch)
                l_Result = l_SecondMatchFlagMatch;
        }
        else if (p_Flags & LOGIC_FLAG_02)
            l_Result = l_FirstMatchFlagMatch | l_SecondMatchFlagMatch;

        if (p_Flags & LOGIC_FLAG_03)
            l_Result = l_Result & l_ThirdMatchFlagMatch;
        else if (p_Flags & LOGIC_FLAG_04)
            l_Result = l_Result | l_ThirdMatchFlagMatch;

        if (p_Flags & LOGIC_FLAG_05)
        {
            if (!l_Result)
                return false;
        }
        else if (p_Flags & LOGIC_FLAG_06)
            l_Result = l_FourthMatchFlagMatch | l_Result;

        return l_Result;
    };

    /// @TODO : Flags

    #pragma region Level conditions
    if (l_Entry->MinLevel != 0 && getLevel() < l_Entry->MinLevel)
        return std::pair<bool, std::string>(false, "Failed on MinLevel => dbc(" + std::to_string(l_Entry->MinLevel) + ") you(" + std::to_string(getLevel()) + ")");
    if (l_Entry->MaxLevel != 0 && getLevel() > l_Entry->MaxLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxLevel => dbc(" + std::to_string(l_Entry->MaxLevel) + ") you(" + std::to_string(getLevel()) + ")");
    #pragma endregion Level conditions

    #pragma region Class, Race, Gender, NativeGender
    if (l_Entry->RaceMask != 0 && (l_Entry->RaceMask & getRaceMask()) == 0)
        return std::pair<bool, std::string>(false, "Failed on RaceMask => dbc(" + std::to_string(l_Entry->RaceMask) + ") you(" + std::to_string(getRaceMask()) + ")");
    if (l_Entry->ClassMask != 0 && (l_Entry->ClassMask & getClassMask()) == 0)
        return std::pair<bool, std::string>(false, "Failed on ClassMask => dbc(" + std::to_string(l_Entry->ClassMask) + ") you(" + std::to_string(getClassMask()) + ")");
    if (l_Entry->Gender != -1 && l_Entry->Gender != getGender())
        return std::pair<bool, std::string>(false, "Failed on Gender => dbc(" + std::to_string(l_Entry->Gender) + ") you(" + std::to_string(getGender()) + ")");
    if (l_Entry->NativeGender != -1 && l_Entry->NativeGender != getGender())
        return std::pair<bool, std::string>(false, "Failed on NativeGender => dbc(" + std::to_string(l_Entry->NativeGender) + ") you(" + std::to_string(getGender()) + ")");
    #pragma endregion Class, Race, Gender, NativeGender

    #pragma region Skills
    for (uint32 l_I = 0; l_I < 4; ++l_I)
    {
        if (l_Entry->SkillID[l_I] != 0)
        {
            if (!HasSkill(l_Entry->SkillID[l_I]))
                return std::pair<bool, std::string>(false, "Failed on SkillID => dbc(" + std::to_string(l_Entry->SkillID[l_I]) + ") you don't known this skill");

            int32 l_Skill = (int32)GetSkillValue(l_Entry->SkillID[l_I]);

            if (l_Entry->MinSkill[l_I] != 0 && l_Skill < l_Entry->MinSkill[l_I])
                return std::pair<bool, std::string>(false, "Failed on MinSkill => dbc(" + std::to_string(l_Entry->MinSkill[l_I]) + ") you(" + std::to_string(l_Skill) + ")");
            if (l_Entry->MaxSkill[l_I] != 0 && l_Skill > l_Entry->MaxSkill[l_I])
                return std::pair<bool, std::string>(false, "Failed on MaxSkill => dbc(" + std::to_string(l_Entry->MaxSkill[l_I]) + ") you(" + std::to_string(l_Skill) + ")");
        }
    }
    #pragma endregion Skills

    /// @TODO : SkillLogic

    #pragma region Language
    if (l_Entry->LanguageID != 0)
    {
        uint32 l_SkillID = lang_description[l_Entry->LanguageID].skill_id;

        if (!HasSkill(l_SkillID))
            return std::pair<bool, std::string>(false, "Failed on LanguageID => dbc(" + std::to_string(l_Entry->LanguageID) + ") you don't known this language");

        int32 l_Skill = (int32)GetSkillValue(l_SkillID);

        if (l_Entry->MinLanguage != 0 && l_Skill < l_Entry->MinLanguage)
            return std::pair<bool, std::string>(false, "Failed on MinLanguage => dbc(" + std::to_string(l_Entry->MinLanguage) + ") you(" + std::to_string(l_Skill) + ")");
        if (l_Entry->MaxLanguage != 0 && l_Skill > l_Entry->MaxLanguage)
            return std::pair<bool, std::string>(false, "Failed on MaxLanguage => dbc(" + std::to_string(l_Entry->MaxLanguage) + ") you(" + std::to_string(l_Skill) + ")");
    }
    #pragma endregion Language

    /// @TODO : MinFaction
    /// @TODO : MinReputation
    /// @TODO : MaxReputation
    /// @TODO : ReputationLogic
    /// @TODO : MinPVPRank
    /// @TODO : MaxPVPRank
    /// @TODO : PVPMedal

    #pragma region PrevQuestLogic, PrevQuestID
    if (l_Entry->PrevQuestID[0] || l_Entry->PrevQuestID[1] || l_Entry->PrevQuestID[2] || l_Entry->PrevQuestID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->PrevQuestID[0] != 0) l_Matches[0] = GetQuestRewardStatus(l_Entry->PrevQuestID[0]);
        if (l_Entry->PrevQuestID[1] != 0) l_Matches[1] = GetQuestRewardStatus(l_Entry->PrevQuestID[1]);
        if (l_Entry->PrevQuestID[2] != 0) l_Matches[2] = GetQuestRewardStatus(l_Entry->PrevQuestID[2]);
        if (l_Entry->PrevQuestID[3] != 0) l_Matches[3] = GetQuestRewardStatus(l_Entry->PrevQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->PrevQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on PrevQuestID");
    }
    #pragma endregion PrevQuestLogic, PrevQuestID

    #pragma region CurrQuestLogic, CurrQuestID
    if (l_Entry->CurrQuestID[0] || l_Entry->CurrQuestID[1] || l_Entry->CurrQuestID[2] || l_Entry->CurrQuestID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrQuestID[0] != 0) l_Matches[0] = HasQuest(l_Entry->CurrQuestID[0]);
        if (l_Entry->CurrQuestID[1] != 0) l_Matches[1] = HasQuest(l_Entry->CurrQuestID[1]);
        if (l_Entry->CurrQuestID[2] != 0) l_Matches[2] = HasQuest(l_Entry->CurrQuestID[2]);
        if (l_Entry->CurrQuestID[3] != 0) l_Matches[3] = HasQuest(l_Entry->CurrQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->CurrQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrQuestID");
    }
    #pragma endregion CurrQuestLogic, CurrQuestID

    #pragma region CurrentCompletedQuestLogic, CurrentCompletedQuestID
    if (l_Entry->CurrentCompletedQuestID[0] || l_Entry->CurrentCompletedQuestID[1] || l_Entry->CurrentCompletedQuestID[2] || l_Entry->CurrentCompletedQuestID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrentCompletedQuestID[0] != 0) l_Matches[0] = GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[0]);
        if (l_Entry->CurrentCompletedQuestID[1] != 0) l_Matches[1] = GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[1]);
        if (l_Entry->CurrentCompletedQuestID[2] != 0) l_Matches[2] = GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[2]);
        if (l_Entry->CurrentCompletedQuestID[3] != 0) l_Matches[3] = GetQuestRewardStatus(l_Entry->CurrentCompletedQuestID[3]);

        if (!EvalMatch(l_Matches, l_Entry->CurrentCompletedQuestLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrentCompletedQuestID");
    }
    #pragma endregion CurrentCompletedQuestLogic, CurrentCompletedQuestID

    #pragma region SpellLogic, SpellID
    if (l_Entry->SpellID[0] || l_Entry->SpellID[1] || l_Entry->SpellID[2] || l_Entry->SpellID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->SpellID[0] != 0) l_Matches[0] = HasSpell(l_Entry->SpellID[0]) || HasGlyph(l_Entry->SpellID[0]);
        if (l_Entry->SpellID[1] != 0) l_Matches[1] = HasSpell(l_Entry->SpellID[1]) || HasGlyph(l_Entry->SpellID[1]);
        if (l_Entry->SpellID[2] != 0) l_Matches[2] = HasSpell(l_Entry->SpellID[2]) || HasGlyph(l_Entry->SpellID[2]);
        if (l_Entry->SpellID[3] != 0) l_Matches[3] = HasSpell(l_Entry->SpellID[3]) || HasGlyph(l_Entry->SpellID[3]);

        if (!EvalMatch(l_Matches, l_Entry->SpellLogic))
            return std::pair<bool, std::string>(false, "Failed on SpellID");
    }
    #pragma endregion SpellLogic, SpellID

    #pragma region ItemLogic, ItemID, ItemCount
    if (l_Entry->ItemID[0] || l_Entry->ItemID[1] || l_Entry->ItemID[2] || l_Entry->ItemID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->ItemID[0] != 0) l_Matches[0] = HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[0] ? 1 : l_Entry->ItemCount[0], false);
        if (l_Entry->ItemID[1] != 0) l_Matches[1] = HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[1] ? 1 : l_Entry->ItemCount[1], false);
        if (l_Entry->ItemID[2] != 0) l_Matches[2] = HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[2] ? 1 : l_Entry->ItemCount[2], false);
        if (l_Entry->ItemID[3] != 0) l_Matches[3] = HasItemCount(l_Entry->ItemID[0], !l_Entry->ItemCount[3] ? 1 : l_Entry->ItemCount[3], false);

        if (!EvalMatch(l_Matches, l_Entry->ItemLogic))
            return std::pair<bool, std::string>(false, "Failed on ItemID");
    }
    #pragma endregion ItemLogic, ItemID, ItemCount

    /// @TODO : ItemFlags

    #pragma region Explored
    auto IsAreaExplored = [this](uint32 p_AreaID) -> bool ///< p_AreaID is unused
    {
        uint16 l_AreaFlag = sAreaStore.LookupEntry(0) ? sAreaStore.LookupEntry(0)->AreaBit : 0xFFFF;

        if (l_AreaFlag == 0xFFFF)
            return false;
        int l_Offset = l_AreaFlag / 32;

        if (l_Offset >= PLAYER_EXPLORED_ZONES_SIZE)
            return false;

        uint32 l_Value = (uint32)(1 << (l_AreaFlag % 32));

        if (!(GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + l_Offset) & l_Value))
            return false;

        return true;
    };

    if (l_Entry->Explored[0] != 0 && !IsAreaExplored(l_Entry->Explored[0]))
        return std::pair<bool, std::string>(false, "Failed on Explored[0] => dbc(" + std::to_string(l_Entry->Explored[0]) + ") area is not explored");
    if (l_Entry->Explored[1] != 0 && !IsAreaExplored(l_Entry->Explored[1]))
        return std::pair<bool, std::string>(false, "Failed on Explored[1] => dbc(" + std::to_string(l_Entry->Explored[1]) + ") area is not explored");
    #pragma endregion Explored

    /// @TODO : Time

    #pragma region AuraSpellLogic, AuraSpellID
    if (l_Entry->AuraSpellID[0] || l_Entry->AuraSpellID[1] || l_Entry->AuraSpellID[2] || l_Entry->AuraSpellID[3])
    {
        bool l_Matches[] { true, true, true, true };

        if (l_Entry->AuraSpellID[0] != 0) l_Matches[0] = HasAura(l_Entry->AuraSpellID[0]);
        if (l_Entry->AuraSpellID[1] != 0) l_Matches[1] = HasAura(l_Entry->AuraSpellID[1]);
        if (l_Entry->AuraSpellID[2] != 0) l_Matches[2] = HasAura(l_Entry->AuraSpellID[2]);
        if (l_Entry->AuraSpellID[3] != 0) l_Matches[3] = HasAura(l_Entry->AuraSpellID[3]);

        if (!EvalMatch(l_Matches, l_Entry->AuraSpellLogic))
            return std::pair<bool, std::string>(false, "Failed on AuraSpellID");
    }
    #pragma endregion AuraSpellLogic, AuraSpellID

    #pragma region WorldStateExpressionID
    if (l_Entry->WorldStateExpressionID != 0)
    {
        WorldStateExpressionEntry const* l_Expression = sWorldStateExpressionStore.LookupEntry(l_Entry->WorldStateExpressionID);

        if (!l_Expression)
            return std::pair<bool, std::string>(false, "Failed on WorldStateExpressionID => DBC WorldStateExpression entry not found");

        if (!l_Expression->Eval(this))
            return std::pair<bool, std::string>(false, "Failed on WorldStateExpressionID => eval failed");
    }
    #pragma endregion WorldStateExpressionID

    #pragma region Weather
    if (l_Entry->WeatherID != 0)
    {
        AreaTableEntry const* l_Zone = GetAreaEntryByAreaID(GetZoneId());

        if (!l_Zone)
            return std::pair<bool, std::string>(false, "Failed on WeatherID => DBC AreaTable entry not found");

        Weather * l_Weather = WeatherMgr::FindWeather(l_Zone->ID);

        if (!l_Weather)
            return std::pair<bool, std::string>(false, "Failed on WeatherID => no valid weather found");

        if (l_Weather->GetType() != l_Entry->WeatherID) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
            return std::pair<bool, std::string>(false, "Failed on WeatherID => dbc(" + std::to_string(l_Entry->WeatherID) + ") you(" + std::to_string(l_Weather->GetType()) + ")");
    }
    #pragma endregion Weather

    /// @TODO : PartyStatus
    /// @TODO : LifetimeMaxPVPRank

    #pragma region AchievementLogic, Achievement
    if (l_Entry->Achievement[0] || l_Entry->Achievement[1] || l_Entry->Achievement[2] || l_Entry->Achievement[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->Achievement[0] != 0) l_Matches[0] = GetAchievementMgr().HasAchieved(l_Entry->Achievement[0]);
        if (l_Entry->Achievement[1] != 0) l_Matches[1] = GetAchievementMgr().HasAchieved(l_Entry->Achievement[1]);
        if (l_Entry->Achievement[2] != 0) l_Matches[2] = GetAchievementMgr().HasAchieved(l_Entry->Achievement[2]);
        if (l_Entry->Achievement[3] != 0) l_Matches[3] = GetAchievementMgr().HasAchieved(l_Entry->Achievement[3]);

        if (!EvalMatch(l_Matches, l_Entry->AchievementLogic))
            return std::pair<bool, std::string>(false, "Failed on Achievement");
    }
    #pragma endregion AchievementLogic, Achievement

    /// @TODO : LfgLogic
    /// @TODO : LfgStatus
    /// @TODO : LfgCompare
    /// @TODO : LfgValue

    #pragma region AreaLogic, AreaID
    if (l_Entry->AreaID[0] || l_Entry->AreaID[1] || l_Entry->AreaID[2] || l_Entry->AreaID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->AreaID[0] != 0) l_Matches[0] = l_Entry->AreaID[0] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[1] != 0) l_Matches[1] = l_Entry->AreaID[1] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[2] != 0) l_Matches[2] = l_Entry->AreaID[2] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
        if (l_Entry->AreaID[3] != 0) l_Matches[3] = l_Entry->AreaID[3] == GetAreaId(); ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')

        if (!EvalMatch(l_Matches, l_Entry->AreaLogic))
            return std::pair<bool, std::string>(false, "Failed on AreaID");
    }
    #pragma endregion AreaLogic, AreaID

    #pragma region CurrencyLogic, CurrencyID, CurrencyCount
    if (l_Entry->CurrencyID[0] || l_Entry->CurrencyID[1] || l_Entry->CurrencyID[2] || l_Entry->CurrencyID[3])
    {
        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->CurrencyID[0] != 0) l_Matches[0] = HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[0] ? 1 : l_Entry->CurrencyCount[0]));
        if (l_Entry->CurrencyID[1] != 0) l_Matches[1] = HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[1] ? 1 : l_Entry->CurrencyCount[1]));
        if (l_Entry->CurrencyID[2] != 0) l_Matches[2] = HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[2] ? 1 : l_Entry->CurrencyCount[2]));
        if (l_Entry->CurrencyID[3] != 0) l_Matches[3] = HasCurrency(l_Entry->CurrencyID[0], (!l_Entry->CurrencyCount[3] ? 1 : l_Entry->CurrencyCount[3]));

        if (!EvalMatch(l_Matches, l_Entry->CurrencyLogic))
            return std::pair<bool, std::string>(false, "Failed on CurrencyID");
    }
    #pragma endregion CurrencyLogic, CurrencyID, CurrencyCount

    #pragma region QuestKillID, QuestKillLogic, QuestKillMonster
    if (l_Entry->QuestKillID != 0)
    {
        if (!HasQuest(l_Entry->QuestKillID))
            return std::pair<bool, std::string>(false, "Failed on QuestKillID => dbc(" + std::to_string(l_Entry->QuestKillID) + ") you didn't have quest(" + std::to_string(l_Entry->QuestKillID) + ")");

        auto GetNpcObjectiveID = [](uint32 p_QuestID, uint32 p_NPCID) -> uint32
        {
            Quest const* l_Quest = sObjectMgr->GetQuestTemplate(p_QuestID);

            if (!l_Quest)
                return 0;

            for (auto l_Obective : l_Quest->QuestObjectives)
            {
                if (l_Obective.Type != QUEST_OBJECTIVE_TYPE_NPC)
                    continue;

                if (l_Obective.ObjectID == p_NPCID) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                    return l_Obective.ID;
            }

            return 0;
        };

        bool l_Matches[4] { true, true, true, true };

        if (l_Entry->QuestKillMonster[0] != 0) l_Matches[0] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[0]) && GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[0]));
        if (l_Entry->QuestKillMonster[1] != 0) l_Matches[1] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[1]) && GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[1]));
        if (l_Entry->QuestKillMonster[2] != 0) l_Matches[2] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[2]) && GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[2]));
        if (l_Entry->QuestKillMonster[3] != 0) l_Matches[3] = GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[3]) && GetQuestObjectiveCounter(GetNpcObjectiveID(l_Entry->QuestKillID, l_Entry->QuestKillMonster[3]));

        if (!EvalMatch(l_Matches, l_Entry->QuestKillLogic))
            return std::pair<bool, std::string>(false, "Failed on QuestKillMonster");
    }
    #pragma endregion QuestKillID, QuestKillLogic, QuestKillMonster

    /// @TODO : MinExpansionLevel
    /// @TODO : MaxExpansionLevel
    /// @TODO : MinExpansionTier
    /// @TODO : MaxExpansionTier
    /// @OBSOLETE : MinGuildLevel
    /// @OBSOLETE : MaxGuildLevel
    /// @TODO : PhaseUseFlags
    /// @TODO : PhaseID
    /// @TODO : PhaseGroupID

    #pragma region MinAvgItemLevel, MaxAvgItemLevel
    if (l_Entry->MinAvgItemLevel != 0 && GetAverageItemLevelTotal() < (uint32)l_Entry->MinAvgItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MinAvgItemLevel => dbc(" + std::to_string(l_Entry->MinAvgItemLevel) + ") you(" + std::to_string(GetAverageItemLevelTotal()) + ")");
    if (l_Entry->MaxAvgItemLevel != 0 && GetAverageItemLevelTotal() > (uint32)l_Entry->MaxAvgItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxAvgItemLevel => dbc(" + std::to_string(l_Entry->MaxAvgItemLevel) + ") you(" + std::to_string(GetAverageItemLevelTotal()) + ")");
    #pragma endregion MinAvgItemLevel, MaxAvgItemLevel
    
    #pragma region MinAvgEquippedItemLevel, MaxAvgItemLevel
    if (l_Entry->MinAvgEquippedItemLevel != 0 && GetAverageItemLevelEquipped() < (uint32)l_Entry->MinAvgEquippedItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MinAvgEquippedItemLevel => dbc(" + std::to_string(l_Entry->MinAvgEquippedItemLevel) + ") you(" + std::to_string(GetAverageItemLevelEquipped()) + ")");
    if (l_Entry->MaxAvgEquippedItemLevel != 0 && GetAverageItemLevelEquipped() > (uint32)l_Entry->MaxAvgEquippedItemLevel)
        return std::pair<bool, std::string>(false, "Failed on MaxAvgEquippedItemLevel => dbc(" + std::to_string(l_Entry->MaxAvgEquippedItemLevel) + ") you(" + std::to_string(GetAverageItemLevelEquipped()) + ")");
    #pragma endregion MinAvgEquippedItemLevel, MaxAvgItemLevel

    /// @TODO : ChrSpecializationIndex
    /// @TODO : ChrSpecializationRole
    /// @TODO : PowerType
    /// @TODO : PowerTypeComp
    /// @TODO : PowerTypeValue

    return std::pair<bool, std::string>(true, "");
}

Creature* Player::GetNPCIfCanInteractWith(uint64 p_Guid, uint32 p_NpcFlagMask)
{
    /// Unit checks
    if (!p_Guid)
        return nullptr;

    if (!IsInWorld())
        return nullptr;

    if (isInFlight())
        return nullptr;

    /// Exist (we need look pets also for some interaction (quest/etc)
    Creature* l_Creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, p_Guid);
    if (!l_Creature)
        return nullptr;

    /// Deathstate checks
    if (!isAlive() && !(l_Creature->GetCreatureTemplate()->type_flags & CreatureTypeFlags::CREATURE_TYPE_FLAG_GHOST_VISIBLE))
        return nullptr;

    /// Alive or spirit healer
    if (!l_Creature->isAlive() && !(l_Creature->GetCreatureTemplate()->type_flags & CreatureTypeFlags::CREATURE_TYPE_FLAG_CAN_INTERACT_WHILE_DEAD))
        return nullptr;

    /// Appropriate npc type
    if (p_NpcFlagMask && !l_Creature->HasFlag(EUnitFields::UNIT_FIELD_NPC_FLAGS, p_NpcFlagMask))
    {
        /// Targetted object doesn't have required flag.
        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_NO_FLAG);

        return nullptr;
    }

    /// Not allow interaction under control, but allow with own pets
    if (l_Creature->GetCharmerGUID())
        return nullptr;

    /// Not enemy
    if (l_Creature->IsHostileTo(this))
        return nullptr;

    /// Not unfriendly
    if (FactionTemplateEntry const* l_FactionTemplate = sFactionTemplateStore.LookupEntry(l_Creature->getFaction()))
    {
        if (l_FactionTemplate->Faction)
        {
            if (FactionEntry const* l_Faction = sFactionStore.LookupEntry(l_FactionTemplate->Faction))
            {
                if (l_Faction->ReputationIndex >= 0 && GetReputationMgr().GetRank(l_Faction) <= ReputationRank::REP_UNFRIENDLY)
                    return nullptr;
            }
        }
    }

    /// Not too far
    bool l_ByPassDist = false;
    if (l_Creature->IsAIEnabled)
        l_ByPassDist = l_Creature->AI()->CanByPassDistanceCheck();

    if (!l_ByPassDist && !l_Creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return nullptr;

    return l_Creature;
}

Creature* Player::GetNPCIfCanInteractWithFlag2(uint64 guid, uint32 npcflagmask)
{
    // unit checks
    if (!guid)
        return NULL;

    if (!IsInWorld())
        return NULL;

    if (isInFlight())
        return NULL;

    // exist (we need look pets also for some interaction (quest/etc)
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (!creature)
        return NULL;

    // Deathstate checks
    if (!isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_GHOST_VISIBLE))
        return NULL;

    // alive or spirit healer
    if (!creature->isAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_CAN_INTERACT_WHILE_DEAD))
        return NULL;

    // appropriate npc type
    if (npcflagmask && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS + 1, npcflagmask))
        return NULL;

    // not allow interaction under control, but allow with own pets
    if (creature->GetCharmerGUID())
        return NULL;

    // not enemy
    if (creature->IsHostileTo(this))
        return NULL;

    // not unfriendly
    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
        if (factionTemplate->Faction)
            if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->Faction))
                if (faction->ReputationIndex >= 0 && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
                    return NULL;

    // not too far
    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return NULL;

    return creature;
}

GameObject* Player::GetGameObjectIfCanInteractWith(uint64 guid, GameobjectTypes type) const
{
    if (GameObject* go = GetMap()->GetGameObject(guid))
    {
        if (go->GetGoType() == type)
        {
            float maxdist;
            switch (type)
            {
                // TODO: find out how the client calculates the maximal usage distance to spellless working
                // gameobjects like guildbanks and mailboxes - 10.0 is a just an abitrary choosen number
                case GAMEOBJECT_TYPE_GUILD_BANK:
                case GAMEOBJECT_TYPE_MAILBOX:
                    maxdist = 10.0f;
                    break;
                case GAMEOBJECT_TYPE_FISHINGHOLE:
                    maxdist = 20.0f+CONTACT_DISTANCE;       // max spell range
                    break;
                default:
                    maxdist = INTERACTION_DISTANCE;
                    break;
            }

            if (go->IsWithinDistInMap(this, maxdist))
                return go;

            sLog->outDebug(LOG_FILTER_MAPS, "IsGameObjectOfTypeInRange: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)", go->GetGOInfo()->name.c_str(),
                go->GetGUIDLow(), GetName(), GetGUIDLow(), go->GetDistance(this));
        }
    }
    return NULL;
}

bool Player::IsUnderWater() const
{
    return IsInWater() &&
        GetPositionZ() < (GetBaseMap()->GetWaterLevel(GetPositionX(), GetPositionY())-2);
}

void Player::SetInWater(bool apply)
{
    if (m_isInWater == apply)
        return;

    //define player in water by opcodes
    //move player's guid into HateOfflineList of those mobs
    //which can't swim and move guid back into ThreatList when
    //on surface.
    //TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
    m_isInWater = apply;

    // remove auras that need water/land
    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);

    getHostileRefManager().updateThreatTables();
}

void Player::SetGameMaster(bool p_On)
{
    if (p_On && !(m_ExtraFlags & PLAYER_EXTRA_GM_ON))
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
        setFaction(35);
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* l_Pet = GetPet())
        {
            l_Pet->setFaction(35);
            l_Pet->getHostileRefManager().setOnlineOfflineState(false);
        }

        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        ResetContestedPvP();

        getHostileRefManager().setOnlineOfflineState(false);
        CombatStopWithPets();

        SetPhaseMask(uint32(PHASEMASK_ANYWHERE), false);    // see and visible in all phases
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
    else if (!p_On && m_ExtraFlags & PLAYER_EXTRA_GM_ON)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_ON;
        setFactionForRace(getRace());
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* l_Pet = GetPet())
        {
            l_Pet->setFaction(getFaction());
            l_Pet->getHostileRefManager().setOnlineOfflineState(true);
        }

        // restore FFA PvP Server state
        if (sWorld->IsFFAPvPRealm())
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);

        // restore FFA PvP area state, remove not allowed for GM mounts
        UpdateArea(m_areaUpdateId);

        getHostileRefManager().setOnlineOfflineState(true);
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);

        phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_SERVERSIDE_CHANGED);
        phaseMgr.Update();
    }

    UpdateObjectVisibility();
}

void Player::SetGMVisible(bool on)
{
    if (on)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_INVISIBLE;         //remove flag
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
    }
    else
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_INVISIBLE;          //add flag

        SetAcceptWhispers(false);
        SetGameMaster(true);

        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
}

bool Player::IsGroupVisibleFor(Player const* p) const
{
    switch (sWorld->getIntConfig(CONFIG_GROUP_VISIBILITY))
    {
        default: return IsInSameGroupWith(p);
        case 1:  return IsInSameRaidWith(p);
        case 2:  return GetTeam() == p->GetTeam();
    }
}

bool Player::IsInSameGroupWith(Player const* p) const
{
    return p == this || (GetGroup() != NULL &&
        GetGroup() == p->GetGroup() &&
        GetGroup()->SameSubGroup(this, p));
}

///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
/// \todo Shouldn't we also check if there is no other invitees before disbanding the group?
void Player::UninviteFromGroup()
{
    uint32 groupGUID = GetGroupInvite();
    if (!groupGUID)
        return;

    Group* group = sGroupMgr->GetGroupByGUID(groupGUID);
    if (!group)
        return;

    group->RemoveInvite(this);

    if (group->GetMembersCount() <= 1)                       // group has just 1 member => disband
    {
        if (group->IsCreated())
        {
            group->Disband(true);
        }
        else
        {
            group->RemoveAllInvites();
            delete group;
        }
    }
}

void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
{
    if (group)
    {
        group->RemoveMember(guid, method, kicker, reason);
        group = NULL;
    }
}

void Player::SendLogXPGain(uint32 GivenXP, Unit* victim, uint32 BonusXP, bool recruitAFriend, float group_rate)
{
    WorldPacket data(SMSG_LOG_XP_GAIN);

    ObjectGuid victimGuid = victim ? victim->GetGUID() : 0;
    data.appendPackGUID(victimGuid);
    data << uint32(GivenXP);
    data << uint8(victim ? 0 : 1);                  ///< 00-kill_xp type, 01-non_kill_xp type
    data << uint32(GivenXP + BonusXP);
    data << float(group_rate);                      ///< Group bonus
    data.WriteBit(recruitAFriend);
    data.FlushBits();                               ///< Refer A Friend

    GetSession()->SendPacket(&data);
}

void Player::GiveXP(uint32 xp, Unit* victim, float group_rate)
{
    if (xp < 1)
        return;

    if (!isAlive() && !GetBattlegroundId())
        return;

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
        return;

    if (victim && victim->GetTypeId() == TYPEID_UNIT && !victim->ToCreature()->hasLootRecipient())
        return;

    uint8 level = getLevel();

    sScriptMgr->OnGivePlayerXP(this, xp, victim);

    // Favored experience increase START
    uint32 zone = GetZoneId();
    float favored_exp_mult = 0;
    if ((HasAura(32096) || HasAura(32098)) && (zone == 3483 || zone == 3562 || zone == 3836 || zone == 3713 || zone == 3714))
        favored_exp_mult = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
    xp = uint32(xp * (1 + favored_exp_mult));
    // Favored experience increase END

    // XP to money conversion processed in Player::RewardQuest
    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    // VIP xp reward
    if (GetSession()->IsPremium())
        xp *= 1.15f;

    uint32 bonus_xp = 0;
    bool recruitAFriend = GetsRecruitAFriendBonus(true);

    // RaF does NOT stack with rested experience
    if (recruitAFriend)
        bonus_xp = 2 * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
    else
        bonus_xp = victim ? GetXPRestBonus(xp) : 0; // XP resting bonus

    SendLogXPGain(xp, victim, bonus_xp, recruitAFriend, group_rate);

    uint32 curXP = GetUInt32Value(PLAYER_FIELD_XP);
    uint32 nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    uint32 newXP = curXP + xp + bonus_xp;

    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        newXP -= nextLvlXP;

        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            GiveLevel(level + 1);

        level = getLevel();
        nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    }

    SetUInt32Value(PLAYER_FIELD_XP, newXP);
}

// Give xp when gathering herbalism and mininh
// Formulas found here : http://www.wowwiki.com/Formulas:Gather_XP
void Player::GiveGatheringXP()
{
    uint32 level = getLevel();
    uint32 gain = 0;

    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    if (level < 50)
        gain = 12.76f * level;
    else if (level > 49 && level < 60)
        gain = 25 * level - 550;
    else if (level > 59 && level < 70)
        gain = 20 * level - 200;
    else if (level > 69 && level < 80)
        gain = 100 * level - 6600;
    else if (level > 79 && level < 85)
        gain = 750 * level - 58250;
    else if (level > 84 && level < 90)
        gain = 1720 * level - 138800; // (7400 - 14280),  Guessed, @TODO : find blizzlike formula (7400 - 14280)
    else if (level > 89 && level < 95)
        gain = -225 * level + 23100;
    else if (level > 94 && level < 100)
        gain = -228 * level + 24512;    ///< Guessed

    float GatheringXpRate = 1;

    if (GetPersonnalXpRate())
        GatheringXpRate = GetPersonnalXpRate();
    else
        GatheringXpRate = sWorld->getRate(RATE_XP_GATHERING);

    gain *= GatheringXpRate;
    GiveXP(gain, nullptr);
}

// Update player to next level
// Current player experience not update (must be update by caller)
void Player::GiveLevel(uint8 level)
{
    uint8 oldLevel = getLevel();
    if (level == oldLevel)
        return;

    /// Reset MMR values
    for (uint8 l_I = 0; l_I < ArenaSlots::MAX_PVP_SLOT; ++l_I)
    {
        SetArenaPersonalRating(l_I, sWorld->getIntConfig(WorldIntConfigs::CONFIG_ARENA_START_PERSONAL_RATING));
        SetArenaMatchMakerRating(l_I, sWorld->getIntConfig(WorldIntConfigs::CONFIG_ARENA_START_MATCHMAKER_RATING));
    }

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, basehp, basemana);

    // send levelup info to client
    WorldPacket data(SMSG_LEVELUP_INFO, 100);

    data << uint32(level);
    data << uint32(int32(basehp) - int32(GetCreateHealth()));

    data << uint32(int32(basemana) - int32(GetCreateMana()));
    data << uint32(0);
    data << uint32(0);
    data << uint32(0);
    data << uint32(0);
    data << uint32(0);

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)       // Stats loop (0-4)
        data << uint32(int32(info.stats[i]) - GetCreateStat(Stats(i)));

    bool talent = false;

    switch (level)
    {
        case 15:
        case 30:
        case 45:
        case 60:
        case 75:
        case 90:
        case 100:
            talent = true;
            break;
        default:
            break;
    }

    data << uint32(talent);                                 // Has talent

    GetSession()->SendPacket(&data);

    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(level));

    //update level, max level of skills
    m_Played_time[PLAYED_TIME_LEVEL] = 0;                   // Level Played Time reset

    SetLevel(level);

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);
    SetCreateMana(basemana);

    InitTalentForLevel();
    InitSpellForLevel();
    InitTaxiNodesForLevel();
    InitGlyphsForLevel();

    UpdateAllStats();
    RescaleAllItemsIfNeeded(true);

    // Refresh amount of all auras (aura which use scaling for basepoint calcul need to be refresh at level up ...)
    AuraApplicationMap const& l_AppliedAuras =  GetAppliedAuras();
    for (AuraApplicationMap::const_iterator i = l_AppliedAuras.begin(); i != l_AppliedAuras.end(); ++i)
        i->second->GetBase()->RecalculateAmountOfEffects(true);

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
    SetPower(POWER_FOCUS, 0);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();

#ifndef CROSS
    if (MailLevelReward const* mailReward = sObjectMgr->GetMailLevelReward(level, getRaceMask()))
    {
        //- @TODO: Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft(mailReward->mailTemplateId).SendMailTo(trans, this, MailSender(MAIL_CREATURE, mailReward->senderEntry));
        CharacterDatabase.CommitTransaction(trans);
    }
#endif

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_LEVEL);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddConditionType(CONDITION_LEVEL);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    // Refer-A-Friend
/// Commented due to action bar fix, need more research
//     if (GetSession()->GetRecruiterId())
//         if (level < sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
//             if (level % 2 == 0)
//             {
//                 ++m_grantableLevels;
//
//                 if (!HasByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_FIELD_BYTES_OFFSET_RAF_GRANTABLE_LEVEL, 0x01))
//                     SetByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_FIELD_BYTES_OFFSET_RAF_GRANTABLE_LEVEL, 0x01);
//             }

    if (level == 85)
    {
        uint32 idQuest;
        if (GetTeam() == TEAM_ALLIANCE)
        {
            idQuest = 29547;
        }
        else
            idQuest = 29611;

        Quest const* quest = sObjectMgr->GetQuestTemplate(idQuest);
        if (quest)
            AddQuest(quest, NULL);
    }
    else if (level >= 90 && GetQuestStatus(36881) == QUEST_STATUS_NONE)
    {
        if (Quest const* l_Quest = sObjectMgr->GetQuestTemplate(36881)) // Add quest for starting WoD missions and go to Draenor
        {
            if (GetQuestStatus(36881) == QUEST_STATUS_NONE || GetQuestStatus(36881) == QUEST_STATUS_FAILED)
                AddQuest(l_Quest, NULL);
        }
    }

    sScriptMgr->OnPlayerLevelChanged(this, oldLevel);

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->OnOwnerLevelChange(level);
#endif
}

void Player::InitTalentForLevel()
{
    uint8 level = getLevel();
    // talents base at level diff (talents = level - 9 but some can be used already)
    if (level < 15)
    {
        // Remove all talent points
        if (GetUsedTalentCount() > 0)                           // Free any used talents
        {
            ResetTalents(true);
            SetFreeTalentPoints(0);
        }
    }
    else
    {
        if (level < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL) || GetSpecsCount() == 0)
        {
            SetSpecsCount(1);
            SetActiveSpec(0);
        }

        uint32 talentPointsForLevel = CalculateTalentsPoints();

        // if used more that have then reset
        if (GetUsedTalentCount() > talentPointsForLevel)
        {
            if (!AccountMgr::IsAdminAccount(GetSession()->GetSecurity()))
                ResetTalents(true);
            else
                SetFreeTalentPoints(0);
        }
        // else update amount of free points
        else
            SetFreeTalentPoints(talentPointsForLevel - GetUsedTalentCount());
    }

    if (!GetSession()->PlayerLoading())
        SendTalentsInfoData(false);                         // update at client
}


void Player::InitSpellForLevel()
{
    std::set<uint32> l_SpellList = sSpellMgr->GetSpellClassList(getClass());

    // Add talent placeholders spells to spelllist
    for (uint32 l_TalentPlaceHolderSpell : sSpellMgr->GetTalentPlaceHoldersSpell())
        l_SpellList.insert(l_TalentPlaceHolderSpell);

    uint8 l_Level = getLevel();
    uint32 l_SpecializationId = GetSpecializationId();

    for (uint32 l_SpellId : l_SpellList)
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellId);
        if (!l_SpellInfo)
            continue;

        if (HasSpell(l_SpellId))
            continue;

        if (!l_SpellInfo->SpecializationIdList.empty())
        {
            bool find = false;

            for (uint32 itr : l_SpellInfo->SpecializationIdList)
            if (itr == l_SpecializationId)
                find = true;

            if (!find)
                continue;
        }

        if (!IsSpellFitByClassAndRace(l_SpellId))
            continue;

        // Hack fix - Dual Wield cannot be on MistWeaver monks
        if (l_SpecializationId == SPEC_MONK_MISTWEAVER && (l_SpellId == 674 || l_SpellId == 124146))
            continue;

        // Hack fix - Monks can't get Daggers competance
        if (getClass() == CLASS_MONK && l_SpellId == 1180)
            continue;

        if (l_SpellInfo->SpellLevel <= l_Level)
            learnSpell(l_SpellId, false);
    }

    const std::set<MinorTalentEntry const*>* l_PerkList = sSpellMgr->GetSpecializationPerks(l_SpecializationId);
    if (l_PerkList)
    {
        // perks are starting at level 90
#define PERK_START_LEVEL 90

        float l_LevelDiff = getLevel() - PERK_START_LEVEL;
        float l_Coeff = (MAX_LEVEL - PERK_START_LEVEL) / float(l_PerkList->size());

        if (l_LevelDiff > 0)
        {
            uint8 l_CurrentIndex = floor(((l_LevelDiff - 1.0f) > 0.0f ? (l_LevelDiff - 1.0f) : 0) / l_Coeff);

            for (auto perk : *l_PerkList)
            if (l_CurrentIndex >= perk->orderIndex)
                learnSpell(perk->spellID, false);
        }
    }

    // Aberration, Two Forms, Darkflight, Flayer, Viciousness
    if (getRace() == RACE_WORGEN)
    {
        learnSpell(68976, false);
        learnSpell(68996, false);
        learnSpell(97709, false);
        learnSpell(68992, false);
        learnSpell(68978, false);
        learnSpell(68975, false);
    }
    else
    {
        if (HasSpell(68996))
            removeSpell(68996, false, false);
        if (HasSpell(68976))
            removeSpell(68976, false, false);
        if (HasSpell(97709))
            removeSpell(97709, false, false);
        if (HasSpell(68992))
            removeSpell(68992, false, false);
        if (HasSpell(68978))
            removeSpell(68978, false, false);
        if (HasSpell(68975))
            removeSpell(68975, false, false);
    }

    if (getRace() == Races::RACE_NIGHTELF)
        learnSpell(154748, false);

    // Worgen players are automatically granted Apprentice Riding at level 20, as well, due to their racial ability Running Wild.
    // http://www.wowhead.com/spell=33388
    if (l_Level >= 20 && getRace() == RACE_WORGEN)
    {
        learnSpell(87840, false); // Running Wild
        learnSpell(33388, false); // Apprentice Riding
    }
    else
    {
        // Only for Worgens with level >= 20
        if (HasSpell(87840))
            removeSpell(87840, false, false);

        // Some spells allowing flying mounts in some maps
        if (HasSpell(115913) && getLevel() < 90)
            removeSpell(115913, false, false);
        if (HasSpell(90267) && getLevel() < 60)
            removeSpell(90267, false, false);
    }

    // Fix Pick Lock update at each level
    if (HasSpell(1804) && getLevel() > 20)
        SetSkill(921, GetSkillStep(921), (getLevel() * 5), (getLevel() * 5));

    /// Missing mining skill (shop issue)
    if (GetSkillValue(SkillType::SKILL_MINING) >= 700 && !HasSpell(158754))
        learnSpell(158754, false);
}

void Player::RemoveSpecializationSpells()
{
    std::list<uint32> spellToRemove;

    for (auto itr : GetSpellMap())
    {
        SpellInfo const* spell = sSpellMgr->GetSpellInfo(itr.first);
        if (spell && !spell->SpecializationIdList.empty()
            && spell->Id != 674)    ///< Ambidextrie hackfix, removed at spec switch (rogue)
            spellToRemove.push_back(itr.first);
    }

    for (uint32 i = 0; i < sMinorTalentStore.GetNumRows(); i++)
        if (MinorTalentEntry const* minorTalent = sMinorTalentStore.LookupEntry(i))
            if (HasSpell(minorTalent->spellID))
                spellToRemove.push_back(minorTalent->spellID);

    spellToRemove.push_back(48517); // Lunar eclipse
    spellToRemove.push_back(48518); // Solar eclipse
    spellToRemove.push_back(107095); // Lunar eclipse (overrider)

    for (auto itr : spellToRemove)
        removeSpell(itr);
}

void Player::InitStatsForLevel(bool reapplyMods)
{
    if (reapplyMods)                                        //reapply stats values only on .reset stats (level) command
        _RemoveAllStatBonuses();

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), basehp, basemana);

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);

    SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));

    // reset before any aura state sources (health set/aura apply)
    SetUInt32Value(UNIT_FIELD_AURA_STATE, 0);

    // set default cast time multiplier
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, 0.0f);
    SetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, 0.0f);

    // reset size before reapply auras
    SetObjectScale(1.0f);

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);

    //set create powers
    SetCreateMana(basemana);

    SetArmor(int32(m_createStats[STAT_AGILITY]*2));

    InitStatBuffMods();

    //reset rating fields values
    for (uint16 index = PLAYER_FIELD_COMBAT_RATINGS; index < PLAYER_FIELD_COMBAT_RATINGS + MAX_COMBAT_RATING; ++index)
        SetUInt32Value(index, 0);

    SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, 0);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_DONE_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_PERIODIC_HEALING_DONE_PERCENT, 1.0f);
    for (uint8 i = 0; i < 7; ++i)
    {
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i, 0);
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, 0);
        SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT+i, 1.00f);
    }

    SetFloatValue(PLAYER_FIELD_MOD_SPELL_POWER_PERCENT, 1.0f);

    //reset attack power, damage and attack speed fields
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME, 2000.0f);
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 1, 2000.0f); // offhand attack time
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME, 2000.0f);

    SetFloatValue(UNIT_FIELD_MIN_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE, 0.0f);
    for (uint8 l_WeaponAttackType = WeaponAttackType::BaseAttack; l_WeaponAttackType < WeaponAttackType::MaxAttack; l_WeaponAttackType++)
    {
        SetFloatValue(PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS       + l_WeaponAttackType, 1.0f);
        SetFloatValue(PLAYER_FIELD_WEAPON_ATK_SPEED_MULTIPLIERS + l_WeaponAttackType, 1.0f);
    }

    SetInt32Value(UNIT_FIELD_ATTACK_POWER,            0);
    SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, 0.0f);
    SetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER,     0);
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, 0.0f);

    // Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    SetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE, 0.0f);

    for (uint8 l_I = 0; l_I < PlayerAvgItemLevelOffsets::MaxAvgItemLevel; l_I++)
        SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + l_I, 0.0f);

    // Init spell schools (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    for (uint8 i = 0; i < 7; ++i)
        SetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE+i, 0.0f);

    SetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE, 0.0f);

    // Static 30% damage blocked
    SetUInt32Value(PLAYER_FIELD_SHIELD_BLOCK, 30);

    // Dodge percentage
    SetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE, 0.0f);

    // set armor (resistance 0) to original value (create_agility*2)
    SetArmor(int32(m_createStats[STAT_AGILITY]*2));
    SetResistanceBuffMods(SpellSchools(0), true, 0.0f);
    SetResistanceBuffMods(SpellSchools(0), false, 0.0f);
    // set other resistance to original value (0)
    for (uint8 i = 1; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetResistance(SpellSchools(i), 0);
        SetResistanceBuffMods(SpellSchools(i), true, 0.0f);
        SetResistanceBuffMods(SpellSchools(i), false, 0.0f);
    }

    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, 0);
    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE, 0);
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetUInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i, 0);
        SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i, 0.0f);
    }
    // Reset no reagent cost field
    for (uint8 i = 0; i < 3; ++i)
        SetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK + i, 0);
    // Init data for form but skip reapply item mods for form
    InitDataForForm(reapplyMods);

    // save new stats
    for (uint8 i = POWER_MANA; i < MAX_POWERS; ++i)
        SetMaxPower(Powers(i), GetCreatePowers(Powers(i)));

    SetMaxHealth(basehp);                     // stamina bonus will applied later

    // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
    SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, 0);

    // cleanup unit flags (will be re-applied if need at aura load).
    RemoveFlag(UNIT_FIELD_FLAGS,
        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_ATTACKABLE_1 |
        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
        UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
        UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
        UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
        UNIT_FLAG_SKINNABLE      | UNIT_FLAG_MOUNT        | UNIT_FLAG_TAXI_FLIGHT      );
    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);   // must be set

    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);// must be set

    // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK | PLAYER_FLAGS_DND | PLAYER_FLAGS_GM | PLAYER_FLAGS_GHOST | PLAYER_ALLOW_ONLY_ABILITY);

    RemoveStandFlags(UNIT_STAND_FLAGS_ALL);                 // one form stealth modified bytes
    RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP | UNIT_BYTE2_FLAG_SANCTUARY);

    // restore if need some important flags
    SetUInt32Value(PLAYER_FIELD_OVERRIDE_SPELLS_ID, 0);                 // flags empty by default
    //SetUInt32Value(PLAYER_FIELD_AURA_VISION, 0);                        // flags empty by default


    if (reapplyMods)                                        // reapply stats values only on .reset stats (level) command
        _ApplyAllStatBonuses();

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));

    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));

    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
    SetPower(POWER_RUNIC_POWER, 0);
    SetPower(POWER_CHI, 0);
    SetPower(POWER_SOUL_SHARDS, 100);
    SetPower(POWER_DEMONIC_FURY, 200);
    SetPower(POWER_BURNING_EMBERS, 10);
    SetPower(POWER_SHADOW_ORB, 0);
    SetPower(POWER_ECLIPSE, 0);

    /// All players have 15% of expertise, even if it's hidden stat
    /// https://twitter.com/holinka/status/520348936872030209
    SetFloatValue(PLAYER_FIELD_MAINHAND_EXPERTISE, 15.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_EXPERTISE, 15.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_EXPERTISE, 15.0f);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();
}

void Player::SendKnownSpells()
{
    uint32 l_SpellCount = 0;

    WorldPacket l_Data(SMSG_SEND_KNOWN_SPELLS, 25 * 1024);

    l_Data.WriteBit(1);
    l_Data.FlushBits();

    l_Data << uint32(l_SpellCount);

    // spell count placeholder
    for (PlayerSpellMap::const_iterator l_It = m_spells.begin(); l_It != m_spells.end(); ++l_It)
    {
        if (!l_It->second)
            continue;

        if (l_It->second->state == PlayerSpellState::PLAYERSPELL_REMOVED
            || l_It->second->state == PlayerSpellState::PLAYERSPELL_TEMPORARY)
            continue;

        if (!l_It->second->active || l_It->second->disabled)
            continue;

        l_Data << uint32(l_It->first);

        ++l_SpellCount;
    }

    l_Data.wpos(1);
    l_Data << uint32(l_SpellCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::RemoveMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->messageID == id)
        {
            //do not delete item, because Player::removeMail() is called when returning mail to sender.
            m_mail.erase(itr);
            return;
        }
    }
}

void Player::SendMailResult(uint32 p_MailID, MailResponseType p_MailAction, MailResponseResult p_MailError, uint32 p_EquipError, uint32 p_ItemGuid, uint32 p_ItemCount)
{
    WorldPacket l_Data(SMSG_SEND_MAIL_RESULT, 4 * 6);

    l_Data << uint32(p_MailID);
    l_Data << uint32(p_MailAction);
    l_Data << uint32(p_MailError);
    l_Data << uint32(p_EquipError);
    l_Data << uint32(p_ItemGuid);
    l_Data << uint32(p_ItemCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendNewMail()
{
    // deliver undelivered mail
    WorldPacket l_Data(SMSG_RECEIVED_MAIL, 4);
    l_Data << (uint32)0;

    GetSession()->SendPacket(&l_Data);
}

void Player::UpdateNextMailTimeAndUnreads()
{
    // calculate next delivery time (min. from non-delivered mails
    // and recalculate unReadMail
    time_t cTime = time(NULL);
    m_nextMailDelivereTime = 0;
    unReadMails = 0;
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->deliver_time > cTime)
        {
            if (!m_nextMailDelivereTime || m_nextMailDelivereTime > (*itr)->deliver_time)
                m_nextMailDelivereTime = (*itr)->deliver_time;
        }
        else if (((*itr)->checked & MAIL_CHECK_MASK_READ) == 0)
            ++unReadMails;
    }
}

void Player::AddNewMailDeliverTime(time_t deliver_time)
{
    if (deliver_time <= time(NULL))                          // ready now
    {
        ++unReadMails;
        SendNewMail();
    }
    else                                                    // not ready and no have ready mails
    {
        if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
            m_nextMailDelivereTime = deliver_time;
    }
}

bool Player::AddTalent(uint32 spellId, uint8 spec, bool learning)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
        return false;

    PlayerTalentMap::iterator itr = GetTalentMap(spec)->find(spellId);
    if (itr != GetTalentMap(spec)->end())
        itr->second->state = PLAYERSPELL_UNCHANGED;
    else
    {

        PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;
        PlayerTalent* newtalent = new PlayerTalent();

        newtalent->state = state;
        newtalent->spec = spec;

        (*GetTalentMap(spec))[spellId] = newtalent;
        return true;
    }
    return false;
}

bool Player::addSpell(uint32 spellId, bool active, bool learning, bool dependent, bool disabled, bool loading /*= false*/, bool p_IsMountFavorite, bool p_LearnBattlePet, bool p_FromShopItem)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return false;

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
        return false;

    if (sSpellMgr->IsSpellForbidden(spellId) && !isGameMaster() && sWorld->getBoolConfig(CONFIG_SPELL_FORBIDDEN))
    {
#ifndef CROSS
        std::string banString;
        banString = "Auto-ban for spell cheat ";
        char buff[2048];

        sprintf(buff, "(spellId : %u)", (uint32)spellId);
        banString += buff;
        sWorld->BanAccount(BAN_CHARACTER, GetName(), "-1", banString, "Auto-Ban");
#endif
        return false;
    }

    /// Prevent load of incorrect passives / spells
    if (!spellInfo->SpecializationIdList.empty() && std::find(spellInfo->SpecializationIdList.begin(), spellInfo->SpecializationIdList.end(), GetSpecializationId()) == spellInfo->SpecializationIdList.end()
        && spellInfo->Id != 674)    ///< Ambidextrie hackfix, removed at spec switch (rogue))
        return false;

    /// - Remove non authorized spell (learned when system was buggede)
    if ((spellInfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && (getRaceMask() & RACEMASK_HORDE) == 0)
        || (spellInfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && (getRaceMask() & RACEMASK_ALLIANCE) == 0))
        return false;

    // Validate profession
    if (loading)
    {
        SkillLineAbilityMapBounds spellBounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellInfo->Id);
        for (SkillLineAbilityMap::const_iterator spell_idx = spellBounds.first; spell_idx != spellBounds.second; ++spell_idx)
        {
            if (!IsProfessionSkill(spell_idx->second->skillId))
                continue;

            if (!HasSkill(spell_idx->second->skillId))
                disabled = true;
        }
    }

    PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    bool dependent_set = false;
    bool disabled_case = false;
    bool superceded_old = false;

    PlayerSpellMap::iterator itr = m_spells.find(spellId);

    // Remove temporary spell if found to prevent conflicts
    if (itr != m_spells.end() && itr->second->state == PLAYERSPELL_TEMPORARY)
        RemoveTemporarySpell(spellId);
    else if (itr != m_spells.end())
    {
        uint32 next_active_spell_id = 0;
        // fix activate state for non-stackable low rank (and find next spell for !active case)
        if (!spellInfo->IsStackableWithRanks() && spellInfo->IsRanked())
        {
            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
            {
                if (HasSpell(next))
                {
                    // high rank already known so this must !active
                    active = false;
                    next_active_spell_id = next;
                }
            }
        }

        // not do anything if already known in expected state
        if (itr->second->state != PLAYERSPELL_REMOVED && itr->second->active == active &&
            itr->second->dependent == dependent && itr->second->disabled == disabled)
        {
            if (!IsInWorld() && !learning)                   // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;

            return false;
        }

        // dependent spell known as not dependent, overwrite state
        if (itr->second->state != PLAYERSPELL_REMOVED && !itr->second->dependent && dependent)
        {
            itr->second->dependent = dependent;
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            dependent_set = true;
        }

        // update active state for known spell
        if (itr->second->active != active && itr->second->state != PLAYERSPELL_REMOVED && !itr->second->disabled)
        {
            itr->second->active = active;

            if (!IsInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;
            else if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;

            if (active)
            {
                if (spellInfo->IsPassive() && IsNeedCastPassiveSpellAtLearn(spellInfo))
                    CastSpell (this, spellId, true);
            }
            else if (IsInWorld())
            {
                if (next_active_spell_id)
                {
                    // update spell ranks in spellbook and action bar
                    WorldPacket l_Data(SMSG_SUPERCEDED_SPELL);
                    l_Data << uint32(1);
                    l_Data << uint32(1);
                    l_Data << uint32(next_active_spell_id);
                    l_Data << uint32(spellId);
                    GetSession()->SendPacket(&l_Data);
                }
                else
                {
                    WorldPacket data(SMSG_UNLEARNED_SPELLS, 4 + 4);
                    data << uint32(1);  // Count spells, always one by one
                    data << uint32(spellId);
                    data.WriteBit(0);   ///< Unk Wod
                    GetSession()->SendPacket(&data);
                }
            }

            return active;                                  // learn (show in spell book if active now)
        }

        if (itr->second->disabled != disabled && itr->second->state != PLAYERSPELL_REMOVED)
        {
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            itr->second->disabled = disabled;

            if (disabled)
                return false;

            disabled_case = true;
        }
        else switch (itr->second->state)
        {
            case PLAYERSPELL_UNCHANGED:                     // known saved spell
                return false;
            case PLAYERSPELL_REMOVED:                       // re-learning removed not saved spell
            {
                delete itr->second;
                m_spells.erase(itr);
                state = PLAYERSPELL_CHANGED;
                break;                                      // need re-add
            }
            default:                                        // known not saved yet spell (new or modified)
            {
                // can be in case spell loading but learned at some previous spell loading
                if (!IsInWorld() && !learning && !dependent_set)
                    itr->second->state = PLAYERSPELL_UNCHANGED;

                return false;
            }
        }
    }

    if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
    {
        // non talent spell: learn low ranks (recursive call)
        if (uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spellId))
        {
            if (!IsInWorld() || disabled)                    // at spells loading, no output, but allow save
                addSpell(prev_spell, active, true, true, disabled);
            else                                            // at normal learning
                learnSpell(prev_spell, true);
        }

        PlayerSpell* newspell = new PlayerSpell;
        newspell->state           = state;
        newspell->active          = active;
        newspell->dependent       = dependent;
        newspell->disabled        = disabled;
        newspell->IsMountFavorite = p_IsMountFavorite;
        newspell->FromShopItem    = p_FromShopItem;

        // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
        if (newspell->active && !newspell->disabled && !spellInfo->IsStackableWithRanks() && spellInfo->IsRanked() != 0)
        {
            WorldPacket l_Data(SMSG_SUPERCEDED_SPELL);

            uint32 bitCount = 0;
            ByteBuffer l_DataBuffer;

            for (PlayerSpellMap::iterator l_Iter = m_spells.begin(); l_Iter != m_spells.end(); ++l_Iter)
            {
                if (l_Iter->second->state == PLAYERSPELL_REMOVED)
                    continue;

                SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Iter->first);
                if (!l_SpellInfo)
                    continue;

                if (spellInfo->IsDifferentRankOf(l_SpellInfo))
                {
                    if (l_Iter->second->active)
                    {
                        if (spellInfo->IsHighRankOf(l_SpellInfo))
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                l_DataBuffer << uint32(spellId);
                                l_DataBuffer << uint32(l_Iter->first);
                            }

                            // mark old spell as disable (SMSG_SUPERCEDED_SPELL replace it in client by new)
                            l_Iter->second->active = false;
                            if (l_Iter->second->state != PLAYERSPELL_NEW)
                                l_Iter->second->state = PLAYERSPELL_CHANGED;
                            superceded_old = true;          // new spell replace old in action bars and spell book.
                        }
                        else
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                l_DataBuffer << uint32(l_Iter->first);
                                l_DataBuffer << uint32(spellId);
                            }

                            // mark new spell as disable (not learned yet for client and will not learned)
                            newspell->active = false;
                            if (newspell->state != PLAYERSPELL_NEW)
                                newspell->state = PLAYERSPELL_CHANGED;
                        }
                    }
                }
            }

            l_Data << uint32(bitCount);
            l_Data << uint32(bitCount);

            if (l_DataBuffer.size())
                l_Data.append(l_DataBuffer);

            GetSession()->SendPacket(&l_Data);
        }

        m_spells[spellId] = newspell;

        /// WoD Custom Fix : Firebolt just for Fire specialization
        if (spellId == 133 && GetSpecializationId() != SPEC_MAGE_FIRE)
            newspell->disabled = true;

        // return false if spell disabled
        if (newspell->disabled)
            return false;
    }

    // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
    // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
    if (!loading && sSpellMgr->IsTalent(spellInfo->Id) && spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
    {
        // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
        CastSpell(this, spellId, true);
    }
    // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
    else if (spellInfo->IsPassive())
    {
        if (IsNeedCastPassiveSpellAtLearn(spellInfo))
            CastSpell(this, spellId, true);
    }
    else if (spellInfo->HasEffect(SPELL_EFFECT_SKILL_STEP))
    {
        CastSpell(this, spellId, true);
        return false;
    }

    // update used talent points count
    if (sSpellMgr->IsTalent(spellInfo->Id))
    {
        SetUsedTalentCount(GetUsedTalentCount() + 1);
        SetFreeTalentPoints(GetFreeTalentPoints() -1);
        CastPassiveTalentSpell(spellInfo->Id);
    }

    // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
    if (uint32 freeProfs = GetFreePrimaryProfessionPoints())
    {
        if (spellInfo->IsPrimaryProfessionFirstRank())
            SetFreePrimaryProfessions(freeProfs-1);
    }

    // Add BattlePet
    if (learning && !dependent && p_LearnBattlePet)
    {
        for (uint32 speciesId = 0; speciesId != sBattlePetSpeciesStore.GetNumRows(); ++speciesId)
        {
            BattlePetSpeciesEntry const* speciesInfo = sBattlePetSpeciesStore.LookupEntry(speciesId);
            if (!speciesInfo || speciesInfo->spellId != spellId)
                continue;

            BattlePet pet;
            pet.Slot = PETBATTLE_NULL_SLOT;
            pet.NameTimeStamp = 0;
            pet.Species = speciesInfo->id;
            pet.DisplayModelID = 0;
            pet.Flags = 0;

            if (BattlePetTemplate const* temp = sObjectMgr->GetBattlePetTemplate(speciesInfo->id))
            {
                pet.Breed = temp->Breed;
                pet.Quality = temp->Quality;
                pet.Level = temp->Level;
            }
            else
            {
                pet.Breed = 3;
                pet.Quality = BATTLEPET_QUALITY_COMMON;
                pet.Level = 1;
            }

            // Calculate XP for level
            pet.XP = 0;
            if (pet.Level > 1 && pet.Level < 100)
                pet.XP = sGtBattlePetXPStore.LookupEntry(pet.Level - 2)->value * sGtBattlePetXPStore.LookupEntry(100 + pet.Level - 2)->value;

            // Calculate stats
            pet.UpdateStats();
            pet.Health = pet.InfoMaxHealth;

            pet.AddToPlayer(this);
            ReloadPetBattles();
            break;
        }
    }

    // add dependent skills
    uint16 maxskill     = GetMaxSkillValueForLevel();

    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spellId);

    SkillLineAbilityMapBounds skill_bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);

    if (spellLearnSkill)
    {
        uint32 skill_value = GetPureSkillValue(spellLearnSkill->skill);
        uint32 skill_max_value = GetPureMaxSkillValue(spellLearnSkill->skill);

        if (skill_value < spellLearnSkill->value)
            skill_value = spellLearnSkill->value;

        if (skill_value < 525)
        {
            switch (spellLearnSkill->skill)
            {
                case SKILL_WAY_OF_GRILL:
                case SKILL_WAY_OF_WOK:
                case SKILL_WAY_OF_POT:
                case SKILL_WAY_OF_STEAMER:
                case SKILL_WAY_OF_OVEN:
                case SKILL_WAY_OF_BREW:
                    skill_value = 525;
                    break;
            }
        }

        uint32 new_skill_max_value = spellLearnSkill->maxvalue == 0 ? maxskill : spellLearnSkill->maxvalue;

        if (skill_max_value < new_skill_max_value)
            skill_max_value = new_skill_max_value;

        SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skill_value, skill_max_value);
    }
    else
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->skillId);
            if (!pSkill)
                continue;

            if (HasSkill(pSkill->id))
                continue;

            if (_spell_idx->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL ||
                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
                ((pSkill->id == SKILL_LOCKPICKING || pSkill->id == SKILL_RUNEFORGING) && _spell_idx->second->max_value == 0))
            {
                switch (GetSkillRangeType(pSkill, _spell_idx->second->racemask != 0))
                {
                    case SKILL_RANGE_LANGUAGE:
                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 300, 300);
                        break;
                    case SKILL_RANGE_LEVEL:
                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 1, GetMaxSkillValueForLevel());
                        break;
                    case SKILL_RANGE_MONO:
                        SetSkill(pSkill->id, GetSkillStep(pSkill->id), 1, 1);
                        break;
                    default:
                        break;
                }
            }
        }
    }

    // learn dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spellId);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
    {
        if (!itr2->second.autoLearned)
        {
            if (!IsInWorld() || !itr2->second.active)       // at spells loading, no output, but allow save
                addSpell(itr2->second.spell, itr2->second.active, true, true, false);
            else                                            // at normal learning
                learnSpell(itr2->second.spell, true);
        }
    }

    if (!GetSession()->PlayerLoading())
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LINE, _spell_idx->second->skillId);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILLLINE_SPELLS, _spell_idx->second->skillId);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SPELL, spellId);
    }

    // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
    return active && !disabled && !superceded_old;
}

void Player::AddTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already added - do not do anything
    if (itr != m_spells.end())
        return;
    PlayerSpell* newspell = new PlayerSpell;
    newspell->state     = PLAYERSPELL_TEMPORARY;
    newspell->active    = true;
    newspell->dependent = false;
    newspell->disabled  = false;
    m_spells[spellId]   = newspell;
}

void Player::RemoveTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already not in list - do not do anything
    if (itr == m_spells.end())
        return;
    // spell has other state than temporary - do not change it
    if (itr->second->state != PLAYERSPELL_TEMPORARY)
        return;
    delete itr->second;
    m_spells.erase(itr);
}

bool Player::IsNeedCastPassiveSpellAtLearn(SpellInfo const* spellInfo) const
{
    // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
    // talent dependent passives activated at form apply have proper stance data
    ShapeshiftForm form = GetShapeshiftForm();

    bool need_cast = (!spellInfo->Stances || (form && (spellInfo->Stances & (UI64LIT(1) << (form - 1)))) ||
        (!form && (spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT)));

    //Check CasterAuraStates
    return need_cast && (!spellInfo->CasterAuraState || HasAuraState(AuraStateType(spellInfo->CasterAuraState)));
}

void Player::learnSpell(uint32 p_SpellId, bool dependent, bool p_FromItemShop)
{
    PlayerSpellMap::iterator l_Itr = m_spells.find(p_SpellId);

    bool l_Disabled = (l_Itr != m_spells.end()) ? l_Itr->second->disabled : false;
    bool l_Active = l_Disabled ? l_Itr->second->active : true;

    bool l_Learning = addSpell(p_SpellId, l_Active, true, dependent, false, false, false, true, p_FromItemShop);

    // prevent duplicated entires in spell book, also not send if not in world (loading)
    if (l_Learning && IsInWorld())
    {
        bool l_SuppressMessaging = false;
        ;
        TalentsPlaceHoldersSpell l_PlacesHoldersSpell = sSpellMgr->GetTalentPlaceHoldersSpell();
        if (l_PlacesHoldersSpell.find(p_SpellId) != l_PlacesHoldersSpell.end())
            l_SuppressMessaging = true;

        WorldPacket l_Data(SMSG_LEARNED_SPELL);
        l_Data << uint32(1);                        ///< count of spell_id to send.
        l_Data << uint32(p_SpellId);                ///< SpellId
        l_Data.WriteBit(l_SuppressMessaging);       ///< SuppressMessaging
        l_Data.FlushBits();
        GetSession()->SendPacket(&l_Data);

        sScriptMgr->OnPlayerSpellLearned(this, p_SpellId);
    }

    // learn all disabled higher ranks and required spells (recursive)
    if (l_Disabled)
    {
        if (uint32 l_NextSpell = sSpellMgr->GetNextSpellInChain(p_SpellId))
        {
            PlayerSpellMap::iterator l_Iter = m_spells.find(l_NextSpell);
            if (l_Iter != m_spells.end() && l_Iter->second->disabled)
                learnSpell(l_NextSpell, false);
        }

        SpellsRequiringSpellMapBounds l_SpellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(p_SpellId);
        for (SpellsRequiringSpellMap::const_iterator l_Itr2 = l_SpellsRequiringSpell.first; l_Itr2 != l_SpellsRequiringSpell.second; ++l_Itr2)
        {
            PlayerSpellMap::iterator l_Iter2 = m_spells.find(l_Itr2->second);
            if (l_Iter2 != m_spells.end() && l_Iter2->second->disabled)
                learnSpell(l_Itr2->second, false);
        }
    }
}

void Player::removeSpell(uint32 spell_id, bool disabled, bool learn_low_rank)
{
    PlayerSpellMap::iterator itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;

    if (itr->second->state == PLAYERSPELL_REMOVED || (disabled && itr->second->disabled) || itr->second->state == PLAYERSPELL_TEMPORARY)
        return;

    // unlearn non talent higher ranks (recursive)
    if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
    {
        if (HasSpell(nextSpell)/* && !GetTalentSpellPos(nextSpell)*/)
            removeSpell(nextSpell, disabled, false);
    }
    //unlearn spells dependent from recently removed spells
    SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
    for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
        removeSpell(itr2->second, disabled);

    // re-search, it can be corrupted in prev loop
    itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;                                             // already unleared

    bool giveTalentPoints = disabled || !itr->second->disabled;

    bool cur_active    = itr->second->active;
    bool cur_dependent = itr->second->dependent;

    if (disabled)
    {
        itr->second->disabled = disabled;
        if (itr->second->state != PLAYERSPELL_NEW)
            itr->second->state = PLAYERSPELL_CHANGED;
    }
    else
    {
        if (itr->second->state == PLAYERSPELL_NEW)
        {
            delete itr->second;
            m_spells.erase(itr);
        }
        else
            itr->second->state = PLAYERSPELL_REMOVED;
    }

    RemoveOwnedAura(spell_id, GetGUID());

    // remove pet auras
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
        if (PetAura const* petSpell = sSpellMgr->GetPetAura(spell_id, i))
            RemovePetAura(petSpell);

    uint32 talentCosts = sSpellMgr->IsTalent(spell_id) ? 1 : 0;

    // free talent points
    if (talentCosts > 0 && giveTalentPoints)
    {
        if (talentCosts < GetUsedTalentCount())
        {
            SetUsedTalentCount(GetUsedTalentCount() - talentCosts);
            SetFreeTalentPoints(GetFreeTalentPoints() + 1);
        }
        else
        {
            SetUsedTalentCount(0);
            SetFreeTalentPoints(CalculateTalentsPoints());
        }
    }

    // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return;

    if (spellInfo->IsPrimaryProfessionFirstRank())
    {
        uint32 freeProfs = GetFreePrimaryProfessionPoints()+1;
        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
            SetFreePrimaryProfessions(freeProfs);
    }

    RemovePassiveTalentSpell(spellInfo);

    /// Remove areatrigger
    std::list<AreaTrigger*> l_AreaTriggerList;
    GetAreaTriggerList(l_AreaTriggerList, spell_id);
    if (!l_AreaTriggerList.empty())
    {
        for (auto l_Itr : l_AreaTriggerList)
            l_Itr->RemoveFromWorld();
    }

    // remove dependent skill
    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spell_id);
    if (spellLearnSkill)
    {
        uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spell_id);
        if (!prev_spell)                                    // first rank, remove skill
            SetSkill(spellLearnSkill->skill, 0, 0, 0);
        else
        {
            // search prev. skill setting by spell ranks chain
            SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
            while (!prevSkill && prev_spell)
            {
                prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
                prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
            }

            if (!prevSkill)                                 // not found prev skill setting, remove skill
                SetSkill(spellLearnSkill->skill, 0, 0, 0);
            else                                            // set to prev. skill setting values
            {
                uint32 skill_value = GetPureSkillValue(prevSkill->skill);
                uint32 skill_max_value = GetPureMaxSkillValue(prevSkill->skill);

                if (skill_value > prevSkill->value)
                    skill_value = prevSkill->value;

                uint32 new_skill_max_value = prevSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : prevSkill->maxvalue;

                if (skill_max_value > new_skill_max_value)
                    skill_max_value = new_skill_max_value;

                SetSkill(prevSkill->skill, prevSkill->step, skill_value, skill_max_value);
            }
        }
    }
    else
    {
        // not ranked skills
        SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);

        for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
        {
            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->skillId);
            if (!pSkill)
                continue;

            if ((_spell_idx->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL &&
                pSkill->categoryId != SKILL_CATEGORY_CLASS) ||// not unlearn class skills (spellbook/talent pages)
                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
                ((pSkill->id == SKILL_LOCKPICKING || pSkill->id == SKILL_RUNEFORGING) && _spell_idx->second->max_value == 0))
            {
                // not reset skills for professions and racial abilities
                if ((pSkill->categoryId == SKILL_CATEGORY_SECONDARY || pSkill->categoryId == SKILL_CATEGORY_PROFESSION) &&
                    (IsProfessionSkill(pSkill->id) || _spell_idx->second->racemask != 0))
                    continue;

                SetSkill(pSkill->id, GetSkillStep(pSkill->id), 0, 0);
            }
        }
    }

    // remove dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spell_id);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
        removeSpell(itr2->second.spell, disabled);

    // activate lesser rank in spellbook/action bar, and cast it if need
    bool prev_activate = false;

    if (uint32 prev_id = sSpellMgr->GetPrevSpellInChain(spell_id))
    {
        if (cur_active && !spellInfo->IsStackableWithRanks() && spellInfo->IsRanked())
        {
            // need manually update dependence state (learn spell ignore like attempts)
            PlayerSpellMap::iterator prev_itr = m_spells.find(prev_id);
            if (prev_itr != m_spells.end())
            {
                if (prev_itr->second->dependent != cur_dependent)
                {
                    prev_itr->second->dependent = cur_dependent;
                    if (prev_itr->second->state != PLAYERSPELL_NEW)
                        prev_itr->second->state = PLAYERSPELL_CHANGED;
                }

                // now re-learn if need re-activate
                if (cur_active && !prev_itr->second->active && learn_low_rank)
                {
                    if (addSpell(prev_id, true, false, prev_itr->second->dependent, prev_itr->second->disabled))
                    {
                        // downgrade spell ranks in spellbook and action bar
                        WorldPacket l_Data(SMSG_SUPERCEDED_SPELL);
                        l_Data << uint32(1);
                        l_Data << uint32(1);
                        l_Data << uint32(prev_id);
                        l_Data << uint32(spell_id);
                        GetSession()->SendPacket(&l_Data);
                        prev_activate = true;
                    }
                }
            }
        }
    }

    if (spell_id == 46917 && m_canTitanGrip)
        SetCanTitanGrip(false);
    if (spell_id == 156910 && GetBeaconOfFaithTarget()) ///< Aura should be remove on Ally to not benefit of it on changing spec
    {
        Unit* l_Target = ObjectAccessor::FindUnit(GetBeaconOfFaithTarget());
        if (l_Target != nullptr)
            l_Target->RemoveAura(156910, this->GetGUID());
    }

    if (m_canDualWield)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
        if (spellInfo->IsPassive())
        {
            for (int i = 0; i < spellInfo->EffectCount; i++)
                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_DUAL_WIELD)
                {
                    SetCanDualWield(false);
                    break;
                }
        }
    }

    if (sWorld->getBoolConfig(CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN))
        AutoUnequipOffhandIfNeed();

    // remove from spell book if not replaced by lesser rank
    if (!prev_activate)
    {
        WorldPacket data(SMSG_UNLEARNED_SPELLS, 4 + 4);
        data << uint32(1);  // Count spells, always one by one
        data << uint32(spell_id);
        data.WriteBit(0);   ///< Unk Wod
        GetSession()->SendPacket(&data);
    }
}

void Player::ReduceSpellCooldown(uint32 p_SpellID, time_t p_ModifyTime)
{
    SpellCooldowns::iterator itr = m_spellCooldowns.find(p_SpellID);
    if (itr == m_spellCooldowns.end())
        return;

    uint64 currTime = 0;
    ACE_OS::gettimeofday().msec(currTime);
    if ((itr->second.end - uint64(p_ModifyTime)) > currTime)
        itr->second.end -= uint64(p_ModifyTime);
    else
        m_spellCooldowns.erase(itr);

    WorldPacket l_Data(SMSG_MODIFY_COOLDOWN, 4 + 18 + 4);
    l_Data << uint32(p_SpellID);
    l_Data << int32(-p_ModifyTime);
    l_Data.WriteBit(false);             ///< IsPetCooldown

    SendDirectMessage(&l_Data);
}

void Player::RemoveSpellCooldown(uint32 p_SpellId, bool p_Update /* = false */)
{
    auto l_Itr = m_spellCooldowns.find(p_SpellId);
    if (l_Itr != m_spellCooldowns.end())
    {
        m_spellCooldowns.erase(l_Itr);

        if (p_Update)
            SendClearCooldown(p_SpellId, this);
    }
}

void Player::RemoveArenaSpellCooldowns(bool p_RemoveActivePetCooldowns)
{
    SpellCooldowns::iterator l_Itr, l_Next;
    for (l_Itr = m_spellCooldowns.begin(); l_Itr != m_spellCooldowns.end(); l_Itr = l_Next)
    {
        l_Next = l_Itr;
        ++l_Next;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        uint32 l_Flags = (l_SpellInfo && l_SpellInfo->CategoryEntry) ? l_SpellInfo->CategoryEntry->Flags : 0;

        // check if spellentry is present and if the cooldown is less than 10 min
        if (l_SpellInfo &&
            l_SpellInfo->RecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            l_SpellInfo->CategoryRecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            (l_Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            // remove & notify
            RemoveSpellCooldown(l_Itr->first, true);
        }
    }

    /// Remove spell charge cooldown that have < 10 min CD
    for (auto l_Itr = m_CategoryCharges.begin(); l_Itr != m_CategoryCharges.end();)
    {
        SpellCategoryEntry const* l_SpellCategory = sSpellCategoryStore.LookupEntry(l_Itr->first);
        if (l_SpellCategory &&
            l_SpellCategory->ChargeRecoveryTime < 10 * MINUTE * IN_MILLISECONDS &&
            (l_SpellCategory->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            l_Itr = ResetCharges(l_SpellCategory);
        }
        else
            l_Itr++;
    }

    // pet cooldowns
    if (p_RemoveActivePetCooldowns)
    {
        if (Pet* l_Pet = GetPet())
        {
            // notify player
            for (auto l_Itr = l_Pet->m_CreatureSpellCooldowns.begin(); l_Itr != l_Pet->m_CreatureSpellCooldowns.end(); l_Itr++)
                SendClearCooldown(l_Itr->first, l_Pet);

            // actually clear cooldowns
            l_Pet->m_CreatureSpellCooldowns.clear();
        }
    }
}

void Player::RemoveAllSpellCooldown()
{
    if (!m_spellCooldowns.empty())
    {
        WorldPacket l_Data(SMSG_CLEAR_COOLDOWNS, 4 + (m_spellCooldowns.size() * 4));
        l_Data << uint32(GetSpellCooldownMap().size());

        for (SpellCooldowns::const_iterator itr = GetSpellCooldownMap().begin(); itr != GetSpellCooldownMap().end(); ++itr)
            l_Data << uint32(itr->first);             ///< Spell ID

        SendDirectMessage(&l_Data);
        m_spellCooldowns.clear();
    }
}

void Player::RemoveSpellCooldownsWithTime(uint32 p_MinRecoveryTime)
{
    SpellCooldowns::iterator l_Itr, l_Next;
    for (l_Itr = m_spellCooldowns.begin(); l_Itr != m_spellCooldowns.end(); l_Itr = l_Next)
    {
        l_Next = l_Itr;

        ++l_Next;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        uint32 l_Flags = (l_SpellInfo && l_SpellInfo->CategoryEntry) ? l_SpellInfo->CategoryEntry->Flags : 0;

        /// Check if SpellEntry is present and if the cooldown is equal or more than the specified time
        if (l_SpellInfo &&
            l_SpellInfo->RecoveryTime >= p_MinRecoveryTime &&
            l_SpellInfo->CategoryRecoveryTime >= p_MinRecoveryTime &&
            (l_Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            /// Remove & notify
            RemoveSpellCooldown(l_Itr->first, true);
        }
    }

    /// Remove spell charge with cooldown equal or more than the specified time
    for (auto l_Itr = m_CategoryCharges.begin(); l_Itr != m_CategoryCharges.end();)
    {
        SpellCategoryEntry const* l_SpellCategory = sSpellCategoryStore.LookupEntry(l_Itr->first);
        if (l_SpellCategory &&
            l_SpellCategory->ChargeRecoveryTime >= p_MinRecoveryTime &&
            (l_SpellCategory->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            l_Itr = ResetCharges(l_SpellCategory);
        }
        else
            l_Itr++;
    }
}

void Player::_LoadSpellCooldowns(PreparedQueryResult result)
{
    // some cooldowns can be already set at aura loading...

    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, item, time FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        uint64 curTime = 0;
        ACE_OS::gettimeofday().msec(curTime);

        do
        {
            Field* fields = result->Fetch();
            uint32 spell_id = fields[0].GetUInt32();
            uint32 item_id  = fields[1].GetUInt32();
            uint64 db_time = uint64(fields[2].GetUInt32()) * IN_MILLISECONDS;

            if (!sSpellMgr->GetSpellInfo(spell_id))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown spell %u in `character_spell_cooldown`, skipping.", GetGUIDLow(), spell_id);
                continue;
            }

            // skip outdated cooldown
            if (db_time <= curTime)
                continue;

            AddSpellCooldown(spell_id, item_id, (db_time - curTime));

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player (GUID: %u) spell %u, item %u cooldown loaded (%u secs).", GetGUIDLow(), spell_id, item_id, uint32(db_time-curTime));
        }
        while (result->NextRow());
    }
}

void Player::_LoadChargesCooldowns(PreparedQueryResult p_Result)
{
    if (p_Result)
    {
        uint64 l_CurrTime = 0;
        ACE_OS::gettimeofday().msec(l_CurrTime);

        do
        {
            Field* l_Fields = p_Result->Fetch();
            uint32 l_CategoryId = 0;
            ChargeEntry l_Charges;

            l_CategoryId = l_Fields[0].GetUInt32();
            SpellCategoryEntry const* l_Category = sSpellCategoryStore.LookupEntry(l_CategoryId);
            if (l_Category == nullptr)
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown charges category %u registered, skipping.", GetGUIDLow(), l_CategoryId);
                continue;
            }

            l_Charges.RechargeStart = Clock::from_time_t(time_t(l_Fields[1].GetUInt32()));
            l_Charges.RechargeEnd = Clock::from_time_t(time_t(l_Fields[2].GetUInt32()));

            m_CategoryCharges[l_CategoryId].push_back(l_Charges);
        }
        while (p_Result->NextRow());
    }
}

void Player::_SaveSpellCooldowns(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    uint64 curTime = 0;
    ACE_OS::gettimeofday().msec(curTime);
    uint64 infTime = curTime + infinityCooldownDelayCheck;

    bool first_round = true;
    std::ostringstream ss;

    // remove outdated and save active
    for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end();)
    {
        if (itr->second.end <= curTime)
            m_spellCooldowns.erase(itr++);
        else if (itr->second.end <= infTime)                 // not save locked cooldowns, it will be reset or set at reload
        {
            if (first_round)
            {
                ss << "INSERT INTO character_spell_cooldown (guid, spell, item, time) VALUES ";
                first_round = false;
            }
            // next new/changed record prefix
            else
                ss << ',';
            ss << '(' << GetRealGUIDLow() << ',' << itr->first << ',' << itr->second.itemid << ',' << uint64(itr->second.end / IN_MILLISECONDS) << ')';
            ++itr;
        }
        else
            ++itr;
    }
    // if something changed execute
    if (!first_round)
        trans->Append(ss.str().c_str());
}

void Player::_SaveChargesCooldowns(SQLTransaction& p_Transaction)
{
#ifdef CROSS
    InterRealmDatabasePool* l_Database = GetRealmDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_DEL_CHARGES_COOLDOWN);
    l_Statement->setUInt32(0, GetRealGUIDLow());
    p_Transaction->Append(l_Statement);

    for (auto const& p : m_CategoryCharges)
    {
        for (ChargeEntry const& l_Charge : p.second)
        {
            PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_INS_CHARGES_COOLDOWN);
            l_Statement->setUInt32(0, GetRealGUIDLow());
            l_Statement->setUInt32(1, p.first);
            l_Statement->setUInt32(2, uint32(Clock::to_time_t(l_Charge.RechargeStart)));
            l_Statement->setUInt32(3, uint32(Clock::to_time_t(l_Charge.RechargeEnd)));
            p_Transaction->Append(l_Statement);
        }
    }
}

uint32 Player::GetNextResetSpecializationCost() const
{
    // The first time reset costs 1 gold
    if (GetSpecializationResetCost() < 1*GOLD)
        return 1*GOLD;
    // then 5 gold
    else if (GetSpecializationResetCost() < 5*GOLD)
        return 5*GOLD;
    // After that it increases in increments of 5 gold
    else if (GetSpecializationResetCost() < 10*GOLD)
        return 10*GOLD;
    else
    {
        uint64 months = (sWorld->GetGameTime() - GetSpecializationResetTime())/MONTH;
        if (months > 0)
        {
            // This cost will be reduced by a rate of 5 gold per month
            int32 new_cost = int32(GetSpecializationResetCost() - 5*GOLD*months);
            // to a minimum of 10 gold.
            return (new_cost < 10*GOLD ? 10*GOLD : new_cost);
        }
        else
        {
            // After that it increases in increments of 5 gold
            int32 new_cost = GetSpecializationResetCost() + 5*GOLD;
            // until it hits a cap of 50 gold.
            if (new_cost > 50*GOLD)
                new_cost = 50*GOLD;
            return new_cost;
        }
    }
}

uint32 Player::GetNextResetTalentsCost() const
{
    // The first time reset costs 1 gold
    if (GetTalentResetCost() < 1*GOLD)
        return 1*GOLD;
    // then 5 gold
    else if (GetTalentResetCost() < 5*GOLD)
        return 5*GOLD;
    // After that it increases in increments of 5 gold
    else if (GetTalentResetCost() < 10*GOLD)
        return 10*GOLD;
    else
    {
        uint64 months = (sWorld->GetGameTime() - GetTalentResetTime())/MONTH;
        if (months > 0)
        {
            // This cost will be reduced by a rate of 5 gold per month
            int32 new_cost = int32(GetTalentResetCost() - 5*GOLD*months);

            // 50 gold cap
            new_cost = std::min(new_cost, 50 * GOLD);

            // to a minimum of 10 gold.
            return (new_cost < 10*GOLD ? 10*GOLD : new_cost);
        }
        else
        {
            // After that it increases in increments of 5 gold
            int32 new_cost = GetTalentResetCost() + 5*GOLD;
            // until it hits a cap of 50 gold.
            if (new_cost > 50*GOLD)
                new_cost = 50*GOLD;
            return new_cost;
        }
    }
}

bool Player::ResetTalents(bool p_NoCost /*= false*/)
{
    sScriptMgr->OnPlayerTalentsReset(this, p_NoCost);

    /// Not needed after this call
    if (HasAtLoginFlag(AtLoginFlags::AT_LOGIN_RESET_TALENTS))
        RemoveAtLoginFlag(AtLoginFlags::AT_LOGIN_RESET_TALENTS, true);

    uint32 l_TalentPointsForLevel = CalculateTalentsPoints();

    if (!GetUsedTalentCount())
    {
        SetFreeTalentPoints(l_TalentPointsForLevel);
        return false;
    }

    uint32 l_Cost = 0;

    if (!p_NoCost && !sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_NO_RESET_TALENT_COST))
    {
        l_Cost = GetNextResetTalentsCost();

        if (!HasEnoughMoney(uint64(l_Cost)))
        {
            SendBuyError(BuyResult::BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
            return false;
        }
    }

    if (isInCombat())
    {
        SendEquipError(InventoryResult::EQUIP_ERR_NOT_IN_COMBAT, 0, 0, 0);
        return false;
    }

    if (isInStun() || isInRoots())
    {
        SendEquipError(EQUIP_ERR_GENERIC_STUNNED, 0, 0, 0);
        return false;
    }

    if (Pet* l_Pet = GetPet())
        RemovePet(l_Pet, PetSlot::PET_SLOT_ACTUAL_PET_SLOT, true, l_Pet->m_Stampeded);
    else
        RemovePet(NULL, PetSlot::PET_SLOT_ACTUAL_PET_SLOT, true, GetPet() ? GetPet()->m_Stampeded : true);

    for (uint32 l_TalentID = 0; l_TalentID < sTalentStore.GetNumRows(); ++l_TalentID)
    {
        TalentEntry const* l_TalentInfo = sTalentStore.LookupEntry(l_TalentID);
        if (!l_TalentInfo)
            continue;

        /// Unlearn only talents for character class
        /// Some spell learned by one class as normal spells or know at creation but another class learn it as talent,
        /// To prevent unexpected lost normal learned spell skip another class talents
        if (l_TalentInfo->ClassID != getClass())
            continue;

        /// Skip non-existent talent ranks
        if (l_TalentInfo->SpellID == 0)
            continue;

        RemoveTalent(l_TalentInfo);
    }

    SetFreeTalentPoints(l_TalentPointsForLevel);
    SetUsedTalentCount(0);

#ifdef CROSS
    InterRealmDatabasePool* l_Database = GetRealmDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    SQLTransaction charTrans = l_Database->BeginTransaction();
    SQLTransaction accountTrans = LoginDatabase.BeginTransaction();
    _SaveTalents(charTrans);
    _SaveSpells(charTrans, accountTrans);
    l_Database->CommitTransaction(charTrans);
    LoginDatabase.CommitTransaction(accountTrans);

    if (!p_NoCost)
    {
        ModifyMoney(-(int64)l_Cost);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, l_Cost);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);

        SetTalentResetCost(l_Cost);
        SetTalentResetTime(time(NULL));
    }

    return true;
}

void Player::RemoveTalent(TalentEntry const* p_TalentInfos)
{
    SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(p_TalentInfos->SpellID);
    if (!l_SpellInfo)
        return;

    removeSpell(p_TalentInfos->SpellID, true);

    /// Search for spells that the talent teaches and unlearn them
    for (uint8 l_I = 0; l_I < SpellEffIndex::MAX_EFFECTS; ++l_I)
    {
        if (l_SpellInfo->Effects[l_I].TriggerSpell > 0 && l_SpellInfo->Effects[l_I].Effect == SpellEffects::SPELL_EFFECT_LEARN_SPELL)
            removeSpell(l_SpellInfo->Effects[l_I].TriggerSpell, true);
    }

    for (uint8 l_I = 0; l_I < SpellEffIndex::MAX_EFFECTS; ++l_I)
    {
        if (l_SpellInfo->Effects[l_I].ApplyAuraName == AuraType::SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS ||
            l_SpellInfo->Effects[l_I].ApplyAuraName == AuraType::SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2)
            RemoveAurasDueToSpell(l_SpellInfo->Effects[l_I].BasePoints);
    }

    /// If this talent rank can be found in the PlayerTalentMap, mark the talent as removed so it gets deleted
    PlayerTalentMap::iterator l_PlrTalent = GetTalentMap(GetActiveSpec())->find(p_TalentInfos->SpellID);
    if (l_PlrTalent != GetTalentMap(GetActiveSpec())->end())
        l_PlrTalent->second->state = PlayerSpellState::PLAYERSPELL_REMOVED;

    SetUsedTalentCount(GetUsedTalentCount() - 1);
    SetFreeTalentPoints(GetFreeTalentPoints() + 1);
}

void Player::ResetSpec(bool p_NoCost /* = false */)
{
    uint32 l_Cost = 0;

    if (!sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) && !p_NoCost)
    {
        l_Cost = GetNextResetSpecializationCost();

        if (!HasEnoughMoney(uint64(l_Cost)))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
            return;
        }
    }

    if (isInCombat())
    {
        SendEquipError(EQUIP_ERR_NOT_IN_COMBAT, 0, 0, 0);
        return;
    }

    if (isInStun() || isInRoots())
    {
        SendEquipError(EQUIP_ERR_GENERIC_STUNNED, 0, 0, 0);
        return;
    }

    if (GetSpecializationId() == SpecIndex::SPEC_NONE)
        return;

    /// Remove specialization Glyphs
    std::vector<uint32> l_Glyphs = GetGlyphMap(GetActiveSpec());
    uint8 l_Slot = 0;
    for (uint32 l_Glyph : l_Glyphs)
    {
        GlyphRequiredSpecEntry const* l_GlyphReq = nullptr;
        for (uint32 l_I = 0; l_I < sGlyphRequiredSpecStore.GetNumRows(); ++l_I)
        {
            if (GlyphRequiredSpecEntry const* l_GlyphRequirements = sGlyphRequiredSpecStore.LookupEntry(l_I))
            {
                if (l_GlyphRequirements->GlyphID == l_Glyph)
                {
                    l_GlyphReq = l_GlyphRequirements;
                    break;
                }
            }
        }

        if (l_GlyphReq == nullptr)
        {
            ++l_Slot;
            continue;
        }

        /// If glyph has a spec requirement, remove it
        if (GlyphPropertiesEntry const* l_GlyphProp = sGlyphPropertiesStore.LookupEntry(l_Glyph))
        {
            RemoveAurasDueToSpell(l_GlyphProp->SpellId);
            SetGlyph(l_Slot, 0);
        }

        ++l_Slot;
    }

    RemoveSpecializationSpells();
    SetSpecializationId(GetActiveSpec(), false);
    InitSpellForLevel();
    UpdateMasteryPercentage();
    SendTalentsInfoData(false);

    ModifyMoney(-(int64)l_Cost);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, l_Cost);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);

    SetSpecializationResetCost(l_Cost);
    SetSpecializationResetTime(time(nullptr));
}

void Player::ResetAllSpecs()
{
    for (int l_SpecIdx = 0; l_SpecIdx < 2; l_SpecIdx++)
    {
        /// Remove specialization Glyphs
        std::vector<uint32> l_Glyphs = GetGlyphMap(l_SpecIdx);
        uint8 l_Slot = 0;
        for (uint32 l_Glyph : l_Glyphs)
        {
            GlyphRequiredSpecEntry const* l_GlyphReq = nullptr;
            for (uint32 l_I = 0; l_I < sGlyphRequiredSpecStore.GetNumRows(); ++l_I)
            {
                if (GlyphRequiredSpecEntry const* l_GlyphRequirements = sGlyphRequiredSpecStore.LookupEntry(l_I))
                {
                    if (l_GlyphRequirements->GlyphID == l_Glyph)
                    {
                        l_GlyphReq = l_GlyphRequirements;
                        break;
                    }
                }
            }

            if (l_GlyphReq == nullptr)
            {
                ++l_Slot;
                continue;
            }

            /// If glyph has a spec requirement, remove it
            if (GlyphPropertiesEntry const* l_GlyphProp = sGlyphPropertiesStore.LookupEntry(l_Glyph))
            {
                RemoveAurasDueToSpell(l_GlyphProp->SpellId);
                SetGlyph(l_Slot, 0);
            }

            ++l_Slot;
        }
    }

    RemoveSpecializationSpells();
    SetSpecializationId(GetActiveSpec(), false);
    InitSpellForLevel();
    UpdateMasteryPercentage();
    SendTalentsInfoData(false);

    SetSpecializationResetTime(time(nullptr));
}

void Player::SetSpecializationId(uint8 p_Spec, uint32 p_Specialization, bool p_Loading)
{
    /// Hook playerScript OnModifySpec
    sScriptMgr->OnModifySpec(this, p_Specialization);

    /// Remove specialization talents
    for (auto l_Iter : *GetTalentMap(GetActiveSpec()))
    {
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Iter.first);
        if (!l_SpellInfo)
            continue;

        bool l_Remove = false;
        for (uint32 l_TalentID : l_SpellInfo->m_TalentIDs)
        {
            TalentEntry const* l_TalentEntry = sTalentStore.LookupEntry(l_TalentID);
            if (l_TalentEntry && l_TalentEntry->SpecID != p_Specialization)
            {
                l_Remove = true;
                break;
            }
        }

        if (!l_Remove)
            continue;

        removeSpell(l_Iter.first, true);

        for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
        {
            if (l_SpellInfo->Effects[i].TriggerSpell > 0 && l_SpellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
                removeSpell(l_SpellInfo->Effects[i].TriggerSpell, true);
        }

        for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
        {
            if (l_SpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS ||
                l_SpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2)
                RemoveAurasDueToSpell(l_SpellInfo->Effects[i].BasePoints);
        }

        l_Iter.second->state = PLAYERSPELL_REMOVED;

        SetUsedTalentCount(GetUsedTalentCount() - 1);
        SetFreeTalentPoints(GetFreeTalentPoints() + 1);
    }

    if (p_Spec == GetActiveSpec())
    {
        float pct = GetHealthPct();
        SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, p_Specialization);

        if (!p_Loading)
        {
            for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
            {
                if (Item* item = m_items[i])
                {
                    _ApplyItemMods(item, i, false);
                    RemoveItemsSetItem(this, item->GetTemplate());
                }
            }
        }

        _talentMgr->SpecInfo[p_Spec].SpecializationId = p_Specialization;

        if (!p_Loading)
        {
            for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
            {
                if (Item* item = m_items[i])
                {
                    _ApplyItemMods(item, i, true);
                    AddItemsSetItem(this, item);
                }
            }
        }

        SetHealth(GetMaxHealth() * pct / 100);
        return;
    }
    else
        _talentMgr->SpecInfo[p_Spec].SpecializationId = p_Specialization;

    if (Group* l_Group = GetGroup())
        l_Group->OnChangeMemberSpec(GetGUID(), p_Specialization);

    SaveToDB();
}

uint32 Player::GetRoleForGroup(uint32 specializationId) const
{
    if (!specializationId)
        specializationId = GetSpecializationId();

    return GetRoleBySpecializationId(specializationId);
}

bool Player::IsRangedDamageDealer(bool p_AllowHeal /*= true*/) const
{
    if (GetRoleForGroup() != Roles::ROLE_DAMAGE && !(p_AllowHeal && GetRoleForGroup() == Roles::ROLE_HEALER))
        return false;

    switch (getClass())
    {
        case Classes::CLASS_HUNTER:
        case Classes::CLASS_MAGE:
        case Classes::CLASS_WARLOCK:
            return true;
        default:
            break;
    }

    switch (GetSpecializationId())
    {
        case SpecIndex::SPEC_DRUID_BALANCE:
        case SpecIndex::SPEC_PRIEST_SHADOW:
        case SpecIndex::SPEC_SHAMAN_ELEMENTAL:
            return true;
        case SpecIndex::SPEC_DRUID_RESTORATION:
        case SpecIndex::SPEC_MONK_MISTWEAVER:
        case SpecIndex::SPEC_PALADIN_HOLY:
        case SpecIndex::SPEC_PRIEST_DISCIPLINE:
        case SpecIndex::SPEC_PRIEST_HOLY:
        case SpecIndex::SPEC_SHAMAN_RESTORATION:
            return p_AllowHeal;
        default:
            break;
    }

    return false;
}

bool Player::IsMeleeDamageDealer(bool p_AllowTank /*= false*/) const
{
    if (GetRoleForGroup() != Roles::ROLE_DAMAGE && !(p_AllowTank && GetRoleForGroup() == Roles::ROLE_TANK))
        return false;

    if (getClass() == Classes::CLASS_ROGUE)
        return true;

    switch (GetSpecializationId())
    {
        case SpecIndex::SPEC_DRUID_FERAL:
        case SpecIndex::SPEC_SHAMAN_ENHANCEMENT:
        case SpecIndex::SPEC_MONK_WINDWALKER:
        case SpecIndex::SPEC_WARRIOR_ARMS:
        case SpecIndex::SPEC_WARRIOR_FURY:
        case SpecIndex::SPEC_DK_UNHOLY:
        case SpecIndex::SPEC_DK_FROST:
        case SpecIndex::SPEC_PALADIN_RETRIBUTION:
            return true;
        case SpecIndex::SPEC_DRUID_GUARDIAN:
        case SpecIndex::SPEC_MONK_BREWMASTER:
        case SpecIndex::SPEC_WARRIOR_PROTECTION:
        case SpecIndex::SPEC_DK_BLOOD:
        case SpecIndex::SPEC_PALADIN_PROTECTION:
            return p_AllowTank;
        default:
            break;
    }

    return false;
}

uint32 Player::GetRoleBySpecializationId(uint32 specializationId)
{
   if (specializationId)
        if (ChrSpecializationsEntry const* spec = sChrSpecializationsStore.LookupEntry(specializationId))
        return spec->Role;

    return ROLE_DAMAGE;
}

bool Player::IsActiveSpecTankSpec() const
{
    if (GetSpecializationId() == SPEC_PALADIN_PROTECTION ||
        GetSpecializationId() == SPEC_WARRIOR_PROTECTION ||
        GetSpecializationId() == SPEC_DRUID_GUARDIAN ||
        GetSpecializationId() == SPEC_DK_BLOOD ||
        GetSpecializationId() == SPEC_MONK_BREWMASTER)
        return true;
    return false;
}

Mail* Player::GetMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        if ((*itr)->messageID == id)
            return (*itr);

    return NULL;
}

void Player::BuildCreateUpdateBlockForPlayer(UpdateData* data, Player* target) const
{
    if (target == this)
    {
        for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }
    }

    Unit::BuildCreateUpdateBlockForPlayer(data, target);
}

void Player::DestroyForPlayer(Player* target, bool onDeath) const
{
    Unit::DestroyForPlayer(target, onDeath);

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] == NULL)
            continue;

        m_items[i]->DestroyForPlayer(target);
    }

    if (target == this)
    {
        for (uint8 i = INVENTORY_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->DestroyForPlayer(target);
        }
    }
}

bool Player::HasSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        !itr->second->disabled);
}

bool Player::HasTalent(uint32 spell, uint8 spec) const
{
    PlayerTalentMap::const_iterator itr = GetTalentMap(spec)->find(spell);
    return (itr != GetTalentMap(spec)->end() && itr->second->state != PLAYERSPELL_REMOVED);
}

bool Player::HasActiveSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        itr->second->active && !itr->second->disabled);
}

TrainerSpellState Player::GetTrainerSpellState(TrainerSpell const* trainer_spell) const
{
    if (!trainer_spell)
        return TRAINER_SPELL_RED;

    bool hasSpell = true;
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        if (!HasSpell(trainer_spell->learnedSpell[i]))
        {
            hasSpell = false;
            break;
        }
    }
    // known spell
    if (hasSpell)
        return TRAINER_SPELL_GRAY;

    // check skill requirement
    if (trainer_spell->reqSkill && GetBaseSkillValue(trainer_spell->reqSkill) < trainer_spell->reqSkillValue)
        return TRAINER_SPELL_RED;

    // check level requirement
    if (getLevel() < trainer_spell->reqLevel)
        return TRAINER_SPELL_RED;

    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        // check race/class requirement
        if (!IsSpellFitByClassAndRace(trainer_spell->learnedSpell[i]))
            return TRAINER_SPELL_RED;

        if (uint32 prevSpell = sSpellMgr->GetPrevSpellInChain(trainer_spell->learnedSpell[i]))
        {
            // check prev.rank requirement
            if (prevSpell && !HasSpell(prevSpell))
                return TRAINER_SPELL_RED;
        }

        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(trainer_spell->learnedSpell[i]);
        for (SpellsRequiringSpellMap::const_iterator itr = spellsRequired.first; itr != spellsRequired.second; ++itr)
        {
            // check additional spell requirement
            if (!HasSpell(itr->second))
                return TRAINER_SPELL_RED;
        }
    }

    // check primary prof. limit
    // first rank of primary profession spell when there are no proffesions avalible is disabled
    for (uint8 i = 0; i < SpellEffIndex::MAX_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;
        SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[i]);
        if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank() && (GetFreePrimaryProfessionPoints() == 0))
            return TRAINER_SPELL_GREEN_DISABLED;
    }

    return TRAINER_SPELL_GREEN;
}

/**
 * Deletes a character from the database
 *
 * The way, how the characters will be deleted is decided based on the config option.
 *
 * @see Player::DeleteOldCharacters
 *
 * @param playerguid       the low-GUID from the player which should be deleted
 * @param accountId        the account id from the player
 * @param updateRealmChars when this flag is set, the amount of characters on that realm will be updated in the realmlist
 * @param deleteFinally    if this flag is set, the config option will be ignored and the character will be permanently removed from the database
 */
#ifndef CROSS
void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmChars, bool deleteFinally)
{
    // for not existed account avoid update realm
    if (accountId == 0)
        updateRealmChars = false;

    uint32 charDelete_method = sWorld->getIntConfig(CONFIG_CHARDELETE_METHOD);
    uint32 charDelete_minLvl = sWorld->getIntConfig(CONFIG_CHARDELETE_MIN_LEVEL);

    // if we want to finally delete the character or the character does not meet the level requirement,
    // we set it to mode CHAR_DELETE_REMOVE
    if (deleteFinally || Player::GetLevelFromDB(playerguid) < charDelete_minLvl)
        charDelete_method = CHAR_DELETE_REMOVE;

    uint32 guid = GUID_LOPART(playerguid);

    // convert corpse to bones if exist (to prevent exiting Corpse in World without DB entry)
    // bones will be deleted by corpse/bones deleting thread shortly
    sObjectAccessor->ConvertCorpseForPlayer(playerguid);

    if (uint32 guildId = GetGuildIdFromDB(playerguid, g_RealmID))
        if (Guild* guild = sGuildMgr->GetGuildById(guildId))
            guild->DeleteMember(guid, false, false, true);

    // the player was uninvited already on logout so just remove from group
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
    stmt->setUInt32(0, guid);
    PreparedQueryResult resultGroup = CharacterDatabase.Query(stmt);

    if (resultGroup)
        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*resultGroup)[0].GetUInt32()))
            RemoveFromGroup(group, playerguid);

    // Remove signs from petitions (also remove petitions if owner);
    RemovePetitionsAndSigns(playerguid, 10);

    switch (charDelete_method)
    {
        // Completely remove from the database
        case CHAR_DELETE_REMOVE:
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);

            if (resultMail)
            {
                do
                {
                    Field* mailFields = resultMail->Fetch();

                    uint32 mail_id       = mailFields[0].GetUInt32();
                    uint8 mailType       = mailFields[1].GetUInt8();
                    uint16 mailTemplateId= mailFields[2].GetUInt16();
                    uint32 sender        = mailFields[3].GetUInt32();
                    std::string subject  = mailFields[4].GetString();
                    std::string body     = mailFields[5].GetString();
                    uint64 money         = mailFields[6].GetUInt64();
                    bool has_items       = mailFields[7].GetBool();

                    // We can return mail now
                    // So firstly delete the old one
                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    // Mail is not from player
                    if (mailType != MAIL_NORMAL)
                    {
                        if (has_items)
                        {
                            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                            stmt->setUInt32(0, mail_id);
                            trans->Append(stmt);
                        }
                        continue;
                    }

                    MailDraft draft(subject, body);
                    if (mailTemplateId)
                        draft = MailDraft(mailTemplateId, false);    // items are already included

                    if (has_items)
                    {
                        // Data needs to be at first place for Item::LoadFromDB
                        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
                        stmt->setUInt32(0, mail_id);
                        PreparedQueryResult resultItems = CharacterDatabase.Query(stmt);
                        if (resultItems)
                        {
                            do
                            {
                                Field* itemFields = resultItems->Fetch();
                                uint32 item_guidlow = itemFields[16].GetUInt32();
                                uint32 item_template = itemFields[17].GetUInt32();

                                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
                                if (!itemProto)
                                {
                                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                                    stmt->setUInt32(0, item_guidlow);
                                    trans->Append(stmt);
                                    continue;
                                }

                                Item* pItem = NewItemOrBag(itemProto);
                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
                                {
                                    pItem->FSetState(ITEM_REMOVED);
                                    pItem->SaveToDB(trans);              // it also deletes item object!
                                    continue;
                                }

                                draft.AddItem(pItem);
                            }
                            while (resultItems->NextRow());
                        }
                    }

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    uint32 pl_account = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

                    draft.AddMoney(money).SendReturnToSender(pl_account, guid, sender, trans);
                }
                while (resultMail->NextRow());
            }

            // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
            // NOW we can finally clear other DB data related to character
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);

            if (resultPets)
            {
                do
                {
                    uint32 petguidlow = (*resultPets)[0].GetUInt32();
                    Pet::DeleteFromDB(petguidlow, g_RealmID);
                }
                while
                    (resultPets->NextRow());
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE_ALL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            /// Social list is account binded now
            //stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_ACCOUNT_ID);
            //stmt->setUInt32(0, guid);
            //trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            stmt->setUInt32(1, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            MS::Garrison::Manager::DeleteFromDB(playerguid, trans);

            MS::Utilities::CallBackPtr l_CharCreateCallback = nullptr;

            if (updateRealmChars)
            {
                l_CharCreateCallback = std::make_shared<MS::Utilities::Callback>([accountId](bool p_Success) -> void ///< p_Success is unused
                {
                    sWorld->UpdateRealmCharCount(accountId);
                });
            }

            CommitTransaction(CharacterDatabase, trans, l_CharCreateCallback);
            break;
        }
        // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
        case CHAR_DELETE_UNLINK:
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_DELETE_INFO);

            stmt->setUInt32(0, guid);

            CharacterDatabase.Execute(stmt);
            break;
        }
        default:
            sLog->outError(LOG_FILTER_PLAYER, "Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
    }
}
#endif

/**
 * Characters which were kept back in the database after being deleted and are now too old (see config option "CharDelete.KeepDays"), will be completely deleted.
 *
 * @see Player::DeleteFromDB
 */
void Player::DeleteOldCharacters()
{
    uint32 keepDays = sWorld->getIntConfig(CONFIG_CHARDELETE_KEEP_DAYS);
    if (!keepDays)
        return;

#ifndef CROSS
    Player::DeleteOldCharacters(keepDays);
#else /* CROSS */
    //Player::DeleteOldCharacters(keepDays);
#endif /* CROSS */
}

/**
 * Characters which were kept back in the database after being deleted and are older than the specified amount of days, will be completely deleted.
 *
 * @see Player::DeleteFromDB
 *
 * @param keepDays overrite the config option by another amount of days
 */
void Player::DeleteOldCharacters(uint32 keepDays)
{
#ifndef CROSS
    sLog->outInfo(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
         sLog->outDebug(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
         do
         {
            Field* fields = result->Fetch();
            Player::DeleteFromDB(fields[0].GetUInt32(), fields[1].GetUInt32(), true, true);
         }
         while (result->NextRow());
    }
#endif
}

/* Preconditions:
  - a resurrectable corpse must not be loaded for the player (only bones)
  - the player must be in world
*/
void Player::BuildPlayerRepop()
{
    WorldPacket l_Data(SMSG_PRE_RESURRECT, 8);
    l_Data.appendPackGUID(GetGUID());
    GetSession()->SendPacket(&l_Data);

    if (getRace() == RACE_NIGHTELF)
        CastSpell(this, 20584, true);
    CastSpell(this, 8326, true);

    if (HasAura(84559) && !InBattleground() && !InArena())
        CastSpell(this, 84559, true); // The Quick and the Dead

    if (HasAura(80354))
        RemoveAurasDueToSpell(80354); // Time Warp

    // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
    // there must be SMSG.STOP_MIRROR_TIMER
    // there we must send 888 opcode

    // the player cannot have a corpse already, only bones which are not returned by GetCorpse
    if (GetCorpse())
    {
        sLog->outError(LOG_FILTER_PLAYER, "BuildPlayerRepop: player %s(%d) already has a corpse", GetName(), GetGUIDLow());
        return;
    }

    // create a corpse and place it at the player's location
    CreateCorpse();
    Corpse* corpse = GetCorpse();
    if (!corpse)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Error creating corpse for Player %s [%u]", GetName(), GetGUIDLow());
        return;
    }
    GetMap()->AddToMap(corpse);

    /// convert player body to ghost
    SetHealth(1);

    SetWaterWalking(true);

    if (!GetSession()->isLogingOut())
        SetRooted(false);

    /// BG - remove insignia related
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);

    /// to prevent cheating
    corpse->ResetGhostTime();

    StopMirrorTimers();                                         ///< disable timers(bars)

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, float(1.0f));     ///< see radius of death player?

    /// set and clear other
    SetByteValue(UNIT_FIELD_ANIM_TIER, 3, UNIT_BYTE1_FLAG_ALWAYS_STAND);
}

void Player::ResurrectPlayer(float p_RestorePercent, bool p_ApplySickness)
{
    /// remove spirit healer position
    WorldPacket l_Data(SMSG_DEATH_RELEASE_LOC, 4 * 4);
    l_Data << uint32(-1);
    l_Data << float(0);
    l_Data << float(0);
    l_Data << float(0);
    GetSession()->SendPacket(&l_Data);

    // speed change, land walk

    // remove death flag + set aura
    SetByteValue(UNIT_FIELD_ANIM_TIER, 3, 0x00);
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);

    if (getRace() == RACE_NIGHTELF)
        RemoveAurasDueToSpell(20584);                       // speed bonuses

    RemoveAurasDueToSpell(8326);                            // SPELL_AURA_GHOST

    if (GetGuild() || HasAura(84559) || HasAura(83950))
        RemoveAurasDueToSpell(84559); // The Quick and the Dead

    if (getClass() == CLASS_MONK && HasAura(131562))
        RemoveAurasDueToSpell(131562);

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    setDeathState(ALIVE);

    SetWaterWalking(false, true);
    SetRooted(false);

    m_deathTimer = 0;

    // set health/powers (0- will be set in caller)
    if (p_RestorePercent > 0.0f)
    {
        /// Percentage from SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER
        const AuraEffectList & l_ResurrectedHealthByGuildMember = GetAuraEffectsByType(SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER);

        for (AuraEffectList::const_iterator l_It = l_ResurrectedHealthByGuildMember.begin(); l_It != l_ResurrectedHealthByGuildMember.end(); ++l_It)
            AddPct(p_RestorePercent, (*l_It)->GetAmount());

        SetHealth(uint32(GetMaxHealth()*p_RestorePercent));
        SetPower(POWER_MANA,   uint32(GetMaxPower(POWER_MANA)   * p_RestorePercent));
        SetPower(POWER_RAGE, 0);
        SetPower(POWER_ENERGY, uint32(GetMaxPower(POWER_ENERGY) * p_RestorePercent));
        SetPower(POWER_FOCUS,  uint32(GetMaxPower(POWER_FOCUS)  * p_RestorePercent));
        SetPower(POWER_ECLIPSE, 0);
        SetPower(POWER_DEMONIC_FURY, 200);
        SetPower(POWER_BURNING_EMBERS, 10);
        SetPower(POWER_SOUL_SHARDS, 100);
        SetPower(POWER_CHI, 0);
        SetPower(POWER_SHADOW_ORB, 0);
    }

    /// Trigger update zone for alive state zone updates
    uint32 l_NewZone, l_NewArea;

    GetZoneAndAreaId(l_NewZone, l_NewArea, true);
    UpdateZone(l_NewZone, l_NewArea);

    sOutdoorPvPMgr->HandlePlayerResurrects(this, l_NewZone);

    if (InBattleground())
    {
        if (Battleground * l_Battleground = GetBattleground())
            l_Battleground->HandlePlayerResurrect(this);
    }

    /// Update visibility
    UpdateObjectVisibility();

    SummonLastSummonedBattlePet();

    /// - Vote bonus
    if (GetSession()->HaveVoteRemainingTime() && !HasAura(VOTE_BUFF))
    {
        Aura* l_VoteAura = AddAura(VOTE_BUFF, this);
        if (l_VoteAura)
            l_VoteAura->SetDuration(GetSession()->GetVoteRemainingTime() + 60 * IN_MILLISECONDS);
    }

    if (!p_ApplySickness)
        return;

    /// Characters from level 1-10 are not affected by resurrection sickness.
    /// Characters from level 11-19 will suffer from one minute of sickness
    /// for each level they are above 10.
    /// Characters level 20 and up suffer from ten minutes of sickness.
    int32 l_StartLevel = sWorld->getIntConfig(CONFIG_DEATH_SICKNESS_LEVEL);

    if (int32(getLevel()) >= l_StartLevel)
    {
        /// Set resurrection sickness
        CastSpell(this, 15007, true);

        /// Not full duration
        if (int32(getLevel()) < l_StartLevel + 9)
        {
            int32 l_Data = (int32(getLevel()) - l_StartLevel + 1)*MINUTE;

            Aura* l_Aura = GetAura(15007, GetGUID());

            if (l_Aura != nullptr)
            {
                l_Aura->SetDuration(l_Data*IN_MILLISECONDS);
            }
        }
    }
}

void Player::KillPlayer()
{
    if (IsFlying() && !GetTransport())
        i_motionMaster.MoveFall();

    SetRooted(true);

    StopMirrorTimers();                                     //disable timers(bars)

    setDeathState(CORPSE);
    //SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);

    SetUInt32Value(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
    ApplyModFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_LOCAL_FLAG_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION));

    // 6 minutes until repop at graveyard
    m_deathTimer = 6 * MINUTE * IN_MILLISECONDS;

    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
    SendCorpseReclaimDelay();

    // don't create corpse at this moment, player might be falling

    // update visibility
    UpdateObjectVisibility();

    UnsummonCurrentBattlePetIfAny(true);
}

void Player::CreateCorpse()
{
    // prevent existence 2 corpse for player
    SpawnCorpseBones();

    uint32 _cfb1, _cfb2;

    Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
    SetPvPDeath(false);

    if (!corpse->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_CORPSE), this))
    {
        delete corpse;
        return;
    }

    uint8 race          = (uint8)(GetUInt32Value(UNIT_FIELD_SEX));
    uint8 skin          = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_BYTES_OFFSET_SKIN_ID);
    uint8 face          = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_BYTES_OFFSET_FACE_ID);
    uint8 hairstyle     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_BYTES_OFFSET_HAIR_STYLE_ID);
    uint8 haircolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID,  PLAYER_BYTES_OFFSET_HAIR_COLOR_ID);
    uint8 facialhair    = GetByteValue(PLAYER_FIELD_REST_STATE,     PLAYER_BYTES_2_OFFSET_FACIAL_STYLE);

    _cfb1 = ((0x00) | (race << 8) | (getGender() << 16) | (skin << 24));
    _cfb2 = ((face) | (hairstyle << 8) | (haircolor << 16) | (facialhair << 24));

    corpse->SetUInt32Value(CORPSE_FIELD_SKIN_ID, _cfb1);
    corpse->SetUInt32Value(CORPSE_FIELD_FACIAL_HAIR_STYLE_ID, _cfb2);

    uint32 flags = CORPSE_FLAG_UNK2;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM))
        flags |= CORPSE_FLAG_HIDE_HELM;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
        flags |= CORPSE_FLAG_HIDE_CLOAK;
    if (InBattleground() && !InArena())
        flags |= CORPSE_FLAG_LOOTABLE;                      // to be able to remove insignia

    corpse->SetUInt32Value(CORPSE_FIELD_FLAGS, flags);
    corpse->SetUInt32Value(CORPSE_FIELD_DISPLAY_ID, GetNativeDisplayId());

    uint32 iDisplayID;
    uint32 iIventoryType;
    uint32 _cfi;
    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; i++)
    {
        if (m_items[i])
        {
            iDisplayID = m_items[i]->GetTemplate()->DisplayInfoID;
            iIventoryType = m_items[i]->GetTemplate()->InventoryType;

            _cfi = iDisplayID | (iIventoryType << 24);
            corpse->SetUInt32Value(CORPSE_FIELD_ITEMS + i, _cfi);
        }
    }

    // we do not need to save corpses for BG/arenas
    if (!GetMap()->IsBattlegroundOrArena())
        corpse->SaveToDB();

    // register for player, but not show
    sObjectAccessor->AddCorpse(corpse);
}

void Player::SpawnCorpseBones()
{
    if (sObjectAccessor->ConvertCorpseForPlayer(GetGUID()))
        if (!GetSession()->PlayerLogoutWithSave())          // at logout we will already store the player
            SaveToDB();                                     // prevent loading as ghost without corpse
}

Corpse* Player::GetCorpse() const
{
    return sObjectAccessor->GetCorpseForPlayerGUID(GetGUID());
}

void Player::DurabilityLossAll(double percent, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityLoss(pItem, percent);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityLoss(pItem, percent);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = GetBagByPos(i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityLoss(pItem, percent);
    }
}

void Player::DurabilityLoss(Item* item, double percent)
{
    if (!item)
        return;

    uint32 pMaxDurability = item ->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);

    if (!pMaxDurability)
        return;

    percent /= GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS);

    uint32 pDurabilityLoss = uint32(pMaxDurability*percent);

    if (pDurabilityLoss < 1)
        pDurabilityLoss = 1;

    DurabilityPointsLoss(item, pDurabilityLoss);
}

void Player::DurabilityPointsLossAll(int32 points, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityPointsLoss(pItem, points);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityPointsLoss(pItem, points);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityPointsLoss(pItem, points);
    }
}

void Player::DurabilityPointsLoss(Item* item, int32 points)
{
    if (HasAuraType(AuraType::SPELL_AURA_PREVENT_DURABILITY_LOSS))
        return;

    int32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    int32 pOldDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
    int32 pNewDurability = pOldDurability - points;

    if (pNewDurability < 0)
        pNewDurability = 0;
    else if (pNewDurability > pMaxDurability)
        pNewDurability = pMaxDurability;

    if (pOldDurability != pNewDurability)
    {
        // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
        if (pNewDurability == 0 && pOldDurability > 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), false);

        item->SetUInt32Value(ITEM_FIELD_DURABILITY, pNewDurability);

        // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
        if (pNewDurability > 0 && pOldDurability == 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), true);

        item->SetState(ITEM_CHANGED, this);
    }
}

void Player::DurabilityPointLossForEquipSlot(EquipmentSlots slot)
{
    if (HasAuraType(SPELL_AURA_PREVENT_DURABILITY_LOSS_FROM_COMBAT))
        return;

    if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
        DurabilityPointsLoss(pItem, 1);
}

uint32 Player::DurabilityRepairAll(bool cost, float discountMod, bool guildBank)
{
    uint32 TotalCost = 0;
    // equipped, backpack, bags itself
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        TotalCost += DurabilityRepair(((INVENTORY_SLOT_BAG_0 << 8) | i), cost, discountMod, guildBank);

    // bank, buyback and keys not repaired

    // items in inventory bags
    for (uint8 j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; j++)
        for (uint8 i = 0; i < MAX_BAG_SIZE; i++)
            TotalCost += DurabilityRepair(((j << 8) | i), cost, discountMod, guildBank);
    return TotalCost;
}

uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank)
{
    Item* item = GetItemByPos(pos);

    uint32 TotalCost = 0;
    if (!item)
        return TotalCost;

    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    if (!maxDurability)
        return TotalCost;

    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);

    if (cost)
    {
        uint32 LostDurability = maxDurability - curDurability;
        if (LostDurability>0)
        {
            ItemTemplate const* ditemProto = item->GetTemplate();

            DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
            if (!dcost)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
                return TotalCost;
            }

            uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
            DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
            if (!dQualitymodEntry)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
                return TotalCost;
            }

            uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
            uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));

            costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));

            if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                costs = 1;

#ifdef CROSS
            /// @TODO: Handle guild bank repair in cross
#endif /* CROSS */
            if (guildBank)
#ifndef CROSS
            {
                if (GetGuildId() == 0)
                {
                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You are not member of a guild");
                    return TotalCost;
                }

                Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
                if (!guild)
                    return TotalCost;

                if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
                    return TotalCost;

                guild->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPENT_GOLD_GUILD_REPAIRS, TotalCost, 0, 0, nullptr, this);
                TotalCost = costs;
            }
#else /* CROSS */
                return TotalCost;
#endif /* CROSS */
            else if (!HasEnoughMoney(uint64(costs)))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "You do not have enough money");
                return TotalCost;
            }
            else
                ModifyMoney(-int64(costs));
        }
    }

    item->SetUInt32Value(ITEM_FIELD_DURABILITY, maxDurability);
    item->SetState(ITEM_CHANGED, this);

    // reapply mods for total broken and repaired item if equipped
    if (IsEquipmentPos(pos) && !curDurability)
        _ApplyItemMods(item, pos & 255, true);
    return TotalCost;
}

class DelayedResurrection : public BasicEvent
{
    public:
        DelayedResurrection(uint64 p_Guid) : BasicEvent(), m_Guid(p_Guid) { }
        virtual ~DelayedResurrection() { }

        virtual bool Execute(uint64 /*p_EndTime*/, uint32 /*p_Time*/)
        {
            if (Player* l_Player = HashMapHolder<Player>::Find(m_Guid))
            {
                l_Player->ResurrectPlayer(1.0f);
                l_Player->SpawnCorpseBones();
            }

            return true;
        }

        virtual void Abort(uint64 p_EndTime) { }

    private:
        uint64 m_Guid;
};

void Player::RepopAtGraveyard(bool p_ForceGraveyard /*= false*/)
{
    // note: this can be called also when the player is alive
    // for example from WorldSession::HandleMovementOpcodes

    AreaTableEntry const* zone = GetAreaEntryByAreaID(GetAreaId());

    if (!zone)
    {
        sLog->outInfo(LOG_FILTER_PLAYER, "Player %u in null area; area id : %u", GetGUIDLow(), GetAreaId());
        return;
    }

    // Such zones are considered unreachable as a ghost and the player must be automatically revived
    if ((!isAlive() && zone && zone->Flags & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < GetMap()->GetMinHeight(GetPositionX(), GetPositionY()))
    {
        ResurrectPlayer(0.5f);
        SpawnCorpseBones();
    }

    WorldSafeLocsEntry const* l_ClosestGrave = nullptr;

    // Special handle for battleground maps
    if (Battleground* bg = GetBattleground())
        l_ClosestGrave = bg->GetClosestGraveYard(this);
#ifndef CROSS
    else if (IsInGarrison())
    {
        l_ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
    }
    /// Since WoD, when you die in a dungeon and you release your spirit, you are teleported alive at the entrance of the dungeon.
#endif

    else if (GetMap()->IsDungeon() && !p_ForceGraveyard)
    {
        AreaTriggerStruct const* l_AreaTrigger = sObjectMgr->GetMapEntranceTrigger(GetMapId());
        if (l_AreaTrigger)
        {
            TeleportToClosestGrave(
                l_AreaTrigger->target_X,
                l_AreaTrigger->target_Y,
                l_AreaTrigger->target_Z,
                m_orientation,
                l_AreaTrigger->target_mapId);

            /// Since WoD, you are resurrected in Dungeon with 100% life.
            if (!isAlive())
                m_Events.AddEvent(new DelayedResurrection(GetGUID()), 1 * TimeConstants::IN_MILLISECONDS);
        }
    }
    /// PvP Duel Zone
    else if (GetAreaId() == 2401 && sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
         ResurrectPlayer(1);
         RegenerateAll();
    }
    else
    {
        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(GetZoneId()))
            l_ClosestGrave = bf->GetClosestGraveYard(this);
        /// These checks are here to avoid old Outdoor scripts without GetClosestGraveyard function
        else if (sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId()) != nullptr &&
            sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())->GetClosestGraveyard(this) != nullptr)
        {
            if (OutdoorPvP* l_OutdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())) ///< l_OutdoorPvP is unused
                l_ClosestGrave = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId())->GetClosestGraveyard(this);
        }
        else
            l_ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
    }

    // stop countdown until repop
    m_deathTimer = 0;

    // if no grave found, stay at the current location
    // and don't show spirit healer location
    if (l_ClosestGrave != nullptr)
        TeleportToClosestGrave(l_ClosestGrave);
    else if (GetPositionZ() < GetMap()->GetMinHeight(GetPositionX(), GetPositionY()))
        TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());

    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
}

void Player::TeleportToClosestGrave(float p_X, float p_Y, float p_Z, float p_O, uint32 p_MapId)
{
    TeleportTo(p_MapId, p_X, p_Y, p_Z, p_O);
    UpdateObjectVisibility();

    /// not send if alive, because it used in TeleportTo()
    if (isDead())
    {
        WorldPacket l_Data(SMSG_DEATH_RELEASE_LOC, 4 * 4);  // show spirit healer position on minimap
        l_Data << p_MapId;
        l_Data << p_X;
        l_Data << p_Y;
        l_Data << p_Z;
        GetSession()->SendPacket(&l_Data);
    }
}

void Player::SendCemeteryList(bool p_OnMap)
{
    ByteBuffer l_Buffer(50);
    uint32 l_Counter = 0;

    uint32 l_ZoneID = GetZoneId();
    GraveYardContainer::const_iterator l_GraveLow  = sObjectMgr->GraveYardStore.lower_bound(l_ZoneID);
    GraveYardContainer::const_iterator l_GraveUP   = sObjectMgr->GraveYardStore.upper_bound(l_ZoneID);
    for (GraveYardContainer::const_iterator l_Iter = l_GraveLow; l_Iter != l_GraveUP; ++l_Iter)
    {
        ++l_Counter;
        l_Buffer << uint32(l_Iter->second.safeLocId);
    }

    WorldPacket l_Packet(SMSG_REQUEST_CEMETERY_LIST_RESPONSE, l_Buffer.size() + 4 + 1);
    l_Packet.WriteBit(p_OnMap);
    l_Packet.FlushBits();
    l_Packet << uint32(l_Counter);
    if (l_Counter)
        l_Packet.append(l_Buffer);
    GetSession()->SendPacket(&l_Packet);
}

bool Player::CanJoinConstantChannelInZone(ChatChannelsEntry const* channel, AreaTableEntry const* zone)
{
    if (channel->Flags & CHANNEL_DBC_FLAG_ZONE_DEP && zone->Flags & AREA_FLAG_ARENA_INSTANCE)
        return false;

    if ((channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY) && (!(zone->Flags & AREA_FLAG_SLAVE_CAPITAL)))
        return false;

    if ((channel->Flags & CHANNEL_DBC_FLAG_GUILD_REQ) && GetGuildId())
        return false;

    return true;
}

void Player::JoinedChannel(Channel* c)
{
    m_channels.push_back(c);
}

void Player::LeftChannel(Channel* c)
{
    m_channels.remove(c);
}

void Player::CleanupChannels()
{
    while (!m_channels.empty())
    {
        Channel* ch = *m_channels.begin();
        m_channels.erase(m_channels.begin());               // remove from player's channel list
        ch->Leave(GetGUID(), false);                        // not send to client, not remove from player's channel list
        if (ChannelMgr* cMgr = channelMgr(GetTeam()))
            cMgr->LeftChannel(ch->GetName());               // deleted channel if empty
    }
    sLog->outDebug(LOG_FILTER_CHATSYS, "Player: channels cleaned up!");
}

void Player::UpdateChatLocaleFiltering()
{
    for (auto l_It = m_channels.begin(); l_It != m_channels.end(); ++l_It)
    {
        Channel* l_Channel = (*l_It);

        if (l_Channel)
            l_Channel->UpdateChatLocaleFiltering(this);
    }
}

void Player::UpdateLocalChannels(uint32 newZone)
{
    if (GetSession()->PlayerLoading() && !IsBeingTeleportedFar())
        return;                                              // The client handles it automatically after loading, but not after teleporting

    AreaTableEntry const* current_zone = GetAreaEntryByAreaID(newZone);
    if (!current_zone)
        return;

    ChannelMgr* cMgr = channelMgr(GetTeam());
    if (!cMgr)
        return;

    std::string current_zone_name = current_zone->AreaNameLang;

    for (uint32 i = 0; i < sChatChannelsStore.GetNumRows(); ++i)
    {
        if (ChatChannelsEntry const* channel = sChatChannelsStore.LookupEntry(i))
        {
            Channel* usedChannel = NULL;

			auto itr = std::find_if(m_channels.begin(), m_channels.end(), [&i](Channel const* var) { return var && var->GetChannelId() == i; });
			if (itr != m_channels.end())
				usedChannel = *itr;

            for (JoinedChannelsList::iterator itr = m_channels.begin(); itr != m_channels.end(); ++itr)
            {
                if ((*itr)->GetChannelId() == i)
                {
                    usedChannel = *itr;
                    break;
                }
            }

            Channel* removeChannel = NULL;
            Channel* joinChannel = NULL;
            bool sendRemove = true;

            if (CanJoinConstantChannelInZone(channel, current_zone))
            {
                if (!(channel->Flags & CHANNEL_DBC_FLAG_GLOBAL))
                {
                    if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
                        continue;                            // Already on the channel, as city channel names are not changing

                    char new_channel_name_buf[100];
                    char const* currentNameExt;

                    if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY)
                        currentNameExt = sObjectMgr->GetTrinityStringForDBCLocale(LANG_CHANNEL_CITY);
                    else
                        currentNameExt = current_zone_name.c_str();

                    snprintf(new_channel_name_buf, 100, channel->NameLang, currentNameExt);

                    joinChannel = cMgr->GetJoinChannel(new_channel_name_buf, channel->ID);
                    if (usedChannel)
                    {
                        if (joinChannel != usedChannel)
                        {
                            removeChannel = usedChannel;
                            sendRemove = false;              // Do not send leave channel, it already replaced at client
                        }
                        else
                            joinChannel = NULL;
                    }
                }
                else
                    joinChannel = cMgr->GetJoinChannel(channel->NameLang, channel->ID);
            }
            else
                removeChannel = usedChannel;

            if (joinChannel)
                joinChannel->Join(GetGUID(), "");            // Changed Channel: ... or Joined Channel: ...

            if (removeChannel)
            {
                removeChannel->Leave(GetGUID(), sendRemove); // Leave old channel
                std::string name = removeChannel->GetName(); // Store name, (*i)erase in LeftChannel
                LeftChannel(removeChannel);                  // Remove from player's channel list
                cMgr->LeftChannel(name);                     // Delete if empty
            }
        }
    }
}

void Player::LeaveLFGChannel()
{
    for (JoinedChannelsList::iterator i = m_channels.begin(); i != m_channels.end(); ++i)
    {
        if ((*i)->IsLFG())
        {
            (*i)->Leave(GetGUID());
            break;
        }
    }
}

void Player::HandleBaseModValue(BaseModGroup modGroup, BaseModType modType, float amount, bool apply)
{
    if (modGroup >= BASEMOD_END || modType >= MOD_END) // @todo Comparison of constant 2 with expression of type 'BaseModType' is always false
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "ERROR in HandleBaseModValue(): non existed BaseModGroup of wrong BaseModType!");
        return;
    }

    switch (modType)
    {
        case FLAT_MOD:
            m_auraBaseMod[modGroup][modType] += apply ? amount : -amount;
            break;
        case PCT_MOD:
            ApplyPercentModFloatVar(m_auraBaseMod[modGroup][modType], amount, apply);
            break;
    }

    if (!CanModifyStats())
        return;

    switch (modGroup)
    {
        case CRIT_PERCENTAGE:              UpdateCritPercentage(WeaponAttackType::BaseAttack);                          break;
        case RANGED_CRIT_PERCENTAGE:       UpdateCritPercentage(WeaponAttackType::RangedAttack);                        break;
        case OFFHAND_CRIT_PERCENTAGE:      UpdateCritPercentage(WeaponAttackType::OffAttack);                           break;
        default: break;
    }
}

float Player::GetBaseModValue(BaseModGroup modGroup, BaseModType modType) const
{
    if (modGroup >= BASEMOD_END || modType >= MOD_END) // @todo Comparison of constant 2 with expression of type 'BaseModType' is always false
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "trial to access non existed BaseModGroup or wrong BaseModType!");
        return 0.0f;
    }

    if (modType == PCT_MOD && m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][modType];
}

float Player::GetTotalBaseModValue(BaseModGroup modGroup) const
{
    if (modGroup >= BASEMOD_END)
    {
        sLog->outError(LOG_FILTER_SPELLS_AURAS, "wrong BaseModGroup in GetTotalBaseModValue()!");
        return 0.0f;
    }

    if (m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][FLAT_MOD] * m_auraBaseMod[modGroup][PCT_MOD];
}

float Player::GetRatingMultiplier(CombatRating cr) const
{
    uint8 level = getLevel();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

    GtCombatRatingsEntry const* Rating = sGtCombatRatingsStore.LookupEntry(cr * GT_MAX_LEVEL + level - 1);
    
    if (!Rating || !Rating->ratio)
        return 1.0f; ///< By default use minimum coefficient (not must be called)

    return 1.0f / Rating->ratio;
}

float Player::GetRatingBonusValue(CombatRating cr) const
{
    float baseResult = float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) * GetRatingMultiplier(cr);

    if (cr != CR_RESILIENCE_PLAYER_DAMAGE_TAKEN)
        return baseResult;

    //return float(1.0f - pow(0.99f, baseResult)) * 100.0f;
    return float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) / 1070; // temp hack
}

float Player::GetExpertiseDodgeOrParryReduction(WeaponAttackType attType) const
{
    switch (attType)
    {
        case WeaponAttackType::BaseAttack:
            return GetFloatValue(PLAYER_FIELD_MAINHAND_EXPERTISE);
        case WeaponAttackType::OffAttack:
            return GetFloatValue(PLAYER_FIELD_OFFHAND_EXPERTISE);
        case WeaponAttackType::RangedAttack:
            return GetFloatValue(PLAYER_FIELD_RANGED_EXPERTISE);
        default:
            break;
    }
    return 0.0f;
}

float Player::GetPvpHealingBonus() const
{
    // Pvp healing cannot work in dungeons
    if (Map* l_Map = GetMap())
        if (l_Map->IsDungeon())
            return 1.0f;

    float l_PvpPower = (1 + GetFloatValue(PLAYER_FIELD_PVP_POWER_HEALING) / 100);

    return l_PvpPower;
}

float Player::OCTRegenMPPerSpirit()
{
    uint8 level = getLevel();
    uint32 pclass = getClass();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

    float ratio = 0.0f;
    GtRegenMPPerSptEntry  const* regenBase = sGtRegenMPPerSptStore.LookupEntry((pclass - 1) * GT_MAX_LEVEL + level - 1);
    if (regenBase)
        ratio = regenBase->ratio;

    // Formula get from PaperDollFrame script
    return GetStat(STAT_SPIRIT) * ratio;
}

void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
{
    float oldRating = m_baseRatingValue[cr];
    m_baseRatingValue[cr] += (apply ? value : -value);

    // explicit affected values
    float const multiplier = GetRatingMultiplier(cr);
    float const oldVal = oldRating * multiplier;
    float const newVal = m_baseRatingValue[cr] * multiplier;
    switch (cr)
    {
        case CR_HASTE_MELEE:
        {
            ApplyAttackTimePercentMod(WeaponAttackType::BaseAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::OffAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::BaseAttack, newVal, true);
            ApplyAttackTimePercentMod(WeaponAttackType::OffAttack, newVal, true);
            if (getClass() == CLASS_DEATH_KNIGHT)
                UpdateAllRunesRegen();
            break;
        }
        case CR_HASTE_RANGED:
        {
            ApplyAttackTimePercentMod(WeaponAttackType::RangedAttack, oldVal, false);
            ApplyAttackTimePercentMod(WeaponAttackType::RangedAttack, newVal, true);
            break;
        }
        case CR_HASTE_SPELL:
        {
            ApplyCastTimePercentMod(oldVal, false);
            ApplyCastTimePercentMod(newVal, true);
            break;
        }
        default:
            break;
    }

    UpdateRating(cr);
}

void Player::UpdateRating(CombatRating p_CombatRating)
{
    ///< Apply pct modifier from SPELL_AURA_INCREASE_RATING_PCT
    float l_Modifier = 1.0f;
    AuraEffectList const& l_ModRatingPCT = GetAuraEffectsByType(AuraType::SPELL_AURA_INCREASE_RATING_PCT);
    for (AuraEffectList::const_iterator l_Iter = l_ModRatingPCT.begin(); l_Iter != l_ModRatingPCT.end(); ++l_Iter)
    {
        if ((*l_Iter)->GetMiscValue() & (1 << p_CombatRating))
            l_Modifier += float((*l_Iter)->GetAmount()) / 100.0f;
    }

    int32 l_Amount = m_baseRatingValue[p_CombatRating] * l_Modifier;

    // Apply bonus from SPELL_AURA_MOD_RATING_FROM_STAT
    // stat used stored in miscValueB for this aura
    AuraEffectList const& l_ModRatingFromStat = GetAuraEffectsByType(SPELL_AURA_MOD_RATING_FROM_STAT);
    for (AuraEffectList::const_iterator l_Iter = l_ModRatingFromStat.begin(); l_Iter != l_ModRatingFromStat.end(); ++l_Iter)
    {
        if ((*l_Iter)->GetMiscValue() & (1 << p_CombatRating))
            l_Amount += int32(CalculatePct(GetStat(Stats((*l_Iter)->GetMiscValueB())), (*l_Iter)->GetAmount()));
    }

    if (l_Amount < 0)
        l_Amount = 0;

    SetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + p_CombatRating, uint32(l_Amount));

    if (p_CombatRating >= CR_HASTE_MELEE && p_CombatRating <= CR_HASTE_SPELL)
    {
        float l_HastePct = l_Amount * GetRatingMultiplier(p_CombatRating);

        AuraEffectList const& l_HasteAuras = GetAuraEffectsByType(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK);
        for (AuraEffectList::const_iterator l_Iter = l_HasteAuras.begin(); l_Iter != l_HasteAuras.end(); ++l_Iter)
        {
            if ((*l_Iter)->GetAmount() > 0)
            {
                l_HastePct *= (1.0f + (*l_Iter)->GetAmount() / 100.0f);
                l_HastePct += (*l_Iter)->GetAmount();
            }
        }

        std::map<SpellGroup, int32> SameEffectSpellGroup;
        AuraEffectList const& l_MeleeSlowAuras = GetAuraEffectsByType(SPELL_AURA_MELEE_SLOW);
        for (AuraEffectList::const_iterator l_Iter = l_MeleeSlowAuras.begin(); l_Iter != l_MeleeSlowAuras.end(); ++l_Iter)
        {
            if (!sSpellMgr->AddSameEffectStackRuleSpellGroups((*l_Iter)->GetSpellInfo(), (*l_Iter)->GetAmount(), SameEffectSpellGroup))
            {
                if ((*l_Iter)->GetAmount() > 0)
                {
                    l_HastePct *= (1.0f + (*l_Iter)->GetAmount() / 100.0f);
                    l_HastePct += (*l_Iter)->GetAmount();
                }
            }
        }

        for (std::map<SpellGroup, int32>::const_iterator itr = SameEffectSpellGroup.begin(); itr != SameEffectSpellGroup.end(); ++itr)
        {
            l_HastePct *= (1.0f + itr->second / 100.0f);
            l_HastePct += itr->second;
        }

        float l_Haste = 1.0f / (1.0f + l_HastePct / 100.0f);

        ///< Update haste percentage for client
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_SPELL_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_RANGED_HASTE, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_HASTE_REGEN, l_Haste);
        SetFloatValue(EUnitFields::UNIT_FIELD_MOD_CASTING_SPEED, l_Haste);

        UpdateManaRegen();
        UpdateEnergyRegen();
        UpdateFocusRegen();
        UpdateAllRunesRegen();
    }

    bool l_AffectStats = CanModifyStats();

    switch (p_CombatRating)
    {
        case CR_DODGE:
            UpdateDodgePercentage();
            break;
        case CR_PARRY:
            UpdateParryPercentage();
            break;
        case CR_BLOCK:
            UpdateBlockPercentage();
            break;
        case CR_CRIT_MELEE:
            if (l_AffectStats)
            {
                UpdateCritPercentage(WeaponAttackType::BaseAttack);
                UpdateCritPercentage(WeaponAttackType::OffAttack);
            }
            break;
        case CR_CRIT_RANGED:
            if (l_AffectStats)
                UpdateCritPercentage(WeaponAttackType::RangedAttack);
            break;
        case CR_CRIT_SPELL:
            if (l_AffectStats)
                UpdateAllSpellCritChances();
            break;
        case CR_SPEED:
            UpdateSpeedPercentage();
            break;
        case CR_MASTERY:                                    // Implemented in Player::UpdateMasteryPercentage
            UpdateMasteryPercentage();
            break;
        case CR_MULTISTRIKE:
            UpdateMultistrikePercentage();
            break;
        case CR_LIFESTEAL:
            UpdateLeechPercentage();
            break;
        case CR_VERSATILITY_DAMAGE_DONE:
        case CR_VERSATILITY_DAMAGE_TAKEN:
            UpdateVersatilityPercentage();
            break;
        case CR_AVOIDANCE:
            UpdateAvoidancePercentage();
            break;
        case CR_HASTE_MELEE:                                // Implemented in Player::ApplyRatingMod
        case CR_HASTE_RANGED:
        case CR_HASTE_SPELL:
        case CR_RESILIENCE_PLAYER_DAMAGE_TAKEN:
        case CR_RESILIENCE_CRIT_TAKEN:
        case CR_DEFENSE_SKILL:
        default:
            break;
    }
}

void Player::UpdateAllRatings()
{
    for (int cr = 0; cr < MAX_COMBAT_RATING; ++cr)
        UpdateRating(CombatRating(cr));
}

void Player::SetRegularAttackTime()
{
    for (uint8 i = 0; i < WeaponAttackType::MaxAttack; ++i)
    {
        Item* tmpitem = GetWeaponForAttack(WeaponAttackType(i), true);
        if (tmpitem && !tmpitem->CantBeUse())
        {
            ItemTemplate const* proto = tmpitem->GetTemplate();
            if (proto->Delay)
                SetAttackTime(WeaponAttackType(i), proto->Delay);
        }
        else
            SetAttackTime(WeaponAttackType(i), BASE_ATTACK_TIME);  // If there is no weapon reset attack time to base (might have been changed from forms)
    }
}

//skill+step, checking for max value
bool Player::UpdateSkill(uint32 skill_id, uint32 step)
{
    if (!skill_id)
        return false;

    if (skill_id == SKILL_FIST_WEAPONS)
        skill_id = SKILL_UNARMED;

    SkillStatusMap::iterator itr = mSkillStatus.find(skill_id);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return false;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset);

    if (!max || !value || value >= max)
        return false;

    if (value < max)
    {
        uint16 new_value = value + step;
        if (new_value > max)
            new_value = max;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, new_value);
        if (itr->second.uState != SKILL_NEW)
            itr->second.uState = SKILL_CHANGED;

        UpdateSkillEnchantments(skill_id, value, new_value);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
        return true;
    }

    return false;
}

inline int SkillGainChance(uint32 SkillValue, uint32 GrayLevel, uint32 GreenLevel, uint32 YellowLevel)
{
    if (SkillValue >= GrayLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREY)*10;
    if (SkillValue >= GreenLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREEN)*10;
    if (SkillValue >= YellowLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_YELLOW)*10;
    return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10;
}

bool Player::UpdateCraftSkill(uint32 spellid)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateCraftSkill spellid %d", spellid);

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellid);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        if (_spell_idx->second->skillId)
        {
            uint32 SkillValue = GetPureSkillValue(_spell_idx->second->skillId);

            // Alchemy Discoveries here
            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(spellid);
            if (spellEntry && spellEntry->Mechanic == MECHANIC_DISCOVERY)
            {
                if (uint32 discoveredSpell = GetSkillDiscoverySpell(_spell_idx->second->skillId, spellid, this))
                    learnSpell(discoveredSpell, false);
            }

            uint32 craft_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_CRAFTING);
            int skill_gain_chance = SkillGainChance(SkillValue, _spell_idx->second->max_value, (_spell_idx->second->max_value + _spell_idx->second->min_value)/2, _spell_idx->second->min_value);
            
            // Since 4.0.x, we have bonus skill point reward with somes items ...
            if (_spell_idx->second && _spell_idx->second->skill_gain >craft_skill_gain && skill_gain_chance == sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10) ///< Comparison of integers of different signs: 'int' and 'unsigned int'
                craft_skill_gain = _spell_idx->second->skill_gain;

            auto skillId = _spell_idx->second->skillId;
            if (UpdateSkillPro(skillId, skill_gain_chance, craft_skill_gain))
            {
                if (SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(skillId))
                {
                    if (uint32 parentSkillId = skillEntry->parentSkillLineID)
                        return UpdateSkillPro(parentSkillId, skill_gain_chance, craft_skill_gain);
                }

                return true;
            }

            return false;
        }
    }
    return false;
}

bool Player::UpdateGatherSkill(uint32 SkillId, uint32 SkillValue, uint32 RedLevel, uint32 Multiplicator)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateGatherSkill(SkillId %d SkillLevel %d RedLevel %d)", SkillId, SkillValue, RedLevel);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
    switch (SkillId)
    {
        case SKILL_HERBALISM:
        case SKILL_LOCKPICKING:
        case SKILL_JEWELCRAFTING:
        case SKILL_INSCRIPTION:
            return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
        case SKILL_SKINNING:
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            else
                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS)), gathering_skill_gain);
        case SKILL_MINING:
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            else
                return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+100, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS)), gathering_skill_gain);
    }
    return false;
}

bool Player::UpdateFishingSkill()
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateFishingSkill");

    uint32 SkillValue = GetPureSkillValue(SKILL_FISHING);

    int32 chance = SkillValue < 75 ? 100 : 2500/(SkillValue-50);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    return UpdateSkillPro(SKILL_FISHING, chance*10, gathering_skill_gain);
}

// levels sync. with spell requirement for skill levels to learn
// bonus abilities in sSkillLineAbilityStore
// Used only to avoid scan DBC at each skill grow
static uint32 g_BonusSkillLevels[] = {75, 150, 225, 300, 375, 450, 525, 600, 700};
static const size_t g_BonusSkillLevelsSize = sizeof(g_BonusSkillLevels) / sizeof(uint32);

bool Player::UpdateSkillPro(uint16 p_SkillId, int32 p_Chance, uint32 p_Step)
{
    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "UpdateSkillPro(SkillId %d, Chance %3.1f%%)", p_SkillId, p_Chance / 10.0f);

    if (!p_SkillId)
        return false;

    if (p_Chance <= 0)                                         // speedup in 0 chance case
    {
        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", p_Chance / 10.0f);
        return false;
    }

    SkillStatusMap::iterator l_It = mSkillStatus.find(p_SkillId);
    if (l_It == mSkillStatus.end() || l_It->second.uState == SKILL_DELETED)
        return false;

    uint16 l_SkillField       = l_It->second.pos / 2;
    uint8  l_SkillFieldOffset = l_It->second.pos & 1; // itr->second.pos % 2

    uint16 l_CurrentSkillValue    = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + l_SkillField, l_SkillFieldOffset);
    uint16 l_CurrentSkillMaxValue = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + l_SkillField, l_SkillFieldOffset);

    if (!l_CurrentSkillMaxValue || !l_CurrentSkillValue || l_CurrentSkillValue >= l_CurrentSkillMaxValue)
        return false;

    int32 l_Roll = irand(1, 1000);

    if (l_Roll <= p_Chance)
    {
        uint16 l_NewSkillValue = l_CurrentSkillValue + p_Step;
        if (l_NewSkillValue > l_CurrentSkillMaxValue)
            l_NewSkillValue = l_CurrentSkillMaxValue;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + l_SkillField, l_SkillFieldOffset, l_NewSkillValue);

        if (l_It->second.uState != SKILL_NEW)
            l_It->second.uState = SKILL_CHANGED;

        for (size_t l_I = 0; l_I < g_BonusSkillLevelsSize; ++l_I)
        {
            uint32 l_BonusSkillLevel = g_BonusSkillLevels[l_I];
            if (l_CurrentSkillValue < l_BonusSkillLevel && l_NewSkillValue >= l_BonusSkillLevel)
            {
                learnSkillRewardedSpells(p_SkillId, l_NewSkillValue);
                break;
            }
        }

        UpdateSkillEnchantments(p_SkillId, l_CurrentSkillValue, l_NewSkillValue);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, p_SkillId);

        sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% taken", p_Chance / 10.0f);

        return true;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", p_Chance / 10.0f);
    return false;
}

void Player::ModifySkillBonus(uint32 skillid, int32 val, bool talent)
{
    SkillStatusMap::const_iterator itr = mSkillStatus.find(skillid);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return;

    uint16 field = itr->second.pos / 2 + (talent ? PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT : PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER);
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 bonus = GetUInt16Value(field, offset);

    SetUInt16Value(field, offset, bonus + val);
}

// This functions sets a skill line value (and adds if doesn't exist yet)
// To "remove" a skill line, set it's values to zero
void Player::SetSkill(uint16 id, uint16 step, uint16 newVal, uint16 maxVal)
{
    if (!id)
        return;

    if (IsPrimaryProfessionSkill(id))
    {
        for (uint8 i = 0; i < DEFAULT_MAX_PRIMARY_TRADE_SKILL; ++i)
        {
            if (GetPrimaryProfession(i) == (newVal ? 0 : id))
            {
                SetPrimaryProfession(i, newVal ? id : 0);
                break;
            }
        }
    }

    uint16 currVal;
    SkillStatusMap::iterator itr = mSkillStatus.find(id);

    //has skill
    if (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED)
    {
        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
        currVal = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset);
        if (newVal)
        {
            // if skill value is going down, update enchantments before setting the new value
            if (newVal < currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, id);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, step);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, newVal);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, maxVal);

            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_CHANGED;

            learnSkillRewardedSpells(id, newVal);
            // if skill value is going up, update enchantments after setting the new value
            if (newVal > currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
        }
        else                                                //remove
        {
            //remove enchantments needing this skill
            UpdateSkillEnchantments(id, currVal, 0);
            // clear skill fields
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, id);

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);

            // mark as deleted or simply remove from map if not saved yet
            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_DELETED;
            else
                mSkillStatus.erase(itr);

            // remove all spells that related to this skill
            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
                if (SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j))
                    if (pAbility->skillId == id)
                        removeSpell(sSpellMgr->GetFirstSpellInChain(pAbility->spellId));
        }

        if (step == 0 && newVal == 0 && maxVal == 0)
        {
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, id);
            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, 0);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, 0);
        }
    }
    else if (newVal)                                        //add
    {
        currVal = 0;
        for (uint32 i = 0; i < PLAYER_MAX_SKILLS; ++i)
        {
            uint16 field = i / 2;
            uint8 offset = i & 1; // i % 2

            if (!GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset) || GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset) == id)
            {
                SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(id);
                if (!skillEntry)
                {
                    sLog->outError(LOG_FILTER_GENERAL, "Skill not found in SkillLineStore: skill #%u", id);
                    return;
                }

                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, id);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, step);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, newVal);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, maxVal);

                UpdateSkillEnchantments(id, currVal, newVal);
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);

                // insert new entry or update if not deleted old entry yet
                if (itr != mSkillStatus.end())
                {
                    itr->second.pos = i;
                    itr->second.uState = SKILL_CHANGED;
                }
                else
                    mSkillStatus.insert(SkillStatusMap::value_type(id, SkillStatusData(i, SKILL_NEW)));

                // apply skill bonuses
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);

                // temporary bonuses
                AuraEffectList const& mModSkill = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL);
                for (AuraEffectList::const_iterator j = mModSkill.begin(); j != mModSkill.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // permanent bonuses
                AuraEffectList const& mModSkillTalent = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_TALENT);
                for (AuraEffectList::const_iterator j = mModSkillTalent.begin(); j != mModSkillTalent.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // Learn all spells for skill
                learnSkillRewardedSpells(id, newVal);
                return;
            }
        }
    }
    // Some spells can be without skills, clean
    else if (itr == mSkillStatus.end() && !newVal)
    {
        for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
            if (SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j))
                if (pAbility->skillId == id)
                    removeSpell(sSpellMgr->GetFirstSpellInChain(pAbility->spellId), false, false);
    }
}

bool Player::HasSkill(uint32 skill) const
{
    if (!skill)
        return false;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    return (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED);
}

uint16 Player::GetSkillStep(uint16 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + itr->second.pos / 2, itr->second.pos & 1);
}

uint16 Player::GetSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset);
}

uint16 Player::GetBaseSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset);
}

int16 Player::GetSkillPermBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset);
}

int16 Player::GetSkillTempBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset);
}

void Player::SendActionButtons(uint32 p_State) const
{
    WorldPacket l_Data(SMSG_UPDATE_ACTION_BUTTONS, 1 + (MAX_ACTION_BUTTONS * 8));

    if (p_State != 2)
    {
        /// Masks
        for (uint8 l_Button = 0; l_Button < MAX_ACTION_BUTTONS; ++l_Button)
        {
            auto l_Iter = m_actionButtons.find(l_Button);

            if (l_Iter != m_actionButtons.end() && l_Iter->second.uState != ACTIONBUTTON_DELETED)
                l_Data << uint64(l_Iter->second.packedData);
            else
                l_Data << uint64(0);
        }
    }
    else
    {
        for (uint32 l_I = 0; l_I < MAX_ACTION_BUTTONS; l_I++)
            l_Data << uint64(0);
    }

    l_Data << uint8(p_State);

    GetSession()->SendPacket(&l_Data);

    sLog->outInfo(LOG_FILTER_NETWORKIO, "Action Buttons for '%u' spec '%u' Sent", GetGUIDLow(), GetActiveSpec());
}

bool Player::IsActionButtonDataValid(uint8 button, uint32 action, uint8 type)
{
    if (button >= MAX_ACTION_BUTTONS)
    {
        sLog->outError(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: button must be < %u", action, button, GetName(), MAX_ACTION_BUTTONS);
        return false;
    }

    if (action >= MAX_ACTION_BUTTON_ACTION_VALUE)
    {
        sLog->outError(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: action must be < %u", action, button, GetName(), MAX_ACTION_BUTTON_ACTION_VALUE);
        return false;
    }

    switch (type)
    {
        case ACTION_BUTTON_SPELL:
            if (!sSpellMgr->GetSpellInfo(action))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Spell action %u not added into button %u for player %s: spell not exist", action, button, GetName());
                return false;
            }

            if (!HasSpell(action))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::IsActionButtonDataValid Spell action %u not added into button %u for player %s: player don't known this spell", action, button, GetName());
                return false;
            }
            break;
        case ACTION_BUTTON_ITEM:
            if (!sObjectMgr->GetItemTemplate(action))
            {
                sLog->outError(LOG_FILTER_PLAYER_LOADING, "Item action %u not added into button %u for player %s: item not exist", action, button, GetName());
                return false;
            }
            break;
        default:
            break;                                          // other cases not checked at this moment
    }

    return true;
}

ActionButton* Player::addActionButton(uint8 button, uint32 action, uint8 type)
{
    if (!IsActionButtonDataValid(button, action, type))
        return NULL;

    // it create new button (NEW state) if need or return existed
    ActionButton& ab = m_actionButtons[button];

    // set data and update to CHANGED if not NEW
    ab.SetActionAndType(action, ActionButtonType(type));

    sLog->outInfo(LOG_FILTER_PLAYER_LOADING, "Player '%u' Added Action '%u' (type %u) to Button '%u'", GetGUIDLow(), action, type, button);
    return &ab;
}

void Player::removeActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return;

    if (buttonItr->second.uState == ACTIONBUTTON_NEW)
        m_actionButtons.erase(buttonItr);                   // new and not saved
    else
        buttonItr->second.uState = ACTIONBUTTON_DELETED;    // saved, will deleted at next save

    sLog->outInfo(LOG_FILTER_PLAYER_LOADING, "Action Button '%u' Removed from Player '%u'", button, GetGUIDLow());
}

ActionButton const* Player::GetActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return NULL;

    return &buttonItr->second;
}

int8 Player::GetFreeActionButton()
{
    // 12 is max button of first action bar
    for (uint8 i = 0; i < 12; i++)
        if (!GetActionButton(i))
            return i;

    return -1;
}

bool Player::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
{
    if ((time(0) - m_BonusQuestTimer) >= 5)
    {
        m_BonusQuestTimer = time(0);
        for (auto l_Current : sObjectMgr->BonusQuestsRects)
        {
            if (IsQuestRewarded(l_Current.first))
                continue;

            bool l_HasOneIn = false;

            for (uint32 l_I = 0; l_I < l_Current.second.size(); ++l_I)
            {
                if (l_Current.second[l_I].IsIn(GetMapId(), x, y))
                    l_HasOneIn = true;
            }

            uint32 l_Slot = FindQuestSlot(l_Current.first);

            if (!l_HasOneIn && l_Slot < MAX_QUEST_LOG_SIZE)
            {
                SetQuestSlot(l_Slot, 0);
                RemoveActiveQuest(l_Current.first, true);
            }
            else if (l_HasOneIn && l_Slot >= MAX_QUEST_LOG_SIZE)
            {
                if (const Quest * l_Quest = sObjectMgr->GetQuestTemplate(l_Current.first))
                {
                    AddQuest(l_Quest, this);

                    l_Slot = FindQuestSlot(l_Current.first);

                    if (l_Slot < MAX_QUEST_LOG_SIZE)
                    {
                        for (auto l_Objective : l_Quest->QuestObjectives)
                        {
                            SetQuestSlotCounter(l_Slot, l_Objective.Index, m_questObjectiveStatus[l_Objective.ID]);
                        }
                    }
                }
            }
        }
    }

    if (!Unit::UpdatePosition(x, y, z, orientation, teleport))
        return false;

    //if (movementInfo.flags & MOVEMENTFLAG_MOVING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
    //if (movementInfo.flags & MOVEMENTFLAG_TURNING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
    //AURA_INTERRUPT_FLAG_JUMP not sure

    // group update
    if (GetGroup())
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);

    // code block for underwater state update
    // Unit::SetPosition() checks for validity and update our coordinates
    // so we re-fetch them instead of using "raw" coordinates from function params
    UpdateUnderwaterState(GetMap(), GetPositionX(), GetPositionY(), GetPositionZ());

    if (GetTrader() && !IsWithinDistInMap(GetTrader(), INTERACTION_DISTANCE))
        GetSession()->SendCancelTrade();

    CheckAreaExploreAndOutdoor();

    return true;
}

void Player::SaveRecallPosition()
{
    m_recallMap = GetMapId();
    m_recallX = GetPositionX();
    m_recallY = GetPositionY();
    m_recallZ = GetPositionZ();
    m_recallO = GetOrientation();
}

void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self, const GuidUnorderedSet& p_IgnoreList)
{
    if (self)
        GetSession()->SendPacket(data);

    JadeCore::MessageDistDeliverer notifier(this, data, dist, false, nullptr, p_IgnoreList);
    VisitNearbyWorldObject(dist, notifier);
}

void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self, bool own_team_only)
{
    if (self)
        GetSession()->SendPacket(data);

    JadeCore::MessageDistDeliverer notifier(this, data, dist, own_team_only);
    VisitNearbyWorldObject(dist, notifier);
}

void Player::SendMessageToSet(WorldPacket* data, Player const* skipped_rcvr, const GuidUnorderedSet& p_IgnoreList)
{
    if (skipped_rcvr != this)
        GetSession()->SendPacket(data);

    // we use World::GetMaxVisibleDistance() because i cannot see why not use a distance
    // update: replaced by GetMap()->GetVisibilityDistance()
    JadeCore::MessageDistDeliverer notifier(this, data, GetVisibilityRange(), false, skipped_rcvr, p_IgnoreList);
    VisitNearbyWorldObject(GetVisibilityRange(), notifier);
}

void Player::SendDirectMessage(WorldPacket* data)
{
    m_session->SendPacket(data);
}

//////////////////////////////////////////////////////////////////////////
/// Cinematic
//////////////////////////////////////////////////////////////////////////
void Player::StopCinematic()
{
    if (m_CinematicSequence && IsInWorld())
    {
        m_CinematicSequence         = NULL;
        m_InCinematic               = false;
        m_CinematicClientStartTime  = 0;

        Unit::UpdatePosition(m_CinematicStartX, m_CinematicStartY, m_CinematicStartZ, m_CinematicStartO, true);

        getHostileRefManager().setOnlineOfflineState(true);

        SetFall(true);

        RemoveAura(60190);
    }
}
void Player::SendCinematicStart(uint32 p_CinematicSequenceId)
{
    WorldPacket l_Data(SMSG_TRIGGER_CINEMATIC, 4);
    l_Data << uint32(p_CinematicSequenceId);
    SendDirectMessage(&l_Data);

    StopCinematic();

    m_CinematicSequence = const_cast<CinematicSequence*>(sCinematicSequenceMgr->GetSequence(p_CinematicSequenceId));

    if (m_CinematicSequence)
    {
        m_CinematicClientStartTime  = (getMSTime() - GetSession()->GetLatency()) + 1500;
        m_InCinematic               = true;

        m_CinematicStartX = m_positionX;
        m_CinematicStartY = m_positionY;
        m_CinematicStartZ = m_positionZ;
        m_CinematicStartO = GetOrientation();

        getHostileRefManager().setOnlineOfflineState(false);

        SetFall(false);

        AddAura(60190, this);
    }
}

void Player::SendMovieStart(uint32 MovieId)
{
    WorldPacket data(SMSG_TRIGGER_MOVIE, 4);
    data << uint32(MovieId);
    SendDirectMessage(&data);

    CurrentPlayedMovie = MovieId;
}

bool Player::CanMountAsPassenger(Player* l_DriverPlayer) const
{
    // Crossfaction mount
    if (GetTeam() != l_DriverPlayer->GetTeam())
    {
        if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ALLOW_TWO_SIDE_INTERACTION_MOUNT))
            return false;

        if (AreaTableEntry const* l_Zone = GetAreaEntryByAreaID(l_DriverPlayer->GetZoneId()))
        {
            if (l_Zone->Flags & AreaFlags::AREA_FLAG_CAPITAL && !l_Zone->IsSanctuary())
            {
                if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ALLOW_TWO_SIDE_INTERACTION_MOUNT_CAPITALS))
                    return false;
            }
        }
    }

    return true;
}

void Player::CheckAreaExploreAndOutdoor()
{
    if (!isAlive())
        return;

    if (isInFlight())
        return;

    bool isOutdoor;
    uint16 areaFlag = GetBaseMap()->GetAreaFlag(GetPositionX(), GetPositionY(), GetPositionZ(), &isOutdoor);

    if (isOutdoor != m_IsOutdoors)
        sScriptMgr->OnSwitchOutdoorsState(this, isOutdoor);

    m_IsOutdoors = isOutdoor;

    if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !isOutdoor)
        RemoveAurasWithAttribute(SPELL_ATTR0_OUTDOORS_ONLY);

    if (areaFlag == 0xffff)
        return;
    int offset = areaFlag / 32;

    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Wrong area flag %u in map data for (X: %f Y: %f) point to field PLAYER_FIELD_EXPLORED_ZONES + %u ( %u must be < %u ).", areaFlag, GetPositionX(), GetPositionY(), offset, offset, PLAYER_EXPLORED_ZONES_SIZE);
        return;
    }

    uint32 val = (uint32)(1 << (areaFlag % 32));
    uint32 currFields = GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset);

    if (!(currFields & val))
    {
        SetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset, (uint32)(currFields | val));

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EXPLORE_AREA);

        AreaTableEntry const* areaEntry = GetAreaEntryByAreaFlagAndMap(areaFlag, GetMapId());
        if (!areaEntry)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %u discovered unknown area (x: %f y: %f z: %f map: %u", GetGUIDLow(), GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
            return;
        }

        if (areaEntry->ExplorationLevel > 0)
        {
            uint32 area = areaEntry->ID;
            if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            {
                SendExplorationExperience(area, 0);
            }
            else
            {
                int32 diff = int32(getLevel()) - areaEntry->ExplorationLevel;
                uint32 XP = 0;

                float ExploreXpRate = 1;
                if (GetPersonnalXpRate())
                   ExploreXpRate = GetPersonnalXpRate();
                else
                   ExploreXpRate = sWorld->getRate(RATE_XP_EXPLORE);

                if (diff < -5)
                {
                    XP = uint32(sObjectMgr->GetBaseXP(getLevel()+5) * ExploreXpRate);
                }
                else if (diff > 5)
                {
                    int32 exploration_percent = (100-((diff-5)*5));
                    if (exploration_percent > 100)
                        exploration_percent = 100;
                    else if (exploration_percent < 0)
                        exploration_percent = 0;

                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * exploration_percent / 100 * ExploreXpRate);
                }
                else
                {
                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * ExploreXpRate);
                }

                if (GetSession()->IsPremium())
                    XP *= sWorld->getRate(RATE_XP_EXPLORE_PREMIUM);

                GiveXP(XP, NULL);
                SendExplorationExperience(area, XP);
            }
            sLog->outInfo(LOG_FILTER_PLAYER, "Player %u discovered a new area: %u", GetGUIDLow(), area);
        }
    }
}

uint32 Player::TeamForRace(uint8 race)
{
    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race))
    {
        switch (rEntry->TeamID)
        {
            case 1: return HORDE;
            case 7: return ALLIANCE;
            case 42: return PANDAREN_NEUTRAL;
        }
    }

    return ALLIANCE;
}

void Player::setFactionForRace(uint8 race)
{
    // temporary hack for rated bg factions
    if (HasAura(81748))
    {
        RemoveAura(81748);
        AddAura(81748, this);
        return;
    }
    else if (HasAura(81744))
    {
        RemoveAura(81744);
        AddAura(81744, this);
        return;
    }

    m_team = TeamForRace(race);

    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
    setFaction(rEntry ? rEntry->FactionID : 0);
}

ReputationRank Player::GetReputationRank(uint32 faction) const
{
    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction);
    return GetReputationMgr().GetRank(factionEntry);
}

/// Calculate total reputation percent player gain with quest/creature level
int32 Player::CalculateReputationGain(ReputationSource p_Source, uint32 p_CreatureOrQuestLevel, int32 p_Reputation, int32 faction, bool p_NoQuestBonus)
{
    float l_Percent         = 100.0f;
    float l_ReputationMod   = p_NoQuestBonus ? 0.0f : float(GetTotalAuraModifier(SPELL_AURA_MOD_REPUTATION_GAIN));

    /// faction specific auras only seem to apply to kills
    if (p_Source == REPUTATION_SOURCE_KILL)
        l_ReputationMod += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction);

    l_Percent += p_Reputation > 0 ? l_ReputationMod : -l_ReputationMod;

    float l_Rate;
    switch (p_Source)
    {
        case REPUTATION_SOURCE_KILL:
            l_Rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_KILL);
            break;

        case REPUTATION_SOURCE_QUEST:
        case REPUTATION_SOURCE_DAILY_QUEST:
        case REPUTATION_SOURCE_WEEKLY_QUEST:
        case REPUTATION_SOURCE_MONTHLY_QUEST:
        case REPUTATION_SOURCE_REPEATABLE_QUEST:
            l_Rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_QUEST);
            break;

        case REPUTATION_SOURCE_SPELL:
        default:
            l_Rate = 1.0f;
            break;
    }

    if (l_Rate != 1.0f && p_CreatureOrQuestLevel < JadeCore::XP::GetGrayLevel(getLevel()))
        l_Percent *= l_Rate;

    if (l_Percent <= 0.0f)
        return 0;

    /// Multiply result with the faction specific rate
    if (RepRewardRate const* repData = sObjectMgr->GetRepRewardRate(faction))
    {
        float l_ReputationRate = 0.0f;
        switch (p_Source)
        {
            case REPUTATION_SOURCE_KILL:
                l_ReputationRate = repData->creature_rate;
                break;

            case REPUTATION_SOURCE_QUEST:
            case REPUTATION_SOURCE_DAILY_QUEST:         ///< @TODO
            case REPUTATION_SOURCE_WEEKLY_QUEST:        ///< @TODO
            case REPUTATION_SOURCE_MONTHLY_QUEST:       ///< @TODO
            case REPUTATION_SOURCE_REPEATABLE_QUEST:    ///< @TODO
                l_ReputationRate = repData->quest_rate;
                break;

            case REPUTATION_SOURCE_SPELL:
                l_ReputationRate = repData->spell_rate;
                break;
        }

        /// for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
        if (l_ReputationRate <= 0.0f)
            return 0;

        l_Percent *= l_ReputationRate;
    }

    if (p_Source != REPUTATION_SOURCE_SPELL && GetsRecruitAFriendBonus(false))
        l_Percent *= 1.0f + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS);

    return CalculatePct(p_Reputation, l_Percent);
}

/// Calculates how many reputation points player gains in victim's enemy factions
void Player::RewardReputation(Unit* p_Victim, float p_Rate)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (p_Victim->ToCreature()->IsReputationGainDisabled())
        return;

    if (HasAura(186404)) ///< Sign of the Emissary (Weekly event bonus)
    {
        uint32 l_Zone = GetZoneId();
        uint32 l_Team = GetTeam();

        Creature* l_Creature = p_Victim->ToCreature();

        if (l_Creature == nullptr)
            return;

        if (l_Creature->GetMap()->IsMythic() || l_Creature->GetMap()->IsHeroic())
        {
            std::map<int32, int32>    l_ReputationByMap;
            l_ReputationByMap[6988] = 1515;                                 ///< Skyreach / Arakkoa Outcasts
            l_ReputationByMap[6912] = l_Team == ALLIANCE ? 1710 : 1708;     ///< Auchindoun  / Sha'tari Defense (Alliance), Laughing Skull (Horde)
            l_ReputationByMap[7109] = l_Team == ALLIANCE ? 1710 : 1708;     ///< The Everbloom  / Sha'tari Defense (Alliance), Laughing Skull (Horde)
            l_ReputationByMap[6932] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Shadowmoon Burial Grounds  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6984] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Grimrail Depot  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6951] = l_Team == ALLIANCE ? 1731 : 1445;     ///< Iron Docks  / Council of Exarchs (Alliance), Frostwolf Orcs (Horde)
            l_ReputationByMap[6874] = 1711;                                 ///< Bloodmaul Slag Mines  / Steamwheedle Preservation Society
            l_ReputationByMap[7307] = 1711;                                 ///< Upper Blackrock Spire  / Steamwheedle Preservation Society

            int32 l_FactionID = 0;
            for (auto& l_Reputation : l_ReputationByMap)
            {
                if (l_Zone == l_Reputation.first)
                    l_FactionID = l_Reputation.second;
            }

            if (l_FactionID)
            {
                int16 l_ReputationGain = 20;
                if (l_Creature->IsDungeonBoss())
                    l_ReputationGain = 400;

                FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(l_FactionID);
                uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
                if (factionEntry1)
                    GetReputationMgr().ModifyReputation(factionEntry1, l_ReputationGain);
            }
        }
    }

    ReputationOnKillEntry const* l_Reputation = sObjectMgr->GetReputationOnKilEntry(p_Victim->ToCreature()->GetCreatureTemplate()->Entry);

    if (GetChampioningFaction() && !l_Reputation && p_Victim->ToCreature())
    {
        /// Support for: Championing - http://www.wowwiki.com/Championing

        Map const* l_Map = GetMap();
        if (l_Map && l_Map->IsDungeon() && !l_Map->IsRaid())
        {
            AccessRequirement const* l_AccessRequirement = sObjectMgr->GetAccessRequirement(l_Map->GetId(), ((InstanceMap*)l_Map)->GetDifficultyID());
            if (l_AccessRequirement && l_AccessRequirement->levelMin >= 80)
            {
                uint32 l_ReputationGain = 0;

                switch (p_Victim->ToCreature()->GetCreatureTemplate()->rank)
                {
                    case CREATURE_ELITE_TRIVIAL:
                    case CREATURE_ELITE_NORMAL:
                    case CREATURE_ELITE_RARE:
                        l_ReputationGain = l_Map->GetDifficultyID() == DifficultyHeroic ? 5 : 3;
                        break;
                    case CREATURE_ELITE_ELITE:
                        l_ReputationGain = 15;
                        break;
                    case CREATURE_ELITE_RAREELITE:
                    case CREATURE_ELITE_WORLDBOSS:
                        l_ReputationGain = 300;
                        break;
                    default:
                        break;
                }

                if (l_ReputationGain)
                {
                    FactionEntry const* l_FactionEntry = sFactionStore.LookupEntry(GetChampioningFaction());

                    if (l_FactionEntry)
                        GetReputationMgr().ModifyReputation(l_FactionEntry, l_ReputationGain, true);
                }
            }
        }
    }

    if (!l_Reputation)
        return;

    uint32 l_Zone = GetZoneId();
    uint32 l_Team = GetTeam();
    float l_BonusReputationRate = 0;

    /// Thrallmar's Favor and Honor Hold's Favor
    if ((l_Zone == 3483 || l_Zone == 3562 || l_Zone == 3836 || l_Zone == 3713 || l_Zone == 3714) && (HasAura(32096) || HasAura(32098)))
        l_BonusReputationRate = 0.25;

    /// Cenarion Favor
    if ((l_Reputation->RepFaction1 == 609 || l_Reputation->RepFaction2 == 609) && HasAura(30754))
        l_BonusReputationRate = 0.25;

    if (l_Reputation->RepFaction1 && (!l_Reputation->TeamDependent || l_Team == ALLIANCE))
    {
        int32 l_StandingA = CalculateReputationGain(REPUTATION_SOURCE_KILL, p_Victim->getLevel(), l_Reputation->RepValue1, l_Reputation->RepFaction1, false);
        l_StandingA = int32(float(l_StandingA) * (p_Rate + l_BonusReputationRate));

        if (FactionEntry const* l_FactionEntryA = sFactionStore.LookupEntry(l_Reputation->RepFaction1))
        {
            if (GetReputationMgr().GetRank(l_FactionEntryA) <= l_Reputation->ReputationMaxCap1)
                GetReputationMgr().ModifyReputation(l_FactionEntryA, l_StandingA);
        }
    }

    if (l_Reputation->RepFaction2 && (!l_Reputation->TeamDependent || l_Team == HORDE))
    {
        int32 l_StandingB = CalculateReputationGain(REPUTATION_SOURCE_KILL, p_Victim->getLevel(), l_Reputation->RepValue2, l_Reputation->RepFaction2, false);
        l_StandingB = int32(float(l_StandingB) * (p_Rate + l_BonusReputationRate));

        if (FactionEntry const* l_FactionEntryB = sFactionStore.LookupEntry(l_Reputation->RepFaction2))
        {
            if (GetReputationMgr().GetRank(l_FactionEntryB) <= l_Reputation->ReputationMaxCap2)
                GetReputationMgr().ModifyReputation(l_FactionEntryB, l_StandingB);
        }
    }
}

void Player::RewardSkill(Quest const* p_Quest)
{
    uint32 l_SkillID = p_Quest->GetRewardSkillId();
    uint32 l_RewardSkillPoints = p_Quest->GetRewardSkillPoints();
    if (!l_SkillID || !l_RewardSkillPoints)
        return;

    UpdateSkillPro(l_SkillID, 1000, l_RewardSkillPoints);
}

//Calculate how many reputation points player gain with the quest
void Player::RewardReputation(Quest const* p_Quest)
{
    // quest reputation reward/loss
    for (uint8 l_I = 0; l_I < QUEST_REPUTATIONS_COUNT; ++l_I)
    {
        if (!p_Quest->RewardFactionId[l_I])
            continue;

        int32 l_Reputation = 0;
        bool l_NoQuestBonus = false;

        if (p_Quest->RewardFactionValueIdOverride[l_I])
        {
            l_Reputation = p_Quest->RewardFactionValueIdOverride[l_I] / 100;
            l_NoQuestBonus = true;
        }
        else
        {
            uint32 l_Row = ((p_Quest->RewardFactionValueId[l_I] < 0) ? 1 : 0) + 1;
            if (QuestFactionRewEntry const* questFactionRewEntry = sQuestFactionRewardStore.LookupEntry(l_Row))
            {
                uint32 field = abs(p_Quest->RewardFactionValueId[l_I]);
                l_Reputation = questFactionRewEntry->QuestRewFactionValue[field];
            }
        }

        if (!l_Reputation)
            continue;

        /// @TODO
        ///if (quest->IsDaily())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsWeekly())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_WEEKLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsMonthly())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_MONTHLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else if (quest->IsRepeatable())
        ///    rep = CalculateReputationGain(REPUTATION_SOURCE_REPEATABLE_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        ///else
            l_Reputation = CalculateReputationGain(REPUTATION_SOURCE_QUEST, GetQuestLevel(p_Quest), l_Reputation, p_Quest->RewardFactionId[l_I], l_NoQuestBonus);

        if (FactionEntry const* l_FactionEntry = sFactionStore.LookupEntry(p_Quest->RewardFactionId[l_I]))
            GetReputationMgr().ModifyReputation(l_FactionEntry, l_Reputation);
    }
}

Expansion Player::GetExpByLevel()
{
    uint8 level = getLevel();

    if (level <= 60)
        return EXPANSION_VANILLA;
    else if (level <= 70)
        return EXPANSION_THE_BURNING_CRUSADE;
    else if (level <= 80)
        return  EXPANSION_WRATH_OF_THE_LICH_KING;
    else if (level <= 85)
        return EXPANSION_CATACLYSM;
    else if (level <= 90)
        return EXPANSION_MISTS_OF_PANDARIA;
    else if (level <= 100)
        return EXPANSION_WARLORDS_OF_DRAENOR;
    else
        return EXPANSION_VANILLA;
}

void Player::RewardGuildReputation(Quest const* quest)
{
    if (!GetGuild())
        return;

    uint32 rep = 0;

    switch (GetExpByLevel())
    {
        case EXPANSION_VANILLA:                 rep = 25;
            break;
        case EXPANSION_THE_BURNING_CRUSADE:     rep = 50;
            break;
        case  EXPANSION_WRATH_OF_THE_LICH_KING: rep = 75;
            break;
        case EXPANSION_CATACLYSM:               rep = 100;
            break;
        case EXPANSION_MISTS_OF_PANDARIA:       rep = 150;
            break;
        case EXPANSION_WARLORDS_OF_DRAENOR:     rep = 200;      ///<    Not sure
            break;
        default:                                rep = 0;
            break;
    }

    rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, REP_GUILD, true);

    if (GetsRecruitAFriendBonus(false))
        rep = int32(rep * (1 + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS)));

    // Apply reputation multiplier from aura (not stacking-get highest)
    AddPct(rep, GetMaxPositiveAuraModifier(SPELL_AURA_MOD_GUID_REP_GAIN_PCT));

    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(REP_GUILD))
        GetReputationMgr().ModifyReputation(factionEntry, rep);
}

void Player::UpdateHonorFields()
{
    /// called when rewarding honor and at each save
    time_t now = time_t(time(NULL));
    time_t today = time_t(time(NULL) / DAY) * DAY;

    if (m_lastHonorUpdateTime < today)
    {
        time_t yesterday = today - DAY;

        uint16 kills_today = PAIR32_LOPART(GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));

        // update yesterday's contribution
        if (m_lastHonorUpdateTime >= yesterday)
        {
            // this is the first update today, reset today's contribution
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, MAKE_PAIR32(0, kills_today));
        }
        else
        {
            // no honor/kills yesterday or today, reset
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
        }
    }

    m_lastHonorUpdateTime = now;
}

///Calculate the amount of honor gained based on the victim
///and the size of the group for which the honor is divided
///An exact honor value can also be given (overriding the calcs)
bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvptoken, MS::Battlegrounds::RewardCurrencyType::Type p_RewardCurrencyType)
{
    // do not reward honor in arenas, but enable onkill spellproc
    Battleground* l_Bg = GetBattleground();

    if (InArena() && l_Bg != nullptr && !l_Bg->IsSkirmish())
    {
        if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
            return false;

        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
            return false;

        return true;
    }

    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
    if (HasAura(SPELL_AURA_PLAYER_INACTIVE))
        return false;

    uint64 victim_guid = 0;
    uint32 victim_rank = 0;

    // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
    UpdateHonorFields();

    // do not reward honor in arenas, but return true to enable onkill spellproc
    if (InBattleground() && l_Bg && ((l_Bg->isArena() && !l_Bg->IsSkirmish()) || l_Bg->IsRatedBG()))
        return true;

    // Promote to float for calculations
    float honor_f = (float)honor;

    if (honor_f <= 0)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return false;

        victim_guid = victim->GetGUID();

        if (Player* plrVictim = victim->ToPlayer())
        {
            if (GetTeam() == plrVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                return false;

            uint8 k_level = getLevel();
            uint8 k_grey = JadeCore::XP::GetGrayLevel(k_level);
            uint8 v_level = victim->getLevel();

            if (v_level <= k_grey)
                return false;

            // PLAYER_CHOSEN_TITLE VALUES DESCRIPTION
            //  [0]      Just name
            //  [1..14]  Alliance honor titles and player name
            //  [15..28] Horde honor titles and player name
            //  [29..38] Other title and player name
            //  [39+]    Nothing
            uint32 victim_title = victim->GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE);
                                                        // Get Killer titles, CharTitlesEntry::bit_index
            // Ranks:
            //  title[1..14]  -> rank[5..18]
            //  title[15..28] -> rank[5..18]
            //  title[other]  -> 0
            if (victim_title == 0)
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
            else if (victim_title < 15)
                victim_rank = victim_title + 4;
            else if (victim_title < 29)
                victim_rank = victim_title - 14 + 4;
            else
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.

            honor_f = ceil(JadeCore::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));

            // count the number of playerkills in one day
            ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);
            // and those in a lifetime
            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);

#ifndef CROSS
            /// @TODO: cross sync
            if (Guild* l_Guild = GetGuild())
                l_Guild->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, nullptr, this);
#endif
        }
        else
        {
            if (!victim->ToCreature()->isRacialLeader())
                return false;

            honor_f = 100.0f;                               // ??? need more info
            victim_rank = 19;                               // HK: Leader
        }
    }

    if (victim != NULL)
        if (groupsize > 1)
            honor_f /= groupsize;

#ifndef CROSS
    honor_f *= sWorld->getRate(RATE_HONOR);
    if (GetSession()->IsPremium())
        honor_f *= sWorld->getRate(RATE_HONOR_PREMIUM);
#else
    if (InterRealmClient* client = GetSession()->GetInterRealmClient())
    {
        honor_f *= client->GetHonorRate();
 
        if (GetSession()->IsPremium())
            honor_f *= client->GetHonorPremiumRate();
    }
#endif

    // Back to int now
    honor = std::max(int32(honor_f), 1);
    // honor - for show honor points in log
    // victim_guid - for show victim name in log
    // victim_rank [1..4]  HK: <dishonored rank>
    // victim_rank [5..19] HK: <alliance\horde rank>
    // victim_rank [0, 20+] HK: <>

    // add honor points
    honor = ModifyCurrency(CURRENCY_TYPE_HONOR_POINTS, int32(honor), true, false, false, p_RewardCurrencyType);

    WorldPacket data(SMSG_PVP_CREDIT, 4 + 16 + 2 + 4);
    data << uint32(honor);
    data.appendPackGUID(victim_guid);
    data << uint32(victim_rank);
    GetSession()->SendPacket(&data);

    if (InBattleground() && honor > 0)
    {
        if (Battleground* bg = GetBattleground())
        {
            bg->UpdatePlayerScore(this, NULL, SCORE_BONUS_HONOR, honor, false, p_RewardCurrencyType); //false: prevent looping
        }
    }

    if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE) && pvptoken)
    {
        if (!victim || victim == this || victim ->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return true;

        if (victim->IsPlayer())
        {
            // Check if allowed to receive it in current map
            uint8 MapType = sWorld->getIntConfig(CONFIG_PVP_TOKEN_MAP_TYPE);
            if ((MapType == 1 && !InBattleground() && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 2 && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 3 && !InBattleground()))
                return true;

            uint32 itemId = sWorld->getIntConfig(CONFIG_PVP_TOKEN_ID);
            int32 count = sWorld->getIntConfig(CONFIG_PVP_TOKEN_COUNT);

            if (GetOutdoorPvP())
                GetOutdoorPvP()->HandleRewardHonor(this);

            if (AddItem(itemId, count))
                ChatHandler(this).PSendSysMessage("You have been awarded a token for slaying another player.");
        }
    }
    return true;
}

void Player::_LoadCurrency(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint16 currencyID = fields[0].GetUInt16();

        if (!sCurrencyTypesStore.LookupEntry(currencyID))
            continue;

        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_UNCHANGED;
        cur.weekCount = fields[1].GetUInt32();
        cur.totalCount = fields[2].GetUInt32();
        cur.seasonTotal = fields[3].GetUInt32();
        cur.flags = fields[4].GetUInt32();
        cur.weekCap = fields[5].GetUInt32();
        cur.needResetCap = fields[6].GetUInt8();

        if (cur.needResetCap)
        {
            cur.weekCap = CalculateCurrencyWeekCap(currencyID);
            cur.needResetCap = false;
            cur.state = PLAYERCURRENCY_CHANGED;
        }

        _currencyStorage.insert(PlayerCurrenciesMap::value_type(currencyID, cur));

    }
    while (result->NextRow());
}

void Player::_SaveCurrency(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
        if (!entry) // should never happen
            continue;

        switch (itr->second.state)
        {
            case PLAYERCURRENCY_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, itr->first);
                stmt->setUInt32(2, itr->second.weekCount);
                stmt->setUInt32(3, itr->second.totalCount);
                stmt->setUInt32(4, itr->second.seasonTotal);
                stmt->setUInt32(5, itr->second.flags);
                stmt->setUInt32(6, itr->second.weekCap);
                stmt->setUInt8(7, itr->second.needResetCap);
                trans->Append(stmt);
                break;
            case PLAYERCURRENCY_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_CURRENCY);
                stmt->setUInt32(0, itr->second.weekCount);
                stmt->setUInt32(1, itr->second.totalCount);
                stmt->setUInt32(2, itr->second.seasonTotal);
                stmt->setUInt32(3, itr->second.flags);
                stmt->setUInt32(4, itr->second.weekCap);
                stmt->setUInt8(5, itr->second.needResetCap);
                stmt->setUInt32(6, GetRealGUIDLow());
                stmt->setUInt16(7, itr->first);
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.state = PLAYERCURRENCY_UNCHANGED;
    }
}

void Player::SendCurrencies()
{
    WorldPacket l_Data(SMSG_INIT_CURRENCY, 4 + (_currencyStorage.size() * (4 + 4 + 1 + 4 + 4 + 4)));

    l_Data << uint32(_currencyStorage.size());

    for (PlayerCurrenciesMap::const_iterator l_It = _currencyStorage.begin(); l_It != _currencyStorage.end(); ++l_It)
    {
        CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(l_It->first);

        if (!l_CurrencyEntry) // should never happen
            continue;

        uint32 l_WeekCount      = l_It->second.weekCount;
        uint32 l_WeekCap        = GetCurrencyWeekCap(l_CurrencyEntry->ID);
        uint32 l_SeasonTotal    = l_It->second.seasonTotal;

        l_Data << uint32(l_CurrencyEntry->ID);
        l_Data << uint32(l_It->second.totalCount);

        l_Data.WriteBit(l_WeekCount);
        l_Data.WriteBit(l_WeekCap);
        l_Data.WriteBit(l_SeasonTotal);
        l_Data.WriteBits(l_It->second.flags, 5);
        l_Data.FlushBits();

        if (l_WeekCount)
            l_Data << uint32(l_WeekCount);
        if (l_WeekCap)
            l_Data << uint32(l_WeekCap);
        if (l_SeasonTotal)
            l_Data << uint32(l_SeasonTotal);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::SendPvpRewards()
{
    WorldPacket l_Packet(SMSG_REQUEST_PVP_REWARDS_RESPONSE, 65);
    l_Packet << (uint32)GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_POINTS, false);                         ///< Count of gived all conquest points in week
    l_Packet << (uint32)GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_POINTS, false);                        ///< Max Conquest points cap

    l_Packet << (uint32)GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_ARENA_BG, false);                  ///< Count of gived all conquest points in week
    l_Packet << (uint32)GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ARENA_BG, false);                 ///< Max Conquest points cap

    l_Packet << (uint32)GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_ASHRAN, false);                    ///< Ashran currency week
    l_Packet << (uint32)GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ASHRAN, false);                   ///< Ashran currency weekcap

    l_Packet << (uint32)0;                                                                               ///< Count of gived all conquest rewarded in battlegrounds, deprecated
    l_Packet << (uint32)0;                                                                               ///< battleground currency weekcap, deprecated

    l_Packet << (uint32)sWorld->getIntConfig(CONFIG_CURRENCY_CONQUEST_POINTS_RATED_BG_REWARD);           ///< Conquest points from Rated BG win
    l_Packet << (uint32)sWorld->getIntConfig(CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD);              ///< Conquest points from Arena win

    l_Packet << (uint32)0;  ///< Mask
    l_Packet << (uint32)0;  ///< RewardMoney
    l_Packet << (uint32)0;  ///< RewardXP

    l_Packet << (uint32)0;  ///< ItemCount
    l_Packet << (uint32)0;  ///< CurrencyCount
    l_Packet << (uint32)0;  ///< QuantityCount

    l_Packet.WriteBit(false);   ///< unk

    /// 2x the same reader

    l_Packet << (uint32)0;  ///< Mask
    l_Packet << (uint32)0;  ///< RewardMoney
    l_Packet << (uint32)0;  ///< RewardXP

    l_Packet << (uint32)0;  ///< ItemCount
    l_Packet << (uint32)0;  ///< CurrencyCount
    l_Packet << (uint32)0;  ///< QuantityCount

    l_Packet.WriteBit(false);   ///< unk
    l_Packet.FlushBits();

    GetSession()->SendPacket(&l_Packet);
}

uint32 Player::GetCurrency(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.totalCount / precision;
}

uint32 Player::GetCurrencyOnWeek(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.weekCount / precision;
}

uint32 Player::GetCurrencyOnSeason(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.seasonTotal / precision;
}

bool Player::HasCurrency(uint32 id, uint32 count) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    return itr != _currencyStorage.end() && itr->second.totalCount >= count;
}

void Player::ModifyCurrencyFlags(uint32 currencyId, uint8 flags)
{
    if (!currencyId)
        return;

    if (_currencyStorage.find(currencyId) == _currencyStorage.end())
        return;

    _currencyStorage[currencyId].flags = flags;

    if (_currencyStorage[currencyId].state != PLAYERCURRENCY_NEW)
        _currencyStorage[currencyId].state = PLAYERCURRENCY_CHANGED;
}

void Player::ModifyCurrencyAndSendToast(uint32 id, int32 count, bool printLog/* = true*/, bool ignoreMultipliers/* = false*/, bool ignoreLimit /* = false */)
{
    ModifyCurrency(id, count, printLog, ignoreMultipliers, ignoreLimit);

    switch (id)
    {
        case CURRENCY_TYPE_CONQUEST_META_ARENA_BG:
        case CURRENCY_TYPE_CONQUEST_META_RBG:
        case CURRENCY_TYPE_CONQUEST_META_ASHRAN:
            id = CURRENCY_TYPE_CONQUEST_POINTS;
        default:
            break;
    }

    SendDisplayToast(id, count, DISPLAY_TOAST_METHOD_CURRENCY_OR_GOLD, TOAST_TYPE_NEW_CURRENCY, false, false);
}

int32 Player::ModifyCurrency(uint32 p_CurrencyID, int32 p_Count, bool p_SuppressLog /*= true*/, bool p_IgnoreMultipliers /*= false*/, bool p_IgnoreLimit /*= false*/, MS::Battlegrounds::RewardCurrencyType::Type p_RewardCurrencyType /*= None*/)
{
    if (!sWorld->getBoolConfig(WorldBoolConfigs::CONFIG_ARENA_SEASON_IN_PROGRESS) && p_Count >= 0 &&
            (  p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_RBG
            || p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_ARENA_BG
            || p_CurrencyID == CurrencyTypes::CURRENCY_TYPE_CONQUEST_POINTS))
        return p_Count;

    CurrencyTypesEntry const* l_CurrencyEntry = sCurrencyTypesStore.LookupEntry(p_CurrencyID);
    if (!l_CurrencyEntry || !p_Count)
        return 0;

    if (!p_IgnoreMultipliers)
    {
        p_Count *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_CURRENCY_GAIN, p_CurrencyID);

        if (p_RewardCurrencyType)
        {
            float l_Multiplier = 1.0f;
            Unit::AuraEffectList const& l_ModPvpPercent = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_2);
            for (Unit::AuraEffectList::const_iterator i = l_ModPvpPercent.begin(); i != l_ModPvpPercent.end(); ++i)
            {
                if ((*i)->GetMiscValue() == p_CurrencyID && (*i)->GetMiscValueB() == p_RewardCurrencyType)
                    AddPct(l_Multiplier, (*i)->GetAmount());
            }
            p_Count *= l_Multiplier;
        }
    }

    int32 l_Precision = l_CurrencyEntry->Flags & CURRENCY_FLAG_HIGH_PRECISION ? CURRENCY_PRECISION : 1; ///< l_precision is never read 01/18/16
    uint32 l_OldTotalCount          = 0;
    uint32 l_OldWeekCount           = 0;
    uint32 l_OldSeasonTotalCount    = 0;

    PlayerCurrenciesMap::iterator l_CurrencyIT = _currencyStorage.find(p_CurrencyID);
    if (l_CurrencyIT == _currencyStorage.end())
    {
        PlayerCurrency l_NewCurrency;
        l_NewCurrency.state         = PLAYERCURRENCY_NEW;
        l_NewCurrency.totalCount    = 0;
        l_NewCurrency.weekCount     = 0;
        l_NewCurrency.seasonTotal   = 0;
        l_NewCurrency.flags         = 0;
        l_NewCurrency.weekCap       = CalculateCurrencyWeekCap(p_CurrencyID);
        l_NewCurrency.needResetCap  = false;

        _currencyStorage[p_CurrencyID] = l_NewCurrency;
        l_CurrencyIT = _currencyStorage.find(p_CurrencyID);

        l_OldTotalCount       = 0;
        l_OldWeekCount        = 0;
        l_OldSeasonTotalCount = 0;
    }
    else
    {
        l_OldTotalCount       = l_CurrencyIT->second.totalCount;
        l_OldWeekCount        = l_CurrencyIT->second.weekCount;
        l_OldSeasonTotalCount = l_CurrencyIT->second.seasonTotal;
    }

    /// count can't be more then weekCap.
    uint32 l_WeekCap = GetCurrencyWeekCap(l_CurrencyEntry->ID);
    if (!p_IgnoreLimit && l_WeekCap && p_Count > int32(l_WeekCap))
        p_Count = l_WeekCap;

    int32 l_NewTotalCount = int32(l_OldTotalCount) + p_Count;
    if (l_NewTotalCount < 0)
        l_NewTotalCount = 0;

    int32 l_NewWeekCount = !p_IgnoreLimit ? (int32(l_OldWeekCount) + (p_Count > 0 ? p_Count : 0)) : int32(l_OldWeekCount);
    if (l_NewWeekCount < 0)
        l_NewWeekCount = 0;

    int32 l_NewSeasonTotalCount = !p_IgnoreLimit ? (int32(l_OldSeasonTotalCount) + (p_Count > 0 ? p_Count : 0)) : int32(l_OldSeasonTotalCount);

    if (!p_IgnoreLimit)
    {
        /// if we get more then weekCap just set to limit
        if (l_WeekCap && int32(l_WeekCap) < l_NewWeekCount)
        {
            l_NewWeekCount = int32(l_WeekCap);
            /// weekCap - oldWeekCount alwayt >= 0 as we set limit before!
            l_NewTotalCount = l_OldTotalCount + (l_WeekCap - l_OldWeekCount);
        }

        /// if we get more then totalCap set to maximum;
        if (l_CurrencyEntry->TotalCap && int32(l_CurrencyEntry->TotalCap) < l_NewTotalCount)
        {
            l_NewTotalCount = int32(l_CurrencyEntry->TotalCap);
            l_NewWeekCount = l_WeekCap;
        }
    }

    if (l_NewWeekCount < 0)
        l_NewWeekCount = 0;
    if (l_NewTotalCount < 0)
        l_NewTotalCount = 0;

    if (p_CurrencyID == CURRENCY_TYPE_HONOR_POINTS || p_CurrencyID == CURRENCY_TYPE_JUSTICE_POINTS)
    {
        l_NewWeekCount = l_NewTotalCount;
        l_WeekCap = 0;
    }

    if (uint32(l_NewTotalCount) != l_OldTotalCount)
    {
        if (l_CurrencyIT->second.state != PLAYERCURRENCY_NEW)
            l_CurrencyIT->second.state = PLAYERCURRENCY_CHANGED;

        l_CurrencyIT->second.totalCount = l_NewTotalCount;
        l_CurrencyIT->second.weekCount = l_NewWeekCount;
        l_CurrencyIT->second.seasonTotal = l_NewSeasonTotalCount;

        // probably excessive checks
        if (IsInWorld() && !GetSession()->PlayerLoading())
        {
            if (p_Count > 0 && !p_IgnoreLimit)
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CURRENCY, p_CurrencyID, p_Count);

            if (l_CurrencyEntry->Category == CURRENCY_CATEGORY_META_CONQUEST)
            {
                // count was changed to week limit, now we can modify original points.
                ModifyCurrency(CURRENCY_TYPE_CONQUEST_POINTS, p_Count, p_SuppressLog);
                return p_Count;
            }

            if (p_CurrencyID == CURRENCY_TYPE_CONQUEST_POINTS)
                SendPvpRewards();

            /// Update archaeology projects
            if (l_CurrencyEntry->Flags & CURRENCY_FLAG_ARCHAEOLOGY_FRAGMENT && GetSkillValue(SKILL_ARCHAEOLOGY))
                m_archaeologyMgr.GenerateResearchProjects();

             // on new case just set init.
            if (l_OldTotalCount == 0 && l_CurrencyIT->second.state == PLAYERCURRENCY_NEW)
            {
                l_CurrencyIT->second.weekCap = CalculateCurrencyWeekCap(p_CurrencyID);
                SendCurrencies();
                return p_Count;
            }

            QuestObjectiveSatisfy(p_CurrencyID, p_Count, QUEST_OBJECTIVE_TYPE_CURRENCY);

            WorldPacket l_Packet(SMSG_UPDATE_CURRENCY);

            l_Packet << uint32(p_CurrencyID);
            l_Packet << uint32(l_NewTotalCount);
            l_Packet << uint32(l_CurrencyIT->second.flags);

            l_Packet.WriteBit(l_WeekCap != 0);
            l_Packet.WriteBit(l_CurrencyIT->second.seasonTotal);
            l_Packet.WriteBit(p_SuppressLog);
            l_Packet.FlushBits();

            if (l_WeekCap)
                l_Packet << uint32(l_NewWeekCount);

            if (l_CurrencyIT->second.seasonTotal)
                l_Packet << uint32(l_CurrencyIT->second.seasonTotal);

            GetSession()->SendPacket(&l_Packet);
        }
    }
    return p_Count;
}

void Player::SetCurrency(uint32 id, uint32 count, bool printLog /*= true*/)
{
    ModifyCurrency(id, int32(count) - GetCurrency(id, true), printLog);
}

uint32 Player::GetCurrencyWeekCap(uint32 id, bool usePrecision)
{
    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
    if (!entry)
        return 0;

    uint32 precision = (usePrecision && entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonTotal = 0;
        cur.flags = 0;
        cur.weekCap = CalculateCurrencyWeekCap(id);
        cur.needResetCap = false;
        _currencyStorage[id] = cur;
        itr = _currencyStorage.find(id);
    }

    return itr->second.weekCap / precision;
}

void Player::ResetCurrencyWeekCap()
{
    FinishWeek();                              // set played this week etc values to 0 in memory, too

    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        itr->second.weekCount = 0;
        itr->second.state = PLAYERCURRENCY_CHANGED;
        itr->second.weekCap = CalculateCurrencyWeekCap(itr->first);
    }

    WorldPacket data(SMSG_WEEKLY_RESET_CURRENCY, 0);
    SendDirectMessage(&data);
}

uint32 Player::CalculateCurrencyWeekCap(uint32 id)
{
    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);

    if (!entry)
        return 0;

    uint32 cap = entry->WeekCap;

    switch (entry->ID)
    {
        case CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_ARENA_BG:
        {
            uint32 l_MaxRating = 0;
            for (int l_Slot = 0; l_Slot < MAX_ARENA_SLOT; ++ l_Slot)
                if (GetPrevWeekGames(l_Slot))
                    l_MaxRating = std::max(l_MaxRating, GetArenaPersonalRating(l_Slot));

            cap = Arena::GetConquestCapFromRating(l_MaxRating) * CURRENCY_PRECISION;
            break;
        }
        case CurrencyTypes::CURRENCY_TYPE_CONQUEST_META_ASHRAN:
            cap = sWorld->getIntConfig(CONFIG_CURRENCY_ASHRAN_CONQUEST_POINTS_WEEK_CAP);
            break;
        case CurrencyTypes::CURRENCY_TYPE_CONQUEST_POINTS:
        {
            uint32 l_MaxRating = 0;

            for (int l_Slot = 0; l_Slot < MAX_ARENA_SLOT; ++ l_Slot)
                if (GetPrevWeekGames(l_Slot))
                    l_MaxRating = std::max(l_MaxRating, GetArenaPersonalRating(l_Slot));

            cap = Arena::GetConquestCapFromRating(l_MaxRating) * CURRENCY_PRECISION + sWorld->getIntConfig(CONFIG_CURRENCY_ASHRAN_CONQUEST_POINTS_WEEK_CAP);
            break;
        }
    }

    return cap;
}

void Player::SetInGuild(uint32 guildId)
{
    if (guildId)
        SetGuidValue(OBJECT_FIELD_DATA, MAKE_NEW_GUID(guildId, 0, HIGHGUID_GUILD));
    else
        SetGuidValue(OBJECT_FIELD_DATA, 0);

    ApplyModFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GUILD_LEVEL_ENABLED, guildId != 0 && sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED));
    SetUInt16Value(OBJECT_FIELD_TYPE, 1, guildId != 0);
}

uint32 Player::GetGuildIdFromDB(uint64 guid, uint32 realmId)
{
#ifndef CROSS
    auto l_Database = &CharacterDatabase;
#else /* CROSS */
    InterRealmDatabasePool* l_Database = sInterRealmMgr->GetClientByRealmNumber(realmId)->GetDatabase();
#endif

    PreparedStatement* stmt = l_Database->GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt32(0, GUID_LOPART(guid));
    if (PreparedQueryResult result = l_Database->Query(stmt))
        return result->Fetch()[0].GetUInt32();

    return 0;
}

uint8 Player::GetRankFromDB(uint64 guid)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt32(0, GUID_LOPART(guid));
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        return result->Fetch()[1].GetUInt8();
#endif
    return 0;
}

uint32 Player::GetZoneIdFromDB(uint64 guid)
{
    uint32 zone = 0;
#ifndef CROSS
    uint32 guidLow = GUID_LOPART(guid);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
    stmt->setUInt32(0, guidLow);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;
    Field* fields = result->Fetch();
    zone = fields[0].GetUInt16();

    if (!zone)
    {
        // stored zone is zero, use generic and slow zone detection
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
        stmt->setUInt32(0, guidLow);
        PreparedQueryResult result = CharacterDatabase.Query(stmt);

        if (!result)
            return 0;
        fields = result->Fetch();
        uint32 map = fields[0].GetUInt16();
        float posx = fields[1].GetFloat();
        float posy = fields[2].GetFloat();
        float posz = fields[3].GetFloat();

        if (!sMapStore.LookupEntry(map))
            return 0;

        zone = sMapMgr->GetZoneId(map, posx, posy, posz);

        if (zone > 0)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ZONE);

            stmt->setUInt16(0, uint16(zone));
            stmt->setUInt32(1, guidLow);

            CharacterDatabase.Execute(stmt);
        }
    }
#endif

    return zone;
}

uint32 Player::GetLevelFromDB(uint64 guid)
{
    uint8 level = 0;

#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_LEVEL);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;

    Field* fields = result->Fetch();
    level = fields[0].GetUInt8();
#endif

    return level;
}

void Player::UpdateArea(uint32 newArea)
{
    uint32 l_OldArea = m_areaUpdateId;

    // FFA_PVP flags are area and not zone id dependent
    // so apply them accordingly
    m_areaUpdateId    = newArea;

    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    AreaTableEntry const* area = GetAreaEntryByAreaID(newArea);
    pvpInfo.inFFAPvPArea = (area && (area->Flags & AREA_FLAG_ARENA)) || InRatedBattleGround() || pvpInfo.forceFFA;
    UpdatePvPState(true);

    //Pandaria area update for monk level < 85
    if (area && getLevel() < 85 && getClass() == CLASS_MONK && GetMapId() == 870 && area->ContinentID == 870 &&
        newArea != 6081 && newArea != 6526 && newArea != 6527
        && GetZoneId() == 5841 && !isGameMaster())
        TeleportTo(870, 3818.55f, 1793.18f, 950.35f, GetOrientation());

    UpdateAreaDependentAuras(newArea);

    // previously this was in UpdateZone (but after UpdateArea) so nothing will break
    pvpInfo.inNoPvPArea = false;
    if (area && area->IsSanctuary())    // in sanctuary
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_SANCTUARY);
        pvpInfo.inNoPvPArea = true;
        CombatStopWithPets();
    }
    else
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_SANCTUARY);

    uint32 const l_AreaRestFlag = (GetTeam() == ALLIANCE) ? AREA_FLAG_REST_ZONE_ALLIANCE : AREA_FLAG_REST_ZONE_HORDE;
    if (area && (area->Flags & l_AreaRestFlag))
    {
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
        SetRestType(REST_TYPE_IN_FACTION_AREA);
        InnEnter(time(0), GetMapId(), 0, 0, 0);
    }
    else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) && GetRestType() == REST_TYPE_IN_FACTION_AREA)
    {
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
        SetRestType(REST_TYPE_NO);
    }

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    if (l_OldArea != newArea)
    {
        uint64 l_Guid = GetGUID();

        sOutdoorPvPMgr->HandlePlayerLeaveArea(this, l_OldArea);
        sOutdoorPvPMgr->HandlePlayerEnterArea(this, newArea);
#ifndef CROSS

        /// Garrison phasing specific code
        if (m_Garrison && m_Garrison->GetGarrisonSiteLevelEntry() && (GetMapId() == MS::Garrison::Globals::BaseMap || GetMapId() == m_Garrison->GetGarrisonSiteLevelEntry()->MapID || GetMapId() == MS::Garrison::ShipyardMapId::Alliance || GetMapId() == MS::Garrison::ShipyardMapId::Horde))
        {
            Map * l_Map = sMapMgr->FindBaseNonInstanceMap(MS::Garrison::Globals::BaseMap);

            if (!l_Map)
                l_Map = sMapMgr->CreateBaseMap(MS::Garrison::Globals::BaseMap);

            if (l_Map)
            {
                uint32 l_DraenorBaseMap_Zone;
                uint32 l_DraenorBaseMap_Area;

                l_Map->GetZoneAndAreaId(l_DraenorBaseMap_Zone, l_DraenorBaseMap_Area, m_positionX, m_positionY, m_positionZ);
                const GarrSiteLevelEntry * l_GarrisonSiteEntry = m_Garrison->GetGarrisonSiteLevelEntry();

                if (l_DraenorBaseMap_Area != MS::Garrison::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()] && IsInShipyard())
                {
                    sMapMgr->AddCriticalOperation([l_Guid]() -> bool
                    {
                        Player * l_Player = sObjectAccessor->FindPlayer(l_Guid);

                        if (l_Player && l_Player->IsInWorld())
                        {
                            l_Player->_SetOutOfShipyard();
                            return true;
                        }

                        return false;
                    });
                }
                else if (l_DraenorBaseMap_Area == MS::Garrison::gGarrisonShipyardAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == MS::Garrison::Globals::BaseMap)
                {
                    sMapMgr->AddCriticalOperation([l_Guid]() -> bool
                    {
                        Player * l_Player = sObjectAccessor->FindPlayer(l_Guid);

                        if (l_Player && l_Player->IsInWorld())
                        {
                            l_Player->_SetInShipyard();
                            return true;
                        }

                        return false;
                    });
                }

                if (l_DraenorBaseMap_Area != MS::Garrison::gGarrisonInGarrisonAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == l_GarrisonSiteEntry->MapID)
                {
                    sMapMgr->AddCriticalOperation([l_Guid]() -> bool
                    {
                        Player * l_Player = HashMapHolder<Player>::Find(l_Guid);

                        if (l_Player && l_Player->IsInWorld())
                        {
                            l_Player->_GarrisonSetOut();
                            return true;
                        }

                        return false;
                    });
                }
                else if (l_DraenorBaseMap_Area == MS::Garrison::gGarrisonInGarrisonAreaID[m_Garrison->GetGarrisonFactionIndex()] && GetMapId() == MS::Garrison::Globals::BaseMap)
                {
                    sMapMgr->AddCriticalOperation([l_Guid]() -> bool
                    {
                        Player * l_Player = HashMapHolder<Player>::Find(l_Guid);

                        if (l_Player && l_Player->IsInWorld())
                        {
                            l_Player->_GarrisonSetIn();
                            return true;
                        }

                        return false;
                    });
                }
            }
        }
#endif /* not CROSS */
    }
}

#ifndef CROSS
void Player::_GarrisonSetIn()
{
    if (!m_Garrison)
        return;

    const GarrSiteLevelEntry * l_GarrisonSiteEntry = m_Garrison->GetGarrisonSiteLevelEntry();

    if (!l_GarrisonSiteEntry)
        return;

    Difficulty l_DungeonDiff = DifficultyNormal;
    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    SwitchToPhasedMap(l_GarrisonSiteEntry->MapID);
    m_Garrison->OnPlayerEnter();

    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    phaseMgr.Update();
    phaseMgr.ForceMapShiftUpdate();
}

void Player::_GarrisonSetOut()
{
    if (!m_Garrison)
        return;

    m_Garrison->OnPlayerLeave();
    m_Garrison->_SetGarrisonScript(nullptr);

    SwitchToPhasedMap(MS::Garrison::Globals::BaseMap);

    phaseMgr.Update();
    phaseMgr.ForceMapShiftUpdate();
}

void Player::_SetInShipyard()
{
    if (!m_Garrison || !m_Garrison->HasShipyard())
        return;

    Difficulty l_DungeonDiff = DifficultyNormal;
    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    SwitchToPhasedMap(m_Garrison->GetShipyardMapId());

    std::swap(l_DungeonDiff, m_dungeonDifficulty);

    phaseMgr.Update();
    phaseMgr.ForceMapShiftUpdate();
}

void Player::_SetOutOfShipyard()
{
    if (!m_Garrison || !m_Garrison->HasShipyard())
        return;

    SwitchToPhasedMap(MS::Garrison::Globals::BaseMap);

    phaseMgr.Update();
    phaseMgr.ForceMapShiftUpdate();
}

#endif /* not CROSS */
void Player::UpdateZone(uint32 newZone, uint32 newArea)
{
    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);

    if (m_zoneUpdateId != newZone)
    {
        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerEnterZone(this, newZone);
        SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
    }

    // group update
    if (Group* group = GetGroup())
    {
        SetGroupUpdateFlag(GROUP_UPDATE_FULL);
        if (GetSession() && group->isLFGGroup() && sLFGMgr->IsTeleported(GetGUID()))
        {
            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
            {
                if (Player* member = itr->getSource())
                    GetSession()->SendNameQueryOpcode(member->GetGUID());
            }
        }
    }

    uint32 l_OldZone  = m_zoneUpdateId;
    m_zoneUpdateId    = newZone;
    m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;

    // zone changed, so area changed as well, update it
    UpdateArea(newArea);

    sScriptMgr->OnPlayerUpdateZone(this, newZone, l_OldZone, newArea);

    AreaTableEntry const* zone = GetAreaEntryByAreaID(newZone);
    if (!zone)
        return;

    if (sWorld->getBoolConfig(CONFIG_WEATHER) && !HasAuraType(SPELL_AURA_FORCE_WEATHER))
    {
        if (Weather* weather = WeatherMgr::FindWeather(zone->ID))
            weather->SendWeatherUpdateToPlayer(this);
        else
        {
            if (!WeatherMgr::AddWeather(zone->ID))
            {
                // send fine weather packet to remove old zone's weather
                WeatherMgr::SendFineWeatherUpdateToPlayer(this);
            }
        }
    }

    // in PvP, any not controlled zone (except zone->team == 6, default case)
    // in PvE, only opposition team capital
    switch (zone->FactionGroupMask)
    {
        case AREATEAM_ALLY:
            pvpInfo.inHostileArea = GetTeam() != ALLIANCE && (sWorld->IsPvPRealm() || zone->Flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_HORDE:
            pvpInfo.inHostileArea = GetTeam() != HORDE && (sWorld->IsPvPRealm() || zone->Flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_NONE:
            // overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
            pvpInfo.inHostileArea = sWorld->IsPvPRealm() || InBattleground() || zone->Flags & AREA_FLAG_WINTERGRASP;
            break;
        default:                                            // 6 in fact
            pvpInfo.inHostileArea = false;
            break;
    }

    if (zone->Flags & AREA_FLAG_CAPITAL)                     // Is in a capital city
    {
        if (!pvpInfo.inHostileArea || zone->IsSanctuary())
        {
            SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
            SetRestType(REST_TYPE_IN_CITY);
            InnEnter(time(0), GetMapId(), 0, 0, 0);
        }
        pvpInfo.inNoPvPArea = true;
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
        {
            if (GetRestType() == REST_TYPE_IN_TAVERN)        // Still inside a tavern or has recently left
            {
                // Remove rest state if we have recently left a tavern.
                if (GetMapId() != GetInnPosMapId() || GetExactDist(GetInnPosX(), GetInnPosY(), GetInnPosZ()) > 1.0f)
                {
                    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                    SetRestType(REST_TYPE_NO);
                }
            }
            else if (GetRestType() != REST_TYPE_IN_FACTION_AREA) // handled in UpdateArea
            {
                // Recently left a capital city
                RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                SetRestType(REST_TYPE_NO);
            }
        }
    }

    UpdatePvPState();

    // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
    // if player resurrected at teleport this will be applied in resurrect code
    if (isAlive())
        DestroyZoneLimitedItem(true, newZone);

    // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
    AutoUnequipOffhandIfNeed();

    // recent client version not send leave/join channel packets for built-in local channels
    UpdateLocalChannels(newZone);

    UpdateZoneDependentAuras(newZone);

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
}

//If players are too far away from the duel flag... they lose the duel
void Player::CheckDuelDistance(time_t currTime)
{
    if (!m_Duel)
        return;

    uint64 duelFlagGUID = GetGuidValue(PLAYER_FIELD_DUEL_ARBITER);
    GameObject* obj = GetMap()->GetGameObject(duelFlagGUID);
    if (!obj)
        return;

    if (m_Duel->outOfBound == 0)
    {
        if (!IsWithinDistInMap(obj, 100))
        {
            m_Duel->outOfBound = currTime;

            WorldPacket data(SMSG_DUEL_OUT_OF_BOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
    }
    else
    {
        if (IsWithinDistInMap(obj, 80))
        {
            m_Duel->outOfBound = 0;

            WorldPacket data(SMSG_DUEL_INBOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
        else if (currTime >= (m_Duel->outOfBound+10))
            DuelComplete(DUEL_FLED);
    }
}

bool Player::IsOutdoorPvPActive()
{
    return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
}

void Player::DuelComplete(DuelCompleteType p_DuelType)
{
    // duel not requested
    if (!m_Duel)
        return;

    // Say "duel has been canceled"
    if (p_DuelType == DUEL_INTERRUPTED)
    {
        WorldPacket l_Data(SMSG_DUEL_COMPLETE, (1));
        l_Data.WriteBit(m_Duel->started);       ///< Started
        l_Data.FlushBits();
        GetSession()->SendPacket(&l_Data);

        if (m_Duel->opponent->GetSession())
            m_Duel->opponent->GetSession()->SendPacket(&l_Data);
    }


    if (p_DuelType != DUEL_INTERRUPTED)
    {
        /// Opponent is always the winner ...
        std::string l_BeatenName = GetName();
        std::string l_WinnerName = m_Duel->opponent->GetName();

        WorldPacket l_Data(SMSG_DUEL_WINNER);
        l_Data.WriteBits(l_WinnerName.size(), 6);               ///< WinnerName Size
        l_Data.WriteBits(l_BeatenName.size(), 6);               ///< BeatenName Size
        l_Data.WriteBit(p_DuelType == DUEL_WON ? 0 : 1);        ///< Fled
        l_Data << uint32(g_RealmID);                            ///< WinnerVirtualRealmAddress
        l_Data << uint32(g_RealmID);                            ///< BeatenVirtualRealmAddress
        l_Data.WriteString(l_WinnerName);                       ///< WinnerName
        l_Data.WriteString(l_BeatenName);                       ///< BeatenName

        SendMessageToSet(&l_Data, true);
    }

    sScriptMgr->OnPlayerDuelEnd(m_Duel->opponent, this, p_DuelType);

    if (sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
        RemoveAllSpellCooldown();
        if (m_Duel->opponent != nullptr)
            m_Duel->opponent->RemoveAllSpellCooldown();
    }

    switch (p_DuelType)
    {
        case DUEL_FLED:
            // if initiator and opponent are on the same team
            // or initiator and opponent are not PvP enabled, forcibly stop attacking
            if (m_Duel->initiator->GetTeam() == m_Duel->opponent->GetTeam())
            {
                m_Duel->initiator->AttackStop();
                m_Duel->opponent->AttackStop();
            }
            else
            {
                if (!m_Duel->initiator->IsPvP())
                    m_Duel->initiator->AttackStop();
                if (!m_Duel->opponent->IsPvP())
                    m_Duel->opponent->AttackStop();
            }
            break;
        case DUEL_WON:
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOSE_DUEL, 1);
            if (m_Duel->opponent)
            {
                 m_Duel->opponent->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_DUEL, 1);

                //Credit for quest Death's Challenge
                if (getClass() == CLASS_DEATH_KNIGHT && m_Duel->opponent->GetQuestStatus(12733) == QUEST_STATUS_INCOMPLETE)
                    m_Duel->opponent->CastSpell(m_Duel->opponent, 52994, true);
            }
            break;
        default:
            break;
    }

    // Victory emote spell
    if (p_DuelType != DUEL_INTERRUPTED && m_Duel->opponent)
        m_Duel->opponent->CastSpell(m_Duel->opponent, 52852, true);

    //Remove Duel Flag object
    GameObject* obj = GetMap()->GetGameObject(GetGuidValue(PLAYER_FIELD_DUEL_ARBITER));
    if (obj)
        m_Duel->initiator->RemoveGameObject(obj, true);

    /* remove auras */
    AuraApplicationMap &itsAuras = m_Duel->opponent->GetAppliedAuras();
    for (AuraApplicationMap::iterator i = itsAuras.begin(); i != itsAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && aura->GetCasterGUID() == GetGUID() && aura->GetApplyTime() >= m_Duel->startTime && !i->second->GetRemoveMode())
            m_Duel->opponent->RemoveAura(i);
        else
            ++i;
    }

    AuraApplicationMap &myAuras = GetAppliedAuras();
    for (AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && m_Duel->opponent != nullptr && aura->GetCasterGUID() == m_Duel->opponent->GetGUID() && aura->GetApplyTime() >= m_Duel->startTime && !i->second->GetRemoveMode())
            RemoveAura(i);
        else
            ++i;
    }

    // cleanup combo points
    ClearComboPoints();
    m_Duel->opponent->ClearComboPoints();

    SendClearLossOfControl();
    m_Duel->opponent->SendClearLossOfControl();

    // Honor points after duel (the winner) - ImpConfig
    if (uint32 amount = sWorld->getIntConfig(CONFIG_HONOR_AFTER_DUEL))
        m_Duel->opponent->RewardHonor(NULL, 1, amount);

    //cleanups
    SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);
    m_Duel->opponent->SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
    m_Duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    delete m_Duel->opponent->m_Duel;
    m_Duel->opponent->m_Duel = NULL;
    delete m_Duel;
    m_Duel = NULL;
}

//---------------------------------------------------------//
void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();

    if (!proto)
        return;

    // not apply/remove mods for broken item
    if (item->CantBeUse())
        return;

    sLog->outInfo(LOG_FILTER_PLAYER_ITEMS, "applying mods for item %u ", item->GetGUIDLow());

    uint8 attacktype = Player::GetAttackBySlot(slot);

    if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
        CorrectMetaGemEnchants(slot, apply);

    if (attacktype < WeaponAttackType::MaxAttack)
        _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);

    _ApplyItemBonuses(item, slot, apply);
    ApplyItemEquipSpell(item, apply);
    ApplyEnchantment(item, apply);
    _ApplyItemModifications(item, slot, apply);
}

void Player::_ApplyItemModifications(Item const* p_Item, uint8 p_Slot, bool p_Apply, uint32 p_RescaleToItemLevel)
{
    if (p_Slot >= INVENTORY_SLOT_BAG_END || !p_Item)
        return;

    ItemTemplate const* l_Proto = p_Item->GetTemplate();
    if (!l_Proto)
        return;

    if (!p_Item->GetAllItemBonuses().size())
        return;

     for (auto& l_ItemBonusList : p_Item->GetAllItemBonuses())
     {
        if (!l_ItemBonusList)
            continue;

        std::vector<ItemBonusEntry const*> const* l_BonusList = GetItemBonusesByID(l_ItemBonusList);
        for (uint32 i = 0; i < l_BonusList->size(); i++)
        {
            ItemBonusEntry const* l_ItemBonus = (*l_BonusList)[i];

            if (!l_ItemBonus)
                continue;

            _ApplyItemModification(p_Item, l_ItemBonus, p_Slot, p_Apply, p_RescaleToItemLevel);
        }
     }
}

void Player::_ApplyItemModification(Item const* p_Item, ItemBonusEntry const* p_ItemBonusEntry, uint8 p_Slot, bool p_Apply, uint32 p_RescaleToItemLevel)
{
    if (p_Slot >= INVENTORY_SLOT_BAG_END || !p_Item)
        return;

    ItemTemplate const* l_Proto = p_Item->GetTemplate();
    if (!l_Proto)
        return;

    uint32 ilvl = m_itemScale[p_Slot] ? m_itemScale[p_Slot] : GetEquipItemLevelFor(l_Proto, p_Item);

    if (ilvl == p_RescaleToItemLevel)
        return;

    switch (p_ItemBonusEntry->Type)
    {
        case ITEM_BONUS_ADD_STAT:
        {
            bool l_ApplyStats = p_RescaleToItemLevel < ilvl && p_RescaleToItemLevel ? !p_Apply : p_Apply;
            uint32 l_Stat = p_ItemBonusEntry->Value[0];
            int32 l_ScalingValue = p_ItemBonusEntry->Value[1];
            int32 l_StatValue = 0;

            if (!p_RescaleToItemLevel)
                l_StatValue = l_Proto->CalculateStatScaling(l_ScalingValue, 0.0f, ilvl);
            else
                l_StatValue = abs(int32(l_Proto->CalculateStatScaling(l_ScalingValue, 0.0f, p_RescaleToItemLevel) - l_Proto->CalculateStatScaling(l_ScalingValue, 0.0f, ilvl)));

            switch (l_Stat)
            {
                case ITEM_MOD_MANA:
                    HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_HEALTH:
                    HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_AGILITY:
                {
                    if (GetPrimaryStat() != STAT_AGILITY && GetSpecializationId())
                        break;

                    HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(STAT_AGILITY, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_STRENGTH:
                {
                    if (GetPrimaryStat() != STAT_STRENGTH && GetSpecializationId())
                        break;

                    HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(STAT_STRENGTH, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_INTELLECT:
                {
                    if (GetPrimaryStat() != STAT_INTELLECT && GetSpecializationId())
                        break;

                    HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(STAT_INTELLECT, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_SPIRIT:
                {
                    if (GetPrimaryStat() != STAT_INTELLECT && GetSpecializationId())
                        break;

                    HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(STAT_SPIRIT, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_STAMINA:
                    HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(STAT_STAMINA, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_DODGE_RATING:
                    ApplyRatingMod(CR_DODGE, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_PARRY_RATING:
                    ApplyRatingMod(CR_PARRY, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_BLOCK_RATING:
                    ApplyRatingMod(CR_BLOCK, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_CRIT_RATING:
                    ApplyRatingMod(CR_CRIT_MELEE, int32(l_StatValue), l_ApplyStats);
                    ApplyRatingMod(CR_CRIT_RANGED, int32(l_StatValue), l_ApplyStats);
                    ApplyRatingMod(CR_CRIT_SPELL, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_RESILIENCE_RATING:
                    ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_HASTE_RATING:
                    ApplyRatingMod(CR_HASTE_MELEE, int32(l_StatValue), l_ApplyStats);
                    ApplyRatingMod(CR_HASTE_RANGED, int32(l_StatValue), l_ApplyStats);
                    ApplyRatingMod(CR_HASTE_SPELL, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_ATTACK_POWER:
                    HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(l_StatValue), l_ApplyStats);
                    HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_VERSATILITY_RATING:
                    ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, int32(l_StatValue), l_ApplyStats);
                    ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_MANA_REGENERATION:
                    ApplyManaRegenBonus(int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_SPELL_POWER:
                    ApplySpellPowerBonus(int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_HEALTH_REGEN:
                    ApplyHealthRegenBonus(int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_MASTERY_RATING:
                    ApplyRatingMod(CR_MASTERY, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_EXTRA_ARMOR:
                    HandleStatModifier(UNIT_MOD_BONUS_ARMOR, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    UpdateArmor();
                    break;
                case ITEM_MOD_FIRE_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_FROST_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_HOLY_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_SHADOW_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_NATURE_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_ARCANE_RESISTANCE:
                    HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_PVP_POWER:
                    ApplyRatingMod(CR_PVP_POWER, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_MULTISTRIKE_RATING:
                    ApplyRatingMod(CR_MULTISTRIKE, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_SPEED_RATING:
                    ApplyRatingMod(CR_SPEED, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_LEECH_RATING:
                    ApplyRatingMod(CR_LIFESTEAL, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_AVOIDANCE_RATING:
                    ApplyRatingMod(CR_AVOIDANCE, int32(l_StatValue), l_ApplyStats);
                    break;
                case ITEM_MOD_DYNAMIC_STAT_AGI_STR_INT:
                {
                    Stats stat = GetPrimaryStat();
                    HandleStatModifier((UnitMods)stat, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(stat, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_DYNAMIC_STAT_AGI_STR:
                {
                    Stats stat = GetPrimaryStat();
                    if (stat != STAT_AGILITY && stat != STAT_STRENGTH)
                        break;

                    HandleStatModifier((UnitMods)stat, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(stat, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_DYNAMIC_STAT_AGI_INT:
                {
                    Stats stat = GetPrimaryStat();
                    if (stat != STAT_AGILITY && stat != STAT_INTELLECT)
                        break;

                    HandleStatModifier((UnitMods)stat, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(stat, float(l_StatValue), l_ApplyStats);
                    break;
                }
                case ITEM_MOD_DYNAMIC_STAT_STR_INT:
                {
                    Stats stat = GetPrimaryStat();
                    if (stat != STAT_INTELLECT && stat != STAT_STRENGTH)
                        break;

                    HandleStatModifier((UnitMods)stat, BASE_VALUE, float(l_StatValue), l_ApplyStats);
                    ApplyStatBuffMod(stat, float(l_StatValue), l_ApplyStats);
                    break;
                }
            }
        }
    }
}

void Player::_ApplyItemBonuses(Item const* item, uint8 slot, bool apply, uint32 rescaleToItemLevel)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    if (!m_itemScale[slot] && apply)
        m_itemScale[slot] = GetEquipItemLevelFor(proto, item);

    uint32 ilvl = m_itemScale[slot];

    if (!apply && !rescaleToItemLevel)
        m_itemScale[slot] = 0;

    if (ilvl == rescaleToItemLevel)
        return;

    bool applyStats = rescaleToItemLevel < ilvl && rescaleToItemLevel ? !apply : apply;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
    {
        uint32 statType;
        int32 val;

        if (!rescaleToItemLevel)
        {
            statType = proto->ItemStat[i].ItemStatType;
            val = (ilvl == 1 && rescaleToItemLevel == 0) ? proto->ItemStat[i].ItemStatValue : proto->CalculateStatScaling(i, ilvl);
        }
        else
        {
            statType = proto->ItemStat[i].ItemStatType;
            val = abs(int32(proto->CalculateStatScaling(i, rescaleToItemLevel) - proto->CalculateStatScaling(i, ilvl)));

            if (proto->ItemStat[i].ItemStatValue < 0)
                val = -val;
        }

        if (val == 0)
            continue;

        switch (statType)
        {
            case ITEM_MOD_MANA:
                HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_HEALTH:
                HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_AGILITY:
            {
                if (GetPrimaryStat() != STAT_AGILITY && GetSpecializationId())
                    break;

                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(STAT_AGILITY, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_AGILITY, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            }
            case ITEM_MOD_STRENGTH:
            {
                if (GetPrimaryStat() != STAT_STRENGTH && GetSpecializationId())
                    break;

                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(STAT_STRENGTH, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            }
            case ITEM_MOD_INTELLECT:
            {
                if (GetPrimaryStat() != STAT_INTELLECT && GetSpecializationId())
                    break;

                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(STAT_INTELLECT, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            }
            case ITEM_MOD_SPIRIT:
            {
                if (GetPrimaryStat() != STAT_INTELLECT && GetSpecializationId())
                    break;

                HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(STAT_SPIRIT, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            }
            case ITEM_MOD_STAMINA:
                HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(STAT_STAMINA, CalculatePct(val, GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT_EXCLUDE_CREATE)), apply);
                break;
            case ITEM_MOD_DODGE_RATING:
                ApplyRatingMod(CR_DODGE, int32(val), applyStats);
                break;
            case ITEM_MOD_PARRY_RATING:
                ApplyRatingMod(CR_PARRY, int32(val), applyStats);
                break;
            case ITEM_MOD_BLOCK_RATING:
                ApplyRatingMod(CR_BLOCK, int32(val), applyStats);
                break;
            case ITEM_MOD_CRIT_RATING:
                ApplyRatingMod(CR_CRIT_MELEE, int32(val), applyStats);
                ApplyRatingMod(CR_CRIT_RANGED, int32(val), applyStats);
                ApplyRatingMod(CR_CRIT_SPELL, int32(val), applyStats);
                break;
            case ITEM_MOD_RESILIENCE_RATING:
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val), applyStats);
                break;
            case ITEM_MOD_HASTE_RATING:
                ApplyRatingMod(CR_HASTE_MELEE, int32(val), applyStats);
                ApplyRatingMod(CR_HASTE_RANGED, int32(val), applyStats);
                ApplyRatingMod(CR_HASTE_SPELL, int32(val), applyStats);
                break;
            case ITEM_MOD_ATTACK_POWER:
                HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), applyStats);
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_VERSATILITY_RATING:
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, int32(val), applyStats);
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, int32(val), applyStats);
                break;
            case ITEM_MOD_MANA_REGENERATION:
                ApplyManaRegenBonus(int32(val), applyStats);
                break;
            case ITEM_MOD_SPELL_POWER:
                ApplySpellPowerBonus(int32(val), applyStats);
                break;
            case ITEM_MOD_HEALTH_REGEN:
                ApplyHealthRegenBonus(int32(val), applyStats);
                break;
            case ITEM_MOD_MASTERY_RATING:
                ApplyRatingMod(CR_MASTERY, int32(val), applyStats);
                break;
            case ITEM_MOD_EXTRA_ARMOR:
                HandleStatModifier(UNIT_MOD_BONUS_ARMOR, BASE_VALUE, float(val), applyStats);
                UpdateArmor();
                break;
            case ITEM_MOD_FIRE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_FROST_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_HOLY_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_SHADOW_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_NATURE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_ARCANE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(val), applyStats);
                break;
            case ITEM_MOD_PVP_POWER:
                ApplyRatingMod(CR_PVP_POWER, int32(val), applyStats);
                break;
            case ITEM_MOD_MULTISTRIKE_RATING:
                ApplyRatingMod(CR_MULTISTRIKE, int32(val), applyStats);
                break;
            case ITEM_MOD_SPEED_RATING:
                ApplyRatingMod(CR_SPEED, int32(val), applyStats);
                break;
            case ITEM_MOD_LEECH_RATING:
                ApplyRatingMod(CR_LIFESTEAL, int32(val), applyStats);
                break;
            case ITEM_MOD_AVOIDANCE_RATING:
                ApplyRatingMod(CR_AVOIDANCE, int32(val), applyStats);
                break;
            case ITEM_MOD_DYNAMIC_STAT_AGI_STR_INT:
            {
                Stats stat = GetPrimaryStat();
                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(stat, float(val), applyStats);
                break;
            }
            case ITEM_MOD_DYNAMIC_STAT_AGI_STR:
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_AGILITY && stat != STAT_STRENGTH)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(stat, float(val), applyStats);
                break;
            }
            case ITEM_MOD_DYNAMIC_STAT_AGI_INT:
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_AGILITY && stat != STAT_INTELLECT)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(stat, float(val), applyStats);
                break;
            }
            case ITEM_MOD_DYNAMIC_STAT_STR_INT:
            {
                Stats stat = GetPrimaryStat();
                if (stat != STAT_INTELLECT && stat != STAT_STRENGTH)
                    break;

                HandleStatModifier((UnitMods)stat, BASE_VALUE, float(val), applyStats);
                ApplyStatBuffMod(stat, float(val), applyStats);
                break;
            }
        }
    }

    uint32 armor = proto->CalculateArmorScaling(ilvl);
    if (rescaleToItemLevel)
        armor = abs(int32(proto->CalculateArmorScaling(ilvl) - proto->CalculateArmorScaling(rescaleToItemLevel)));

    if (armor)
    {
        UnitModifierType modType = TOTAL_VALUE;
        if (proto->Class == ITEM_CLASS_ARMOR)
        {
            switch (proto->SubClass)
            {
                case ITEM_SUBCLASS_ARMOR_CLOTH:
                case ITEM_SUBCLASS_ARMOR_LEATHER:
                case ITEM_SUBCLASS_ARMOR_MAIL:
                case ITEM_SUBCLASS_ARMOR_PLATE:
                case ITEM_SUBCLASS_ARMOR_SHIELD:
                    modType = BASE_VALUE;
                break;
            }
        }
        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), applyStats);
    }

    if (!proto->IsWeapon())
        return;

    WeaponAttackType attType = WeaponAttackType::BaseAttack;

    if (slot == EQUIPMENT_SLOT_MAINHAND && (
        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
        proto->InventoryType == INVTYPE_RANGEDRIGHT))
    {
        attType = WeaponAttackType::RangedAttack;
    }
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = WeaponAttackType::OffAttack;

    uint32 minDamage = 0;
    uint32 maxDamage = 0;

    if (apply)
        proto->CalculateMinMaxDamageScaling(rescaleToItemLevel ? rescaleToItemLevel : ilvl, minDamage, maxDamage);

    if (CanUseAttackType(attType))
        _ApplyWeaponDamage(slot, item, apply, minDamage, maxDamage);

    // Dual Wield penalty
    if (CanModifyStats())
    {
        if (attType == WeaponAttackType::OffAttack)
            UpdateDamagePhysical(WeaponAttackType::BaseAttack, !apply);
        else if (attType == WeaponAttackType::BaseAttack && CanUseAttackType(WeaponAttackType::OffAttack))
            UpdateDamagePhysical(WeaponAttackType::OffAttack, !apply);
    }
}

void Player::_ApplyWeaponDamage(uint8 slot, Item const* item, bool apply, uint32 minDamage, uint32 maxDamage)
{
    ItemTemplate const* proto = item->GetTemplate();
    WeaponAttackType attType = WeaponAttackType::BaseAttack;

    if (slot == EQUIPMENT_SLOT_MAINHAND && (
        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
        proto->InventoryType == INVTYPE_RANGEDRIGHT))
    {
        attType = WeaponAttackType::RangedAttack;
    }
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
    {
        attType = WeaponAttackType::OffAttack;
    }

    if (!maxDamage && apply)
        proto->CalculateMinMaxDamageScaling(GetEquipItemLevelFor(proto, item), minDamage, maxDamage);

    if (!minDamage && maxDamage && apply)
        minDamage = maxDamage;

    float damage = apply ? minDamage : 0;
    SetBaseWeaponDamage(attType, MINDAMAGE, damage);
    damage = apply ? maxDamage : 0;
    SetBaseWeaponDamage(attType, MAXDAMAGE, damage);

    if (proto->Delay && !IsInFeralForm())
    {
        if (slot == EQUIPMENT_SLOT_MAINHAND && (
        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
        proto->InventoryType == INVTYPE_RANGEDRIGHT))
            SetAttackTime(WeaponAttackType::RangedAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_MAINHAND)
            SetAttackTime(WeaponAttackType::BaseAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_OFFHAND)
            SetAttackTime(WeaponAttackType::OffAttack, apply ? proto->Delay: BASE_ATTACK_TIME);
    }

    if (CanModifyStats())
        UpdateDamagePhysical(attType);
}

void Player::_ApplyWeaponDependentAuraMods(Item* item, WeaponAttackType attackType, bool apply)
{
    AuraEffectList const& auraCritList = GetAuraEffectsByType(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
    for (AuraEffectList::const_iterator itr = auraCritList.begin(); itr != auraCritList.end(); ++itr)
        _ApplyWeaponDependentAuraCritMod(item, attackType, *itr, apply);

    AuraEffectList const& auraDamageFlatList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
    for (AuraEffectList::const_iterator itr = auraDamageFlatList.begin(); itr != auraDamageFlatList.end(); ++itr)
        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);

    AuraEffectList const& auraDamagePctList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
    for (AuraEffectList::const_iterator itr = auraDamagePctList.begin(); itr != auraDamagePctList.end(); ++itr)
        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);

    _ApplyWeaponDependentAuraSpellModifier(item, attackType, apply);
}

void Player::_ApplyWeaponDependentAuraCritMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->CantBeUse() || !CanUseAttackType(attackType))
        return;

    // generic not weapon specific case processes in aura code
    if (aura->GetSpellInfo()->EquippedItemClass == -1)
        return;

    BaseModGroup mod = BASEMOD_END;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   mod = CRIT_PERCENTAGE;        break;
        case WeaponAttackType::OffAttack:    mod = OFFHAND_CRIT_PERCENTAGE;break;
        case WeaponAttackType::RangedAttack: mod = RANGED_CRIT_PERCENTAGE; break;
        default: return;
    }

    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
        HandleBaseModValue(mod, FLAT_MOD, float (aura->GetAmount()), apply);
}

void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->CantBeUse() || !CanUseAttackType(attackType))
        return;

    // ignore spell mods for not wands
    if ((aura->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) == 0 && (getClassMask() & CLASSMASK_WAND_USERS) == 0)
        return;

    // generic not weapon specific case processes in aura code
    if (aura->GetSpellInfo()->EquippedItemClass == -1)
        return;

    UnitMods unitMod = UNIT_MOD_END;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
        case WeaponAttackType::OffAttack:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
        case WeaponAttackType::RangedAttack: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
        default: return;
    }

    UnitModifierType unitModType = TOTAL_VALUE;
    switch (aura->GetAuraType())
    {
        case SPELL_AURA_MOD_DAMAGE_DONE:         unitModType = TOTAL_VALUE; break;
        case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE: unitModType = TOTAL_PCT;   break;
        default: return;
    }

    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
    {
        HandleStatModifier(unitMod, unitModType, float(aura->GetAmount()), apply);
        if (unitModType == TOTAL_VALUE)
            ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS, aura->GetAmount(), apply);
    }
}

void Player::_ApplyWeaponDependentAuraSpellModifier(Item* item, WeaponAttackType attackType, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->CantBeUse() || !CanUseAttackType(attackType))
        return;

    switch (getClass())
    {
        case CLASS_DEATH_KNIGHT:
        {
            switch (GetSpecializationId())
            {
                case SPEC_DK_FROST:
                    if (getLevel() < 74)
                        break;

                    if (apply)
                    {
                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
                        {
                            CastSpell(this, 81333, true);
                            RemoveAura(66192);
                        }
                        else if (item->GetTemplate()->InventoryType == INVTYPE_WEAPON)
                        {
                            if ((attackType == WeaponAttackType::BaseAttack && GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND)) ||
                                (attackType == WeaponAttackType::OffAttack && GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND)))
                            {
                                CastSpell(this, 66192, true);
                                RemoveAura(81333);
                            }
                        }
                    }
                    else
                    {
                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
                            RemoveAura(81333);
                        else if (item->GetTemplate()->InventoryType == INVTYPE_WEAPON)
                        {
                            if ((attackType == WeaponAttackType::BaseAttack && GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND)) ||
                                (attackType == WeaponAttackType::OffAttack && GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND)))
                                RemoveAura(66192);
                        }
                    }
                    break;
                default:
                    break;
            }

            break;
        }
        default:
            break;
    }
}

void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
{
    if (!item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = proto->Spells[i];

        // no spell
        if (!spellData.SpellId)
            continue;

        // wrong triggering type
        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
            continue;

        // check if it is valid spell
        SpellInfo const* spellproto = sSpellMgr->GetSpellInfo(spellData.SpellId);
        if (!spellproto)
            continue;

        // Item doesn't need to be equipped
        if (spellData.SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && spellproto->HasAura(SPELL_AURA_MOD_SKILL_VALUE))
            continue;

        ApplyEquipSpell(spellproto, item, apply, form_change);
    }
}

void Player::ApplyEquipSpell(SpellInfo const* spellInfo, Item* item, bool apply, bool form_change)
{
    if (apply)
    {
        // Cannot be used in this stance/form
        if (spellInfo->CheckShapeshift(GetShapeshiftForm()) != SPELL_CAST_OK)
            return;

        if (form_change)                                    // check aura active state from other form
        {
            AuraApplicationMap const& auras = GetAppliedAuras();
            for (AuraApplicationMap::const_iterator itr = auras.lower_bound(spellInfo->Id); itr != auras.upper_bound(spellInfo->Id); ++itr)
                if (!item || itr->second->GetBase()->GetCastItemGUID() == item->GetGUID())
                    return;
        }

        sLog->outDebug(LOG_FILTER_PLAYER, "WORLD: cast %s Equip spellId - %i", (item ? "item" : "itemset"), spellInfo->Id);

        CastSpell(this, spellInfo, true, item);
    }
    else
    {
        if (form_change)                                     // check aura compatibility
        {
            // Cannot be used in this stance/form
            if (spellInfo->CheckShapeshift(GetShapeshiftForm()) == SPELL_CAST_OK)
                return;                                     // and remove only not compatible at form change
        }

        if (item)
            RemoveAurasDueToItemSpell(item, spellInfo->Id);  // un-apply all spells, not only at-equipped
        else
            RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
    }
}

void Player::UpdateEquipSpellsAtFormChange()
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] && !m_items[i]->CantBeUse() && CanUseAttackType(GetAttackBySlot(i)))
        {
            ApplyItemEquipSpell(m_items[i], false, true);     // remove spells that not fit to form
            ApplyItemEquipSpell(m_items[i], true, true);      // add spells that fit form but not active
        }
    }

    // item set bonuses not dependent from item broken state
    for (size_t setindex = 0; setindex < ItemSetEff.size(); ++setindex)
    {
        ItemSetEffect* eff = ItemSetEff[setindex];
        if (!eff)
            continue;

        for (uint32 y = 0; y < MAX_ITEM_SET_SPELLS; ++y)
        {
            SpellInfo const* spellInfo = eff->spells[y];
            if (!spellInfo)
                continue;

            ApplyEquipSpell(spellInfo, NULL, false, true);       // remove spells that not fit to form
            ApplyEquipSpell(spellInfo, NULL, true, true);        // add spells that fit form but not active
        }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
{
    if (!target || !target->isAlive() || target == this)
        return;

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // If usable, try to cast item spell
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (!item->CantBeUse() && CanUseAttackType(attType))
                if (ItemTemplate const* proto = item->GetTemplate())
                {
                    // Additional check for weapons
                    if (proto->Class == ITEM_CLASS_WEAPON)
                    {
                        // offhand item cannot proc from main hand hit etc
                        EquipmentSlots slot;
                        switch (attType)
                        {
                            case WeaponAttackType::BaseAttack:   slot = EQUIPMENT_SLOT_MAINHAND; break;
                            case WeaponAttackType::OffAttack:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
                            case WeaponAttackType::RangedAttack: slot = EQUIPMENT_SLOT_MAINHAND;   break;
                            default: slot = EQUIPMENT_SLOT_END; break;
                        }
                        if (slot != i)
                            continue;
                        // Check if item is useable (forms or disarm)
                        if (attType == WeaponAttackType::BaseAttack)
                            if (!IsUseEquipedWeapon(true) && !IsInFeralForm())
                                continue;
                    }
                    CastItemCombatSpell(target, attType, procVictim, procEx, item, proto);
                }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
{
    // Can do effect if any damage done to target
    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
    //if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
    {
        for (uint8 i = 0; i < MAX_ITEM_SPELLS; ++i)
        {
            _Spell const& spellData = proto->Spells[i];

            // no spell
            if (!spellData.SpellId)
                continue;

            // wrong triggering type
            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "WORLD: unknown Item spellid %i", spellData.SpellId);
                continue;
            }

            // not allow proc extra attack spell at extra attack
            if (m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
                return;

            float chance = (float)spellInfo->ProcChance;

            if (proto->SpellPPMRate)
            {
                if (spellData.SpellId == 52781) // Persuasive Strike
                {
                    switch (target->GetEntry())
                    {
                        default:
                            return;
                        case 28939:
                        case 28940:
                        case 28610:
                            break;
                    }
                }
                uint32 WeaponSpeed = GetAttackTime(attType);
                chance = GetPPMProcChance(WeaponSpeed, proto->SpellPPMRate, spellInfo);
            }
            else if (chance > 100.0f)
            {
                chance = GetWeaponProcChance();
            }

            if (roll_chance_f(chance))
                CastSpell(target, spellInfo->Id, true, item);
        }
    }

    // item combat enchantments
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        if (e_slot > ENGINEERING_ENCHANTMENT_SLOT && e_slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!pEnchant)
            continue;

        for (uint8 s = 0; s < MAX_ENCHANTMENT_SPELLS; ++s)
        {
            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
                continue;

            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);

            if (entry && entry->procEx)
            {
                // Check hit/crit/dodge/parry requirement
                if ((entry->procEx & procEx) == 0)
                    continue;
            }
            else
            {
                // Can do effect if any damage done to target
                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
                //if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
                    continue;
            }

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER_ITEMS, "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
                    GetGUIDLow(), GetName(), pEnchant->ID, pEnchant->spellid[s]);
                continue;
            }

            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : GetWeaponProcChance();

            if (entry)
            {
                if (entry->PPMChance)
                    chance = GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
                else if (entry->customChance)
                    chance = (float)entry->customChance;
            }

            // Apply spell mods
            ApplySpellMod(pEnchant->spellid[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);

            if (roll_chance_f(chance))
            {
                if (spellInfo->IsPositive())
                    CastSpell(this, spellInfo, true, item);
                else
                    CastSpell(target, spellInfo, true, item);
            }
        }
    }
}

void Player::CastItemUseSpell(Item* p_Item, SpellCastTargets const& p_Targets, uint8 p_CastCount, uint32 p_Misc, uint32 p_Misc2)
{
    ItemTemplate const* l_ItemTemplate = p_Item->GetTemplate();

    /// Special learning case
    if (l_ItemTemplate->Spells[0].SpellId == 483 || l_ItemTemplate->Spells[0].SpellId == 55884)
    {
        uint32 l_LearnedSpell   = l_ItemTemplate->Spells[0].SpellId;
        uint32 l_LearningSpell  = l_ItemTemplate->Spells[1].SpellId;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_LearnedSpell);
        if (!l_SpellInfo)
        {
            sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring ", l_ItemTemplate->ItemId, l_LearnedSpell);
            SendEquipError(InventoryResult::EQUIP_ERR_INTERNAL_BAG_ERROR, p_Item, nullptr);
            return;
        }

        Spell* l_Spell          = new Spell(this, l_SpellInfo, TriggerCastFlags::TRIGGERED_NONE);
        l_Spell->m_CastItem     = p_Item;
        l_Spell->m_cast_count   = p_CastCount;  ///< Set count of casts
        l_Spell->SetSpellValue(SpellValueMod::SPELLVALUE_BASE_POINT0, l_LearningSpell);
        l_Spell->m_Misc[0] = p_Misc;
        l_Spell->m_Misc[1] = p_Misc2;
        l_Spell->prepare(&p_Targets);
        return;
    }

    /// Use triggered flag only for items with many spell casts and for not first cast
    uint8 l_Count = 0;

    /// Item enchantments spells casted at use
    for (uint8 l_Slot = 0; l_Slot < EnchantmentSlot::MAX_ENCHANTMENT_SLOT; ++l_Slot)
    {
        if (l_Slot > EnchantmentSlot::ENGINEERING_ENCHANTMENT_SLOT && l_Slot < EnchantmentSlot::PROP_ENCHANTMENT_SLOT_0)    ///< Not holding enchantment id
            continue;

        uint32 l_EnchantID = p_Item->GetEnchantmentId(EnchantmentSlot(l_Slot));
        SpellItemEnchantmentEntry const* l_ItemEnchantEntry = sSpellItemEnchantmentStore.LookupEntry(l_EnchantID);
        if (!l_ItemEnchantEntry)
            continue;

        for (uint8 l_I = 0; l_I < MAX_ENCHANTMENT_SPELLS; ++l_I)
        {
            if (l_ItemEnchantEntry->type[l_I] != ItemEnchantmentType::ITEM_ENCHANTMENT_TYPE_USE_SPELL)
                continue;

            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_ItemEnchantEntry->spellid[l_I]);
            if (!l_SpellInfo)
            {
                sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell Enchant %i, cast unknown spell %i", l_ItemEnchantEntry->ID, l_ItemEnchantEntry->spellid[l_I]);
                continue;
            }

            Spell* l_Spell          = new Spell(this, l_SpellInfo, (l_Count > 0) ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE);
            l_Spell->m_CastItem     = p_Item;
            l_Spell->m_cast_count   = p_CastCount;  ///< Set count of casts
            l_Spell->m_Misc[0]      = p_Misc;
            l_Spell->m_Misc[1]      = p_Misc2;
            l_Spell->prepare(&p_Targets);

            ++l_Count;
        }
    }

    /// Item spells casted at use
    for (uint8 l_I = 0; l_I < MAX_ITEM_PROTO_SPELLS; ++l_I)
    {
        _Spell const& l_SpellData = l_ItemTemplate->Spells[l_I];

        /// No spell
        if (!l_SpellData.SpellId)
            continue;

        /// Wrong triggering type
        if (l_SpellData.SpellTrigger != ItemSpelltriggerType::ITEM_SPELLTRIGGER_ON_USE)
            continue;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellData.SpellId);
        if (!l_SpellInfo)
        {
            sLog->outError(LogFilterType::LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring", l_ItemTemplate->ItemId, l_SpellData.SpellId);
            continue;
        }

        Spell* l_Spell            = new Spell(this, l_SpellInfo, (l_Count > 0) ? TriggerCastFlags::TRIGGERED_FULL_MASK : TriggerCastFlags::TRIGGERED_NONE);
        l_Spell->m_CastItem       = p_Item;
        l_Spell->m_cast_count     = p_CastCount;    ///< set count of casts
        l_Spell->m_Misc[0]        = p_Misc;
        l_Spell->m_Misc[1]        = p_Misc2;
        l_Spell->prepare(&p_Targets);

        ++l_Count;
    }
}

void Player::_RemoveAllItemMods()
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                RemoveItemsSetItem(this, proto);

            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], false);
            ApplyEnchantment(m_items[i], false);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < WeaponAttackType::MaxAttack)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), false);

            _ApplyItemBonuses(m_items[i], i, false);
            _ApplyItemModifications(m_items[i], i, false);
        }
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods complete.");
}

void Player::_ApplyAllItemMods()
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < WeaponAttackType::MaxAttack)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), true);

            _ApplyItemBonuses(m_items[i], i, true);
            _ApplyItemModifications(m_items[i], i, true);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                AddItemsSetItem(this, m_items[i]);

            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], true);
            ApplyEnchantment(m_items[i], true);
        }
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods complete.");
}

/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
    Called by remove insignia spell effect    */
void Player::RemovedInsignia(Player* looterPlr)
{
    if (!GetBattlegroundId() && GetMapId() != 1191) ///< Specific handle for Ashran too
        return;

    // If not released spirit, do it !
    if (m_deathTimer > 0)
    {
        m_deathTimer = 0;
        BuildPlayerRepop();
        RepopAtGraveyard();
    }

    // We have to convert player corpse to bones, not to be able to resurrect there
    // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
    Corpse* bones = sObjectAccessor->ConvertCorpseForPlayer(GetGUID(), true);
    if (!bones)
        return;

    // Now we must make bones lootable, and send player loot
    bones->SetFlag(CORPSE_FIELD_DYNAMIC_FLAGS, CORPSE_DYNFLAG_LOOTABLE);

    // We store the level of our player in the gold field
    // We retrieve this information at Player::SendLoot()
    bones->loot.Gold = getLevel();
    bones->lootRecipient = looterPlr;
    looterPlr->SendLoot(bones->GetGUID(), LOOT_INSIGNIA);
}

void Player::SendLootRelease(uint64 p_LootGuid)
{
    uint64 l_LootObject = MAKE_NEW_GUID(GUID_LOPART(p_LootGuid), 0, HIGHGUID_LOOT);

    WorldPacket data(SMSG_LOOT_RELEASE);
    data.appendPackGUID(l_LootObject);
    data.appendPackGUID(p_LootGuid);

    SendDirectMessage(&data);
}

void Player::SendLoot(uint64 p_Guid, LootType p_LootType, bool p_FetchLoot, float p_Radius)
{
    if (uint64 l_Guid = GetLootGUID())
        m_session->DoLootRelease(l_Guid);

    uint64 l_PlayerGuid = GetGUID();
    Loot* l_Loot = 0;
    PermissionTypes l_Permission = ALL_PERMISSION;

    if (IS_GAMEOBJECT_GUID(p_Guid))
    {
        GameObject* l_GameObject = GetMap()->GetGameObject(p_Guid);

        /// Not check distance for GO in case owned GO (fishing bobber case, for example)
        /// And permit out of range GO with no owner in case fishing hole
        if (!l_GameObject || (p_LootType != LOOT_FISHINGHOLE && (p_LootType != LOOT_FISHING || l_GameObject->GetOwnerGUID() != l_PlayerGuid)
            && !l_GameObject->IsWithinDistInMap(this, INTERACTION_DISTANCE)) || (p_LootType == LOOT_CORPSE && l_GameObject->GetRespawnTime() && l_GameObject->isSpawnedByDefault()))
        {
            SendLootRelease(p_Guid);
            return;
        }

        /// If gameobject is quest tracked and player already have it, player can't loot (cheat ?)
        uint32 l_TrackingQuest = l_GameObject->GetGOInfo()->GetTrackingQuestId();
        uint32 l_QuestBit      = GetQuestUniqueBitFlag(l_TrackingQuest);

        if (l_TrackingQuest && IsQuestBitFlaged(l_QuestBit))
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Loot = &l_GameObject->loot;

        if (l_GameObject->getLootState() == GO_READY)
        {
            uint32 l_LootID = l_GameObject->GetGOInfo()->GetLootId();

            /// TODO: fix this big hack
            if ((l_GameObject->GetEntry() == BG_AV_OBJECTID_MINE_N || l_GameObject->GetEntry() == BG_AV_OBJECTID_MINE_S))
            {
                if (Battleground* l_Battleground = GetBattleground())
                {
                    if (l_Battleground->GetTypeID(true) == BATTLEGROUND_AV)
                    {
                        if (!(((BattlegroundAV*)l_Battleground)->PlayerCanDoMineQuest(l_GameObject->GetEntry(), GetTeam())))
                        {
                            SendLootRelease(p_Guid);
                            return;
                        }
                    }
                }
            }

            if (l_LootID)
            {
                l_Loot->clear();

                Group* l_Group = GetGroup();
                bool l_GroupRules = (l_Group && l_GameObject->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && l_GameObject->GetGOInfo()->chest.usegrouplootrules);

                /// Check current RR player and get next if necessary
                if (l_GroupRules)
                    l_Group->UpdateLooterGuid(l_GameObject, true);

                l_Loot->FillLoot(l_LootID, LootTemplates_Gameobject, this, !l_GroupRules, false, l_GameObject->GetLootMode());

                /// Get next RR player (for next loot)
                if (l_GroupRules)
                    l_Group->UpdateLooterGuid(l_GameObject);
            }

            if (p_LootType == LOOT_FISHING)
                l_GameObject->getFishLoot(l_Loot, this);

            if (l_GameObject->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && l_GameObject->GetGOInfo()->chest.usegrouplootrules)
            {
                if (Group* l_Group = GetGroup())
                {
                    switch (l_Group->GetLootMethod())
                    {
                        case GROUP_LOOT:
                            /// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                            l_Group->GroupLoot(l_Loot, l_GameObject);
                            break;
                        case NEED_BEFORE_GREED:
                            l_Group->NeedBeforeGreed(l_Loot, l_GameObject);
                            break;
                        case MASTER_LOOT:
                            l_Group->MasterLoot(l_Loot, l_GameObject);
                            break;
                        default:
                            break;
                    }
                }
            }

            l_GameObject->SetLootState(GO_ACTIVATED, this);
        }

        if (l_GameObject->getLootState() == GO_ACTIVATED)
        {
            if (Group* l_Group = GetGroup())
            {
                switch (l_Group->GetLootMethod())
                {
                    case MASTER_LOOT:
                        l_Permission = MASTER_PERMISSION;
                        break;
                    case FREE_FOR_ALL:
                        l_Permission = ALL_PERMISSION;
                        break;
                    case ROUND_ROBIN:
                        l_Permission = ROUND_ROBIN_PERMISSION;
                        break;
                    default:
                        l_Permission = GROUP_PERMISSION;
                        break;
                }
            }
            else
                l_Permission = ALL_PERMISSION;
        }
    }
    else if (IS_ITEM_GUID(p_Guid))
    {
        Item* l_Item = GetItemByGuid(p_Guid);
        if (!l_Item)
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Permission = OWNER_PERMISSION;

        l_Loot = &l_Item->loot;

        if (!l_Item->m_lootGenerated)
        {
            l_Item->m_lootGenerated = true;
            l_Loot->clear();

            switch (p_LootType)
            {
                case LOOT_DISENCHANTING:
                    l_Loot->FillLoot(l_Item->GetTemplate()->DisenchantID, LootTemplates_Disenchant, this, true);
                    break;
                case LOOT_PROSPECTING:
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Prospecting, this, true);
                    break;
                case LOOT_MILLING:
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Milling, this, true);
                    break;
                default:
                    l_Loot->generateMoneyLoot(l_Item->GetTemplate()->MinMoneyLoot, l_Item->GetTemplate()->MaxMoneyLoot);
                    l_Loot->FillLoot(l_Item->GetEntry(), LootTemplates_Item, this, true, l_Loot->Gold != 0);
                    break;
            }
        }
    }
    /// Remove insignia
    else if (IS_CORPSE_GUID(p_Guid))
    {
        Corpse* l_Corpse = ObjectAccessor::GetCorpse(*this, p_Guid);
        if (!l_Corpse || !(p_LootType == LOOT_CORPSE || p_LootType == LOOT_INSIGNIA) || l_Corpse->GetType() != CORPSE_BONES)
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Loot = &l_Corpse->loot;

        if (!l_Corpse->lootForBody)
        {
            l_Corpse->lootForBody = true;

            uint32 l_Gold = l_Corpse->loot.Gold;
            l_Corpse->loot.clear();

            if (Battleground* l_Battleground = GetBattleground())
            {
                if (l_Battleground->GetTypeID(true) == BATTLEGROUND_AV)
                    l_Loot->FillLoot(1, LootTemplates_Creature, this, true);
            }
            else if (OutdoorPvP* l_OutdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId()))
            {
                if (l_OutdoorPvP->GetTypeId() == OutdoorPvPTypes::OUTDOOR_PVP_ASHRAN)
                    l_OutdoorPvP->FillCustomPvPLoots(this, *l_Loot, l_Corpse->GetOwnerGUID());
            }

            /// It may need a better formula
            /// Now it works like this: lvl10: ~6copper, lvl70: ~9silver
            l_Corpse->loot.Gold = uint32(urand(50, 150) * 0.016f * pow(float(l_Gold) / 5.76f, 2.5f) * sWorld->getRate(RATE_DROP_MONEY));
        }

        if (l_Corpse->lootRecipient != this)
            l_Permission = NONE_PERMISSION;
        else
            l_Permission = OWNER_PERMISSION;
    }
    else
    {
        Creature* l_Creature = GetMap()->GetCreature(p_Guid);

        /// Must be in range and creature must be alive for pickpocket and must be dead for another loot
        if (!l_Creature || l_Creature->isAlive() != (p_LootType == LOOT_PICKPOCKETING) || (!l_Creature->IsWithinDistInMap(this, INTERACTION_DISTANCE) && !p_FetchLoot))
        {
            SendLootRelease(p_Guid);
            return;
        }

        if (p_LootType == LOOT_PICKPOCKETING && IsFriendlyTo(l_Creature))
        {
            SendLootRelease(p_Guid);
            return;
        }

        l_Loot = &l_Creature->loot;
        l_Loot->LinkedLoot.clear();

        if (p_LootType == LOOT_PICKPOCKETING)
        {
            if (!l_Creature->lootForPickPocketed)
            {
                l_Creature->lootForPickPocketed = true;
                l_Loot->clear();

                if (uint32 l_LootID = l_Creature->GetCreatureTemplate()->pickpocketLootId)
                    l_Loot->FillLoot(l_LootID, LootTemplates_Pickpocketing, this, true);

                /// Generate extra money for pick pocket loot
                uint32 const l_A = urand(0, l_Creature->getLevel() / 2);
                uint32 const l_B = urand(0, getLevel() / 2);
                l_Loot->Gold = uint32(10 * (l_A + l_B) * sWorld->getRate(RATE_DROP_MONEY));
                l_Permission = OWNER_PERMISSION;
            }
        }
        else
        {
            /// Check all creature around, to see if we can loot it too
            std::list<Creature*> l_LinkedCreatures;
            l_LinkedCreatures.push_back(l_Creature);

            if (p_LootType == LOOT_CORPSE)
            {
                CellCoord l_CellCoord(JadeCore::ComputeCellCoord(GetPositionX(), GetPositionY()));
                Cell l_Cell(l_CellCoord);
                l_Cell.SetNoCreate();

                JadeCore::AllDeadCreaturesInRange l_Check(this, p_Radius, l_Creature->GetGUID());
                JadeCore::CreatureListSearcher<JadeCore::AllDeadCreaturesInRange> l_Searcher(this, l_LinkedCreatures, l_Check);
                TypeContainerVisitor<JadeCore::CreatureListSearcher<JadeCore::AllDeadCreaturesInRange>, GridTypeMapContainer> l_CellSearcher(l_Searcher);
                l_Cell.Visit(l_CellCoord, l_CellSearcher, *(GetMap()), *this, p_Radius);
            }

            uint32 l_MaxSlots = l_Loot->Items.size() + l_Loot->QuestItems.size();
            l_Loot->AdditionalLinkedGold = 0;
            for (Creature* l_LinkedCreature : l_LinkedCreatures)
            {
                /// The player whose group may loot the corpse
                Player* l_Recipient = l_LinkedCreature->GetLootRecipient();
                if (!l_Recipient)
                {
                    if (l_Creature != l_LinkedCreature)
                        continue;

                    return;
                }

                Loot* l_LinkedLoot = &l_LinkedCreature->loot;
                if (!l_LinkedCreature->lootForBody)
                {
                    l_LinkedCreature->lootForBody = true;

                    /// For creature, loot is filled when creature is killed.
                    if (Group* l_Group = l_Recipient->GetGroup())
                    {
                        switch (l_Group->GetLootMethod())
                        {
                            case GROUP_LOOT:
                                /// GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                                l_Group->GroupLoot(l_LinkedLoot, l_LinkedCreature);
                                break;
                            case NEED_BEFORE_GREED:
                                l_Group->NeedBeforeGreed(l_LinkedLoot, l_LinkedCreature);
                                break;
                            case MASTER_LOOT:
                                l_Group->MasterLoot(l_LinkedLoot, l_LinkedCreature);
                                break;
                            default:
                                break;
                        }
                    }
                }

                PermissionTypes l_Perm = NONE_PERMISSION;

                /// TODO: handle this case with new radius loot system
                /// Possible only if creature->lootForBody && loot->empty() at spell cast check
                if (p_LootType == LOOT_SKINNING)
                {
                    l_LinkedLoot->clear();
                    l_LinkedLoot->FillLoot(l_LinkedCreature->GetCreatureTemplate()->SkinLootId, LootTemplates_Skinning, this, true);
                    l_Perm = OWNER_PERMISSION;
                }
                /// Set group rights only for loot_type != LOOT_SKINNING
                else
                {
                    if (Group* l_Group = GetGroup())
                    {
                        if (l_Group == l_Recipient->GetGroup())
                        {
                            switch (l_Group->GetLootMethod())
                            {
                                case MASTER_LOOT:
                                    l_Perm = MASTER_PERMISSION;
                                    break;
                                case FREE_FOR_ALL:
                                    l_Perm = ALL_PERMISSION;
                                    break;
                                case ROUND_ROBIN:
                                    l_Perm = ROUND_ROBIN_PERMISSION;
                                    break;
                                default:
                                    l_Perm = GROUP_PERMISSION;
                                    break;
                            }
                        }
                        else
                            l_Perm = NONE_PERMISSION;
                    }
                    else if (l_Recipient == this)
                        l_Perm = OWNER_PERMISSION;
                    else
                        l_Perm = NONE_PERMISSION;
                }

                if (l_LinkedCreature == l_Creature)
                    l_Permission = l_Perm;
                else
                {
                    if (l_Perm != NONE_PERMISSION)
                    {
                        l_LinkedLoot->AddLooter(l_PlayerGuid);
                        l_Loot->AdditionalLinkedGold += l_LinkedLoot->Gold;
                    }

                    for (uint32 l_I = 0; l_I < l_LinkedLoot->Items.size(); l_I++)
                        l_Loot->addLinkedLoot(l_MaxSlots++, l_LinkedCreature->GetGUID(), l_I, l_Perm);
                }
            }
        }
    }

    SetLootGUID(p_Guid);

    /// LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
    switch (p_LootType)
    {
        case LOOT_INSIGNIA:
            p_LootType = LOOT_SKINNING;
            break;
        case LOOT_FISHINGHOLE:
            p_LootType = LOOT_FISHING;
            break;
        default:
            break;
    }

    /// In WoD, more you have fishing skill more the fish is bigger
    if (p_LootType == LOOT_FISHING || p_LootType == LOOT_FISHINGHOLE)
    {
        uint32 l_SmallFishChance    = 100;
        uint32 l_MediumFishChance   = 0;
        uint32 l_BigFishChance      = 0;

        uint32 l_FishingSKill = GetSkillValue(SKILL_FISHING);

        /// http://www.wowhead.com/achievement=9462/draenor-angler#comments
        if (l_FishingSKill >= 100 && l_FishingSKill < 525)
        {
            l_SmallFishChance  = 80;
            l_MediumFishChance = 20;
        }
        else if (l_FishingSKill >= 525 && l_FishingSKill < 700)
        {
            l_SmallFishChance   = 10;
            l_MediumFishChance  = 50;
            l_BigFishChance     = 10;
        }
        else if (l_FishingSKill >= 650 && l_FishingSKill < 700)
        {
            l_SmallFishChance   = 0;
            l_MediumFishChance  = 50;
            l_BigFishChance     = 50;
        }
        else if (l_FishingSKill >= 700)
        {
            l_SmallFishChance   = 0;
            l_BigFishChance     = std::min((int32)100, (int32)(50 + ((50 / (950 - 700)) * (l_FishingSKill - 700))));
            l_MediumFishChance  = std::max((int32)0, (int32)(100 - l_BigFishChance));
        }

        enum class FishType
        {
            None,
            Small,
            Medium,
            Big
        };

        /// Fish with various size :
        /// -------------------------------------------
        /// - Crescent Saberfish
        /// - Blackwater Whiptail
        /// - Abyssal Gulper Eel
        /// - Sea Scorpion
        /// - Fire Ammonite
        /// - Blind Lake Sturgeon
        /// - Fat Sleeper
        /// - Jawless Skulker
        /// - Savage Piranha
        std::vector<uint32> l_SmallFish  { 111589, 111650, 111651, 111652, 111656, 111658, 111659, 111662, 118564 };
        std::vector<uint32> l_MediumFish { 111595, 111663, 111664, 111665, 111666, 111667, 111668, 111669, 118565 };
        std::vector<uint32> l_BigFish    { 111601, 111670, 111671, 111672, 111673, 111674, 111675, 111676, 118566 };

        auto GetFishType = [l_SmallFish, l_MediumFish, l_BigFish](uint32 p_ItemID) -> FishType
        {
            if (std::find(l_SmallFish.begin(), l_SmallFish.end(), p_ItemID) != l_SmallFish.end())
                return FishType::Small;
            if (std::find(l_MediumFish.begin(), l_MediumFish.end(), p_ItemID) != l_MediumFish.end())
                return FishType::Medium;
            if (std::find(l_BigFish.begin(), l_BigFish.end(), p_ItemID) != l_BigFish.end())
                return FishType::Big;

            return FishType::None;
        };

        std::vector<LootItem*> l_Fishs;

        for (uint32 l_I = 0; l_I < l_Loot->Items.size(); ++l_I)
        {
            LootItem* l_LootItem = &l_Loot->Items[l_I];
            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_LootItem->itemid);

            if (!l_ItemTemplate)
                return;

            if (l_ItemTemplate->SubClass != ITEM_SUBCLASS_MEAT)
                continue;

            if (GetFishType(l_LootItem->itemid) == FishType::None)
                continue;

#ifdef _MSC_VER
            char* l_Size[] = { "None", "Small", "Medium", "Big" };
            ChatHandler(this).PSendSysMessage("Loot find fish %s(%u) size %s", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDbcLocale()), l_LootItem->itemid, l_Size[(int)GetFishType(l_LootItem->itemid)]);
            ChatHandler(this).PSendSysMessage("Loot removed fish %s(%u)", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDbcLocale()), l_LootItem->itemid);
#endif
            l_Fishs.push_back(l_LootItem);
            l_LootItem->needs_quest = true;
        }

        if (l_Fishs.size())
        {
            for (LootItem* l_LootItem : l_Fishs)
            {
                bool l_RoolResult = false;
                switch (GetFishType(l_LootItem->itemid))
                {
                    case FishType::Small:
                        l_RoolResult = roll_chance_i(l_SmallFishChance);
                        break;
                    case FishType::Medium:
                        l_RoolResult = roll_chance_i(l_MediumFishChance);
                        break;
                    case FishType::Big:
                        l_RoolResult = roll_chance_i(l_BigFishChance);
                        break;
                    default:
                        break;
                }

                if (l_RoolResult)
                {
#ifdef _MSC_VER
                    ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_LootItem->itemid);
                    ChatHandler(this).PSendSysMessage("Loot added fish %s(%u)", l_ItemTemplate->Name1->Get(sWorld->GetDefaultDbcLocale()), l_LootItem->itemid);
#endif
                    l_LootItem->needs_quest = false;
                }
            }
        }
    }

    /// Need know merged fishing/corpse loot type for achievements
    l_Loot->Type = p_LootType;

    WorldPacket l_Data(SMSG_LOOT_RESPONSE, 4 * 1024);
    l_Data << LootView(*l_Loot, this, p_LootType, p_Guid, l_Permission);
    SendDirectMessage(&l_Data);

    /// Add 'this' player as one of the players that are looting 'loot'
    if (l_Permission != NONE_PERMISSION)
        l_Loot->AddLooter(l_PlayerGuid);

    if (p_LootType == LOOT_CORPSE && !IS_ITEM_GUID(p_Guid))
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
}

void Player::SendNotifyLootMoneyRemoved()
{
    ObjectGuid l_Guid = MAKE_NEW_GUID(GUID_LOPART(GetLootGUID()), 0, HIGHGUID_LOOT);

    sObjectMgr->setLootViewGUID(l_Guid, GetLootGUID());

    WorldPacket l_Data(SMSG_COIN_REMOVED);
    l_Data.appendPackGUID(l_Guid);
    GetSession()->SendPacket(&l_Data);
}

void Player::SendNotifyLootItemRemoved(uint8 p_LootSlot)
{
    ObjectGuid l_Guid       = GetLootGUID();
    ObjectGuid l_LootGuid   = MAKE_NEW_GUID(GUID_LOPART(l_Guid), 0, HIGHGUID_LOOT);

    WorldPacket l_Data(SMSG_LOOT_REMOVED);

    l_Data.appendPackGUID(l_Guid);
    l_Data.appendPackGUID(l_LootGuid);
    l_Data << uint8(p_LootSlot);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
{
    WorldPacket data(SMSG_UPDATE_WORLD_STATE, 4+4+1);
    data << Field;
    data << Value;
    data.WriteBit(0);
    data.FlushBits();
    GetSession()->SendPacket(&data);

    SetWorldState(Field, Value);
}

void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
{
    // data depends on zoneid/mapid...
    Battleground* bg = GetBattleground();
    uint32 mapid = GetMapId();
    OutdoorPvP* pvp = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(zoneid);
    InstanceScript* instance = GetInstanceScript();

    sLog->outDebug(LOG_FILTER_NETWORKIO, "Sending SMSG_INIT_WORLD_STATES to Map: %u, Zone: %u", mapid, zoneid);

    ByteBuffer l_Buffer(10 * 1024);
    l_Buffer << uint32(0x8d8) << uint32(0x0);                   // 1
    l_Buffer << uint32(0x8d7) << uint32(0x0);                   // 2
    l_Buffer << uint32(0x8d6) << uint32(0x0);                   // 3
    l_Buffer << uint32(0x8d5) << uint32(0x0);                   // 4
    l_Buffer << uint32(0x8d4) << uint32(0x0);                   // 5
    l_Buffer << uint32(0x8d3) << uint32(0x0);                   // 6

    if (mapid == 530)                                       // Outland
    {
        l_Buffer << uint32(0x9bf) << uint32(0x0);               // 7
        l_Buffer << uint32(0x9bd) << uint32(0xF);               // 8
        l_Buffer << uint32(0x9bb) << uint32(0xF);               // 9
    }

    // insert <field> <value>
    switch (zoneid)
    {
        case 1:                                             // Dun Morogh
        case 11:                                            // Wetlands
        case 12:                                            // Elwynn Forest
        case 38:                                            // Loch Modan
        case 40:                                            // Westfall
        case 51:                                            // Searing Gorge
        case 1519:                                          // Stormwind City
        case 1537:                                          // Ironforge
        case 2257:                                          // Deeprun Tram
        case 3703:                                          // Shattrath City
            break;
        case 1377:                                          // Silithus
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                // states are always shown
                l_Buffer << uint32(2313) << uint32(0x0); // 7 ally silityst gathered
                l_Buffer << uint32(2314) << uint32(0x0); // 8 horde silityst gathered
                l_Buffer << uint32(2317) << uint32(0x0); // 9 max silithyst
            }
            // dunno about these... aq opening event maybe?
            l_Buffer << uint32(2322) << uint32(0x0); // 10 sandworm N
            l_Buffer << uint32(2323) << uint32(0x0); // 11 sandworm S
            l_Buffer << uint32(2324) << uint32(0x0); // 12 sandworm SW
            l_Buffer << uint32(2325) << uint32(0x0); // 13 sandworm E
            break;
        case 2597:                                          // Alterac Valley
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x7ae) << uint32(0x1);           // 7 snowfall n
                l_Buffer << uint32(0x532) << uint32(0x1);           // 8 frostwolfhut hc
                l_Buffer << uint32(0x531) << uint32(0x0);           // 9 frostwolfhut ac
                l_Buffer << uint32(0x52e) << uint32(0x0);           // 10 stormpike firstaid a_a
                l_Buffer << uint32(0x571) << uint32(0x0);           // 11 east frostwolf tower horde assaulted -unused
                l_Buffer << uint32(0x570) << uint32(0x0);           // 12 west frostwolf tower horde assaulted - unused
                l_Buffer << uint32(0x567) << uint32(0x1);           // 13 frostwolfe c
                l_Buffer << uint32(0x566) << uint32(0x1);           // 14 frostwolfw c
                l_Buffer << uint32(0x550) << uint32(0x1);           // 15 irondeep (N) ally
                l_Buffer << uint32(0x544) << uint32(0x0);           // 16 ice grave a_a
                l_Buffer << uint32(0x536) << uint32(0x0);           // 17 stormpike grave h_c
                l_Buffer << uint32(0x535) << uint32(0x1);           // 18 stormpike grave a_c
                l_Buffer << uint32(0x518) << uint32(0x0);           // 19 stoneheart grave a_a
                l_Buffer << uint32(0x517) << uint32(0x0);           // 20 stoneheart grave h_a
                l_Buffer << uint32(0x574) << uint32(0x0);           // 21 1396 unk
                l_Buffer << uint32(0x573) << uint32(0x0);           // 22 iceblood tower horde assaulted -unused
                l_Buffer << uint32(0x572) << uint32(0x0);           // 23 towerpoint horde assaulted - unused
                l_Buffer << uint32(0x56f) << uint32(0x0);           // 24 1391 unk
                l_Buffer << uint32(0x56e) << uint32(0x0);           // 25 iceblood a
                l_Buffer << uint32(0x56d) << uint32(0x0);           // 26 towerp a
                l_Buffer << uint32(0x56c) << uint32(0x0);           // 27 frostwolfe a
                l_Buffer << uint32(0x56b) << uint32(0x0);           // 28 froswolfw a
                l_Buffer << uint32(0x56a) << uint32(0x1);           // 29 1386 unk
                l_Buffer << uint32(0x569) << uint32(0x1);           // 30 iceblood c
                l_Buffer << uint32(0x568) << uint32(0x1);           // 31 towerp c
                l_Buffer << uint32(0x565) << uint32(0x0);           // 32 stoneh tower a
                l_Buffer << uint32(0x564) << uint32(0x0);           // 33 icewing tower a
                l_Buffer << uint32(0x563) << uint32(0x0);           // 34 dunn a
                l_Buffer << uint32(0x562) << uint32(0x0);           // 35 duns a
                l_Buffer << uint32(0x561) << uint32(0x0);           // 36 stoneheart bunker alliance assaulted - unused
                l_Buffer << uint32(0x560) << uint32(0x0);           // 37 icewing bunker alliance assaulted - unused
                l_Buffer << uint32(0x55f) << uint32(0x0);           // 38 dunbaldar south alliance assaulted - unused
                l_Buffer << uint32(0x55e) << uint32(0x0);           // 39 dunbaldar north alliance assaulted - unused
                l_Buffer << uint32(0x55d) << uint32(0x0);           // 40 stone tower d
                l_Buffer << uint32(0x3c6) << uint32(0x0);           // 41 966 unk
                l_Buffer << uint32(0x3c4) << uint32(0x0);           // 42 964 unk
                l_Buffer << uint32(0x3c2) << uint32(0x0);           // 43 962 unk
                l_Buffer << uint32(0x516) << uint32(0x1);           // 44 stoneheart grave a_c
                l_Buffer << uint32(0x515) << uint32(0x0);           // 45 stonheart grave h_c
                l_Buffer << uint32(0x3b6) << uint32(0x0);           // 46 950 unk
                l_Buffer << uint32(0x55c) << uint32(0x0);           // 47 icewing tower d
                l_Buffer << uint32(0x55b) << uint32(0x0);           // 48 dunn d
                l_Buffer << uint32(0x55a) << uint32(0x0);           // 49 duns d
                l_Buffer << uint32(0x559) << uint32(0x0);           // 50 1369 unk
                l_Buffer << uint32(0x558) << uint32(0x0);           // 51 iceblood d
                l_Buffer << uint32(0x557) << uint32(0x0);           // 52 towerp d
                l_Buffer << uint32(0x556) << uint32(0x0);           // 53 frostwolfe d
                l_Buffer << uint32(0x555) << uint32(0x0);           // 54 frostwolfw d
                l_Buffer << uint32(0x554) << uint32(0x1);           // 55 stoneh tower c
                l_Buffer << uint32(0x553) << uint32(0x1);           // 56 icewing tower c
                l_Buffer << uint32(0x552) << uint32(0x1);           // 57 dunn c
                l_Buffer << uint32(0x551) << uint32(0x1);           // 58 duns c
                l_Buffer << uint32(0x54f) << uint32(0x0);           // 59 irondeep (N) horde
                l_Buffer << uint32(0x54e) << uint32(0x0);           // 60 irondeep (N) ally
                l_Buffer << uint32(0x54d) << uint32(0x1);           // 61 mine (S) neutral
                l_Buffer << uint32(0x54c) << uint32(0x0);           // 62 mine (S) horde
                l_Buffer << uint32(0x54b) << uint32(0x0);           // 63 mine (S) ally
                l_Buffer << uint32(0x545) << uint32(0x0);           // 64 iceblood h_a
                l_Buffer << uint32(0x543) << uint32(0x1);           // 65 iceblod h_c
                l_Buffer << uint32(0x542) << uint32(0x0);           // 66 iceblood a_c
                l_Buffer << uint32(0x540) << uint32(0x0);           // 67 snowfall h_a
                l_Buffer << uint32(0x53f) << uint32(0x0);           // 68 snowfall a_a
                l_Buffer << uint32(0x53e) << uint32(0x0);           // 69 snowfall h_c
                l_Buffer << uint32(0x53d) << uint32(0x0);           // 70 snowfall a_c
                l_Buffer << uint32(0x53c) << uint32(0x0);           // 71 frostwolf g h_a
                l_Buffer << uint32(0x53b) << uint32(0x0);           // 72 frostwolf g a_a
                l_Buffer << uint32(0x53a) << uint32(0x1);           // 73 frostwolf g h_c
                l_Buffer << uint32(0x539) << uint32(0x0);           // 74 frostwolf g a_c
                l_Buffer << uint32(0x538) << uint32(0x0);           // 75 stormpike grave h_a
                l_Buffer << uint32(0x537) << uint32(0x0);           // 76 stormpike grave a_a
                l_Buffer << uint32(0x534) << uint32(0x0);           // 77 frostwolf hut h_a
                l_Buffer << uint32(0x533) << uint32(0x0);           // 78 frostwolf hut a_a
                l_Buffer << uint32(0x530) << uint32(0x0);           // 79 stormpike first aid h_a
                l_Buffer << uint32(0x52f) << uint32(0x0);           // 80 stormpike first aid h_c
                l_Buffer << uint32(0x52d) << uint32(0x1);           // 81 stormpike first aid a_c
            }
            break;
        case 3277:                                          // Warsong Gulch
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x62d) << uint32(0x0);       // 7 1581 alliance flag captures
                l_Buffer << uint32(0x62e) << uint32(0x0);       // 8 1582 horde flag captures
                l_Buffer << uint32(0x609) << uint32(0x0);       // 9 1545 unk, set to 1 on alliance flag pickup...
                l_Buffer << uint32(0x60a) << uint32(0x0);       // 10 1546 unk, set to 1 on horde flag pickup, after drop it's -1
                l_Buffer << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
                l_Buffer << uint32(0x641) << uint32(0x3);       // 12 1601 unk (max flag captures?)
                l_Buffer << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                l_Buffer << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        case 3358:                                          // Arathi Basin
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AB)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x6e7) << uint32(0x0);       // 7 1767 stables alliance
                l_Buffer << uint32(0x6e8) << uint32(0x0);       // 8 1768 stables horde
                l_Buffer << uint32(0x6e9) << uint32(0x0);       // 9 1769 unk, ST?
                l_Buffer << uint32(0x6ea) << uint32(0x0);       // 10 1770 stables (show/hide)
                l_Buffer << uint32(0x6ec) << uint32(0x0);       // 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
                l_Buffer << uint32(0x6ed) << uint32(0x0);       // 12 1773 farm (show/hide)
                l_Buffer << uint32(0x6ee) << uint32(0x0);       // 13 1774 farm color
                l_Buffer << uint32(0x6ef) << uint32(0x0);       // 14 1775 gold mine color, may be FM?
                l_Buffer << uint32(0x6f0) << uint32(0x0);       // 15 1776 alliance resources
                l_Buffer << uint32(0x6f1) << uint32(0x0);       // 16 1777 horde resources
                l_Buffer << uint32(0x6f2) << uint32(0x0);       // 17 1778 horde bases
                l_Buffer << uint32(0x6f3) << uint32(0x0);       // 18 1779 alliance bases
                l_Buffer << uint32(0x6f4) << uint32(0x7d0);     // 19 1780 max resources (2000)
                l_Buffer << uint32(0x6f6) << uint32(0x0);       // 20 1782 blacksmith color
                l_Buffer << uint32(0x6f7) << uint32(0x0);       // 21 1783 blacksmith (show/hide)
                l_Buffer << uint32(0x6f8) << uint32(0x0);       // 22 1784 unk, bs?
                l_Buffer << uint32(0x6f9) << uint32(0x0);       // 23 1785 unk, bs?
                l_Buffer << uint32(0x6fb) << uint32(0x0);       // 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
                l_Buffer << uint32(0x6fc) << uint32(0x0);       // 25 1788 gold mine (0 - conflict, 1 - horde)
                l_Buffer << uint32(0x6fd) << uint32(0x0);       // 26 1789 gold mine (1 - show/0 - hide)
                l_Buffer << uint32(0x6fe) << uint32(0x0);       // 27 1790 gold mine color
                l_Buffer << uint32(0x700) << uint32(0x0);       // 28 1792 gold mine color, wtf?, may be LM?
                l_Buffer << uint32(0x701) << uint32(0x0);       // 29 1793 lumber mill color (0 - conflict, 1 - horde contr)
                l_Buffer << uint32(0x702) << uint32(0x0);       // 30 1794 lumber mill (show/hide)
                l_Buffer << uint32(0x703) << uint32(0x0);       // 31 1795 lumber mill color color
                l_Buffer << uint32(0x732) << uint32(0x1);       // 32 1842 stables (1 - uncontrolled)
                l_Buffer << uint32(0x733) << uint32(0x1);       // 33 1843 gold mine (1 - uncontrolled)
                l_Buffer << uint32(0x734) << uint32(0x1);       // 34 1844 lumber mill (1 - uncontrolled)
                l_Buffer << uint32(0x735) << uint32(0x1);       // 35 1845 farm (1 - uncontrolled)
                l_Buffer << uint32(0x736) << uint32(0x1);       // 36 1846 blacksmith (1 - uncontrolled)
                l_Buffer << uint32(0x745) << uint32(0x2);       // 37 1861 unk
                l_Buffer << uint32(0x7a3) << uint32(0x708);     // 38 1955 warning limit (1800)
            }
            break;
        case 3820:                                          // Eye of the Storm
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xac1) << uint32(0x0);       // 7  2753 Horde Bases
                l_Buffer << uint32(0xac0) << uint32(0x0);       // 8  2752 Alliance Bases
                l_Buffer << uint32(0xab6) << uint32(0x0);       // 9  2742 Mage Tower - Horde conflict
                l_Buffer << uint32(0xab5) << uint32(0x0);       // 10 2741 Mage Tower - Alliance conflict
                l_Buffer << uint32(0xab4) << uint32(0x0);       // 11 2740 Fel Reaver - Horde conflict
                l_Buffer << uint32(0xab3) << uint32(0x0);       // 12 2739 Fel Reaver - Alliance conflict
                l_Buffer << uint32(0xab2) << uint32(0x0);       // 13 2738 Draenei - Alliance conflict
                l_Buffer << uint32(0xab1) << uint32(0x0);       // 14 2737 Draenei - Horde conflict
                l_Buffer << uint32(0xab0) << uint32(0x0);       // 15 2736 unk // 0 at start
                l_Buffer << uint32(0xaaf) << uint32(0x0);       // 16 2735 unk // 0 at start
                l_Buffer << uint32(0xaad) << uint32(0x0);       // 17 2733 Draenei - Horde control
                l_Buffer << uint32(0xaac) << uint32(0x0);       // 18 2732 Draenei - Alliance control
                l_Buffer << uint32(0xaab) << uint32(0x1);       // 19 2731 Draenei uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaaa) << uint32(0x0);       // 20 2730 Mage Tower - Alliance control
                l_Buffer << uint32(0xaa9) << uint32(0x0);       // 21 2729 Mage Tower - Horde control
                l_Buffer << uint32(0xaa8) << uint32(0x1);       // 22 2728 Mage Tower uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaa7) << uint32(0x0);       // 23 2727 Fel Reaver - Horde control
                l_Buffer << uint32(0xaa6) << uint32(0x0);       // 24 2726 Fel Reaver - Alliance control
                l_Buffer << uint32(0xaa5) << uint32(0x1);       // 25 2725 Fel Reaver uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xaa4) << uint32(0x0);       // 26 2724 Boold Elf - Horde control
                l_Buffer << uint32(0xaa3) << uint32(0x0);       // 27 2723 Boold Elf - Alliance control
                l_Buffer << uint32(0xaa2) << uint32(0x1);       // 28 2722 Boold Elf uncontrolled (1 - yes, 0 - no)
                l_Buffer << uint32(0xac5) << uint32(0x1);       // 29 2757 Flag (1 - show, 0 - hide) - doesn't work exactly this way!
                l_Buffer << uint32(0xad2) << uint32(0x1);       // 30 2770 Horde top-stats (1 - show, 0 - hide) // 02 -> horde picked up the flag
                l_Buffer << uint32(0xad1) << uint32(0x1);       // 31 2769 Alliance top-stats (1 - show, 0 - hide) // 02 -> alliance picked up the flag
                l_Buffer << uint32(0xabe) << uint32(0x0);       // 32 2750 Horde resources
                l_Buffer << uint32(0xabd) << uint32(0x0);       // 33 2749 Alliance resources
                l_Buffer << uint32(0xa05) << uint32(0x8e);      // 34 2565 unk, constant?
                l_Buffer << uint32(0xaa0) << uint32(0x0);       // 35 2720 Capturing progress-bar (100 -> empty (only grey), 0 -> blue|red (no grey), default 0)
                l_Buffer << uint32(0xa9f) << uint32(0x0);       // 36 2719 Capturing progress-bar (0 - left, 100 - right)
                l_Buffer << uint32(0xa9e) << uint32(0x0);       // 37 2718 Capturing progress-bar (1 - show, 0 - hide)
                l_Buffer << uint32(0xc0d) << uint32(0x17b);     // 38 3085 unk
                // and some more ... unknown
            }
            break;
        // any of these needs change! the client remembers the prev setting!
        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
        case 3483:                                          // Hellfire Peninsula
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x9ba) << uint32(0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
                l_Buffer << uint32(0x9b9) << uint32(0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
                l_Buffer << uint32(0x9b5) << uint32(0x0);           // 12 // show neutral broken hill icon      // 2485
                l_Buffer << uint32(0x9b4) << uint32(0x1);           // 13 // show icon above broken hill        // 2484
                l_Buffer << uint32(0x9b3) << uint32(0x0);           // 14 // show ally broken hill icon         // 2483
                l_Buffer << uint32(0x9b2) << uint32(0x0);           // 15 // show neutral overlook icon         // 2482
                l_Buffer << uint32(0x9b1) << uint32(0x1);           // 16 // show the overlook arrow            // 2481
                l_Buffer << uint32(0x9b0) << uint32(0x0);           // 17 // show ally overlook icon            // 2480
                l_Buffer << uint32(0x9ae) << uint32(0x0);           // 18 // horde pvp objectives captured      // 2478
                l_Buffer << uint32(0x9ac) << uint32(0x0);           // 19 // ally pvp objectives captured       // 2476
                l_Buffer << uint32(2475)  << uint32(100); //: ally / horde slider grey area                              // show only in direct vicinity!
                l_Buffer << uint32(2474)  << uint32(50);  //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
                l_Buffer << uint32(2473)  << uint32(0);   //: ally / horde slider display                                // show only in direct vicinity!
                l_Buffer << uint32(0x9a8) << uint32(0x0);           // 20 // show the neutral stadium icon      // 2472
                l_Buffer << uint32(0x9a7) << uint32(0x0);           // 21 // show the ally stadium icon         // 2471
                l_Buffer << uint32(0x9a6) << uint32(0x1);           // 22 // show the horde stadium icon        // 2470
            }
            break;
        case 3518:                                          // Nagrand
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(2503) << uint32(0x0);    // 10
                l_Buffer << uint32(2502) << uint32(0x0);    // 11
                l_Buffer << uint32(2493) << uint32(0x0);    // 12
                l_Buffer << uint32(2491) << uint32(0x0);    // 13

                l_Buffer << uint32(2495) << uint32(0x0);    // 14
                l_Buffer << uint32(2494) << uint32(0x0);    // 15
                l_Buffer << uint32(2497) << uint32(0x0);    // 16

                l_Buffer << uint32(2762) << uint32(0x0);    // 17
                l_Buffer << uint32(2662) << uint32(0x0);    // 18
                l_Buffer << uint32(2663) << uint32(0x0);    // 19
                l_Buffer << uint32(2664) << uint32(0x0);    // 20

                l_Buffer << uint32(2760) << uint32(0x0);    // 21
                l_Buffer << uint32(2670) << uint32(0x0);    // 22
                l_Buffer << uint32(2668) << uint32(0x0);    // 23
                l_Buffer << uint32(2669) << uint32(0x0);    // 24

                l_Buffer << uint32(2761) << uint32(0x0);    // 25
                l_Buffer << uint32(2667) << uint32(0x0);    // 26
                l_Buffer << uint32(2665) << uint32(0x0);    // 27
                l_Buffer << uint32(2666) << uint32(0x0);    // 28

                l_Buffer << uint32(2763) << uint32(0x0);    // 29
                l_Buffer << uint32(2659) << uint32(0x0);    // 30
                l_Buffer << uint32(2660) << uint32(0x0);    // 31
                l_Buffer << uint32(2661) << uint32(0x0);    // 32

                l_Buffer << uint32(2671) << uint32(0x0);    // 33
                l_Buffer << uint32(2676) << uint32(0x0);    // 34
                l_Buffer << uint32(2677) << uint32(0x0);    // 35
                l_Buffer << uint32(2672) << uint32(0x0);    // 36
                l_Buffer << uint32(2673) << uint32(0x0);    // 37
            }
            break;
        case 3519:                                          // Terokkar Forest
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xa41) << uint32(0x0);           // 10 // 2625 capture bar pos
                l_Buffer << uint32(0xa40) << uint32(0x14);          // 11 // 2624 capture bar neutral
                l_Buffer << uint32(0xa3f) << uint32(0x0);           // 12 // 2623 show capture bar
                l_Buffer << uint32(0xa3e) << uint32(0x0);           // 13 // 2622 horde towers controlled
                l_Buffer << uint32(0xa3d) << uint32(0x5);           // 14 // 2621 ally towers controlled
                l_Buffer << uint32(0xa3c) << uint32(0x0);           // 15 // 2620 show towers controlled
                l_Buffer << uint32(0xa88) << uint32(0x0);           // 16 // 2696 SE Neu
                l_Buffer << uint32(0xa87) << uint32(0x0);           // 17 // SE Horde
                l_Buffer << uint32(0xa86) << uint32(0x0);           // 18 // SE Ally
                l_Buffer << uint32(0xa85) << uint32(0x0);           // 19 //S Neu
                l_Buffer << uint32(0xa84) << uint32(0x0);           // 20 S Horde
                l_Buffer << uint32(0xa83) << uint32(0x0);           // 21 S Ally
                l_Buffer << uint32(0xa82) << uint32(0x0);           // 22 NE Neu
                l_Buffer << uint32(0xa81) << uint32(0x0);           // 23 NE Horde
                l_Buffer << uint32(0xa80) << uint32(0x0);           // 24 NE Ally
                l_Buffer << uint32(0xa7e) << uint32(0x0);           // 25 // 2686 N Neu
                l_Buffer << uint32(0xa7d) << uint32(0x0);           // 26 N Horde
                l_Buffer << uint32(0xa7c) << uint32(0x0);           // 27 N Ally
                l_Buffer << uint32(0xa7b) << uint32(0x0);           // 28 NW Ally
                l_Buffer << uint32(0xa7a) << uint32(0x0);           // 29 NW Horde
                l_Buffer << uint32(0xa79) << uint32(0x0);           // 30 NW Neutral
                l_Buffer << uint32(0x9d0) << uint32(0x5);           // 31 // 2512 locked time remaining seconds first digit
                l_Buffer << uint32(0x9ce) << uint32(0x0);           // 32 // 2510 locked time remaining seconds second digit
                l_Buffer << uint32(0x9cd) << uint32(0x0);           // 33 // 2509 locked time remaining minutes
                l_Buffer << uint32(0x9cc) << uint32(0x0);           // 34 // 2508 neutral locked time show
                l_Buffer << uint32(0xad0) << uint32(0x0);           // 35 // 2768 horde locked time show
                l_Buffer << uint32(0xacf) << uint32(0x1);           // 36 // 2767 ally locked time show
            }
            break;
        case 3521:                                          // Zangarmarsh
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x9e1) << uint32(0x0);           // 10 //2529
                l_Buffer << uint32(0x9e0) << uint32(0x0);           // 11
                l_Buffer << uint32(0x9df) << uint32(0x0);           // 12
                l_Buffer << uint32(0xa5d) << uint32(0x1);           // 13 //2653
                l_Buffer << uint32(0xa5c) << uint32(0x0);           // 14 //2652 east beacon neutral
                l_Buffer << uint32(0xa5b) << uint32(0x1);           // 15 horde
                l_Buffer << uint32(0xa5a) << uint32(0x0);           // 16 ally
                l_Buffer << uint32(0xa59) << uint32(0x1);           // 17 // 2649 Twin spire graveyard horde  12???
                l_Buffer << uint32(0xa58) << uint32(0x0);           // 18 ally     14 ???
                l_Buffer << uint32(0xa57) << uint32(0x0);           // 19 neutral  7???
                l_Buffer << uint32(0xa56) << uint32(0x0);           // 20 // 2646 west beacon neutral
                l_Buffer << uint32(0xa55) << uint32(0x1);           // 21 horde
                l_Buffer << uint32(0xa54) << uint32(0x0);           // 22 ally
                l_Buffer << uint32(0x9e7) << uint32(0x0);           // 23 // 2535
                l_Buffer << uint32(0x9e6) << uint32(0x0);           // 24
                l_Buffer << uint32(0x9e5) << uint32(0x0);           // 25
                l_Buffer << uint32(0xa00) << uint32(0x0);           // 26 // 2560
                l_Buffer << uint32(0x9ff) << uint32(0x1);           // 27
                l_Buffer << uint32(0x9fe) << uint32(0x0);           // 28
                l_Buffer << uint32(0x9fd) << uint32(0x0);           // 29
                l_Buffer << uint32(0x9fc) << uint32(0x1);           // 30
                l_Buffer << uint32(0x9fb) << uint32(0x0);           // 31
                l_Buffer << uint32(0xa62) << uint32(0x0);           // 32 // 2658
                l_Buffer << uint32(0xa61) << uint32(0x1);           // 33
                l_Buffer << uint32(0xa60) << uint32(0x1);           // 34
                l_Buffer << uint32(0xa5f) << uint32(0x0);           // 35
            }
            break;
        case 3698:                                          // Nagrand Arena
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xa0f) << uint32(0x0);           // 7
                l_Buffer << uint32(0xa10) << uint32(0x0);           // 8
                l_Buffer << uint32(0xa11) << uint32(0x0);           // 9 show
            }
            break;
        case 3702:                                          // Blade's Edge Arena
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BE)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x9f0) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0x9f1) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0x9f3) << uint32(0x0);           // 9 show
            }
            break;
        case 3968:                                          // Ruins of Lordaeron
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RL)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xbb8) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xbb9) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xbba) << uint32(0x0);           // 9 show
            }
            break;
        case 4378:                                          // Dalaran Sewers
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DS)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3601) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(3600) << uint32(0x0);           // 8 green
                l_Buffer << uint32(3610) << uint32(0x0);           // 9 show
            }
            break;
        case 4384:                                          // Strand of the Ancients
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SA)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                // 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
                l_Buffer << uint32(0xf09) << uint32(0x0);       // 7  3849 Gate of Temple
                l_Buffer << uint32(0xe36) << uint32(0x0);       // 8  3638 Gate of Yellow Moon
                l_Buffer << uint32(0xe27) << uint32(0x0);       // 9  3623 Gate of Green Emerald
                l_Buffer << uint32(0xe24) << uint32(0x0);       // 10 3620 Gate of Blue Sapphire
                l_Buffer << uint32(0xe21) << uint32(0x0);       // 11 3617 Gate of Red Sun
                l_Buffer << uint32(0xe1e) << uint32(0x0);       // 12 3614 Gate of Purple Ametyst

                l_Buffer << uint32(0xdf3) << uint32(0x0);       // 13 3571 bonus timer (1 - on, 0 - off)
                l_Buffer << uint32(0xded) << uint32(0x0);       // 14 3565 Horde Attacker
                l_Buffer << uint32(0xdec) << uint32(0x0);       // 15 3564 Alliance Attacker
                // End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
                l_Buffer << uint32(0xde9) << uint32(0x0);       // 16 3561 C
                l_Buffer << uint32(0xde8) << uint32(0x0);       // 17 3560 B
                l_Buffer << uint32(0xde7) << uint32(0x0);       // 18 3559 A
                l_Buffer << uint32(0xe35) << uint32(0x0);       // 19 3637 East g - Horde control
                l_Buffer << uint32(0xe34) << uint32(0x0);       // 20 3636 West g - Horde control
                l_Buffer << uint32(0xe33) << uint32(0x0);       // 21 3635 South g - Horde control
                l_Buffer << uint32(0xe32) << uint32(0x0);       // 22 3634 East g - Alliance control
                l_Buffer << uint32(0xe31) << uint32(0x0);       // 23 3633 West g - Alliance control
                l_Buffer << uint32(0xe30) << uint32(0x0);       // 24 3632 South g - Alliance control
                l_Buffer << uint32(0xe2f) << uint32(0x0);       // 25 3631 Chamber of Ancients - Horde control
                l_Buffer << uint32(0xe2e) << uint32(0x0);       // 26 3630 Chamber of Ancients - Alliance control
                l_Buffer << uint32(0xe2d) << uint32(0x0);       // 27 3629 Beach1 - Horde control
                l_Buffer << uint32(0xe2c) << uint32(0x0);       // 28 3628 Beach2 - Horde control
                l_Buffer << uint32(0xe2b) << uint32(0x0);       // 29 3627 Beach1 - Alliance control
                l_Buffer << uint32(0xe2a) << uint32(0x0);       // 30 3626 Beach2 - Alliance control
                // and many unks...
            }
            break;
        case 4406:                                          // Ring of Valor
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xe10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xe11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xe1a) << uint32(0x0);           // 9 show
            }
            break;
        case 4710:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_IC)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4221) << uint32(1); // 7 BG_IC_ALLIANCE_RENFORT_SET
                l_Buffer << uint32(4222) << uint32(1); // 8 BG_IC_HORDE_RENFORT_SET
                l_Buffer << uint32(4226) << uint32(300); // 9 BG_IC_ALLIANCE_RENFORT
                l_Buffer << uint32(4227) << uint32(300); // 10 BG_IC_HORDE_RENFORT
                l_Buffer << uint32(4322) << uint32(1); // 11 BG_IC_GATE_FRONT_H_WS_OPEN
                l_Buffer << uint32(4321) << uint32(1); // 12 BG_IC_GATE_WEST_H_WS_OPEN
                l_Buffer << uint32(4320) << uint32(1); // 13 BG_IC_GATE_EAST_H_WS_OPEN
                l_Buffer << uint32(4323) << uint32(1); // 14 BG_IC_GATE_FRONT_A_WS_OPEN
                l_Buffer << uint32(4324) << uint32(1); // 15 BG_IC_GATE_WEST_A_WS_OPEN
                l_Buffer << uint32(4325) << uint32(1); // 16 BG_IC_GATE_EAST_A_WS_OPEN
                l_Buffer << uint32(4317) << uint32(1); // 17 unknown

                l_Buffer << uint32(4301) << uint32(1); // 18 BG_IC_DOCKS_UNCONTROLLED
                l_Buffer << uint32(4296) << uint32(1); // 19 BG_IC_HANGAR_UNCONTROLLED
                l_Buffer << uint32(4306) << uint32(1); // 20 BG_IC_QUARRY_UNCONTROLLED
                l_Buffer << uint32(4311) << uint32(1); // 21 BG_IC_REFINERY_UNCONTROLLED
                l_Buffer << uint32(4294) << uint32(1); // 22 BG_IC_WORKSHOP_UNCONTROLLED
                l_Buffer << uint32(4243) << uint32(1); // 23 unknown
                l_Buffer << uint32(4345) << uint32(1); // 24 unknown
            }
            break;
        // The Ruby Sanctum
        case 4987:
            if (instance && mapid == 724)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(5049) << uint32(50);             // 9 WORLDSTATE_CORPOREALITY_MATERIAL
                l_Buffer << uint32(5050) << uint32(50);             // 10 WORLDSTATE_CORPOREALITY_TWILIGHT
                l_Buffer << uint32(5051) << uint32(0);              // 11 WORLDSTATE_CORPOREALITY_TOGGLE
            }
            break;
        // Icecrown Citadel
        case 4812:
            if (instance && mapid == 631)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4903) << uint32(0);              // 9  WORLDSTATE_SHOW_TIMER (Blood Quickening weekly)
                l_Buffer << uint32(4904) << uint32(30);             // 10 WORLDSTATE_EXECUTION_TIME
                l_Buffer << uint32(4940) << uint32(0);              // 11 WORLDSTATE_SHOW_ATTEMPTS
                l_Buffer << uint32(4941) << uint32(50);             // 12 WORLDSTATE_ATTEMPTS_REMAINING
                l_Buffer << uint32(4942) << uint32(50);             // 13 WORLDSTATE_ATTEMPTS_MAX
            }
            break;
        // The Culling of Stratholme
        case 4100:
            if (instance && mapid == 595)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3479) << uint32(0);              // 9  WORLDSTATE_SHOW_CRATES
                l_Buffer << uint32(3480) << uint32(0);              // 10 WORLDSTATE_CRATES_REVEALED
                l_Buffer << uint32(3504) << uint32(0);              // 11 WORLDSTATE_WAVE_COUNT
                l_Buffer << uint32(3931) << uint32(25);             // 12 WORLDSTATE_TIME_GUARDIAN
                l_Buffer << uint32(3932) << uint32(0);              // 13 WORLDSTATE_TIME_GUARDIAN_SHOW
            }
            break;
        // The Oculus
        case 4228:
            if (instance && mapid == 578)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(3524) << uint32(0); // 9 WORLD_STATE_CENTRIFUGE_CONSTRUCT_SHOW
                l_Buffer << uint32(3486) << uint32(0); // 10 WORLD_STATE_CENTRIFUGE_CONSTRUCT_AMOUNT
            }
            break;
        // Ulduar
        case 4273:
            if (instance && mapid == 603)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4132) << uint32(0);              // 9  WORLDSTATE_SHOW_CRATES
                l_Buffer << uint32(4131) << uint32(0);              // 10 WORLDSTATE_CRATES_REVEALED
            }
            break;
        // Twin Peaks
        case 5031:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TP)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x62d) << uint32(0x0);       //  7 1581 alliance flag captures
                l_Buffer << uint32(0x62e) << uint32(0x0);       //  8 1582 horde flag captures
                l_Buffer << uint32(0x609) << uint32(0x0);       //  9 1545 unk
                l_Buffer << uint32(0x60a) << uint32(0x0);       // 10 1546 unk
                l_Buffer << uint32(0x60b) << uint32(0x2);       // 11 1547 unk
                l_Buffer << uint32(0x641) << uint32(0x3);       // 12 1601 unk
                l_Buffer << uint32(0x922) << uint32(0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                l_Buffer << uint32(0x923) << uint32(0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        // Battle for Gilneas
        case 5449:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BFG)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        // Halls of Reflection
        case 4820:
            if (instance && mapid == 668)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(4884) << uint32(0);              // 9 WORLD_STATE_HOR_WAVES_ENABLED
                l_Buffer << uint32(4882) << uint32(0);              // 10 WORLD_STATE_HOR_WAVE_COUNT
            }
            break;
        case 5833:
            l_Buffer << uint32(0x1958) << uint32(0x1);
            l_Buffer << uint32(0x1959) << uint32(0x4);
            break;
        // Silvershard Mines
        case 6126:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SM)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0x1924) << uint32(1);            // SM_MINE_CARTS_DISPLAY
                l_Buffer << uint32(0x1925) << uint32(0);            // SM_ALLIANCE_RESOURCES
                l_Buffer << uint32(0x1926) << uint32(0);            // SM_HORDE_RESOURCES
                l_Buffer << uint32(0x1927) << uint32(1);            // SM_MINE_CART_1
                l_Buffer << uint32(0x1928) << uint32(1);            // SM_MINE_CART_2
                l_Buffer << uint32(0x1929) << uint32(1);            // SM_DISPLAY_ALLIANCE_RESSOURCES
                l_Buffer << uint32(0x192a) << uint32(1);            // SM_MINE_CART_3
                l_Buffer << uint32(0x192b) << uint32(1);            // SM_DISPLAY_HORDE_RESSOURCES
                l_Buffer << uint32(0x1adb) << uint32(0);            // SM_DISPLAY_PROGRESS_BAR
                l_Buffer << uint32(0x1adc) << uint32(0);            // SM_PROGRESS_BAR_STATUS
                l_Buffer << uint32(0x1add) << uint32(0);            // SM_UNK
            }
            break;
        // Tol'Viron Arena
        case 6296:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TV)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xE10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xE11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xE1A) << uint32(0x0);           // 9 show
            }
            break;
        // The Tiger's Peak
        case 6732:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TTP)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(0xE10) << uint32(0x0);           // 7 gold
                l_Buffer << uint32(0xE11) << uint32(0x0);           // 8 green
                l_Buffer << uint32(0xE1A) << uint32(0x0);           // 9 show
            }
            break;
        // Deepwind Gorge
        case 6665:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DG)
                bg->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(7938) << uint32(1);          // WORLDSTATE_DG_GOLBIN_MINE
                l_Buffer << uint32(7939) << uint32(1);          // WORLDSTATE_DG_CENTER_MINE
                l_Buffer << uint32(7935) << uint32(1);          // WORLDSTATE_DG_PANDA_MINE
                l_Buffer << uint32(8230) << uint32(0);          // WORLDSTATE_DG_BASE_ALLIANCE
                l_Buffer << uint32(8231) << uint32(0);          // WORLDSTATE_DG_BASE_HORDE
                l_Buffer << uint32(7880) << uint32(0);          // WORLDSTATE_DG_SCORE_ALLIANCE
                l_Buffer << uint32(7881) << uint32(0);          // WORLDSTATE_DG_SCORE_HORDE
                l_Buffer << uint32(7904) << uint32(1);          // WORLDSTATE_DG_CART_ALLIANCE
                l_Buffer << uint32(7887) << uint32(1);          // WORLDSTATE_DG_CART_HORDE
            }
            break;
        // Ashran
        case 6941:
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ASHRAN)
                pvp->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(521) << uint32(0);
                l_Buffer << uint32(522) << uint32(0);
                l_Buffer << uint32(523) << uint32(0);
                l_Buffer << uint32(524) << uint32(0);
                l_Buffer << uint32(1581) << uint32(0);
                l_Buffer << uint32(1582) << uint32(0);
                l_Buffer << uint32(1723) << uint32(0);
                l_Buffer << uint32(1724) << uint32(0);
                l_Buffer << uint32(1941) << uint32(0);
                l_Buffer << uint32(1942) << uint32(0);
                l_Buffer << uint32(1943) << uint32(0);
                l_Buffer << uint32(2259) << uint32(0);
                l_Buffer << uint32(2260) << uint32(0);
                l_Buffer << uint32(2261) << uint32(0);
                l_Buffer << uint32(2262) << uint32(0);
                l_Buffer << uint32(2263) << uint32(0);
                l_Buffer << uint32(2264) << uint32(0);
                l_Buffer << uint32(2265) << uint32(142);
                l_Buffer << uint32(2851) << uint32(0);
                l_Buffer << uint32(3085) << uint32(379);
                l_Buffer << uint32(3191) << uint32(16);
                l_Buffer << uint32(3327) << uint32(0);
                l_Buffer << uint32(3426) << uint32(3);
                l_Buffer << uint32(3600) << uint32(0);
                l_Buffer << uint32(3601) << uint32(0);
                l_Buffer << uint32(3610) << uint32(1);
                l_Buffer << uint32(3695) << uint32(0);
                l_Buffer << uint32(3710) << uint32(0);
                l_Buffer << uint32(3781) << uint32(0);
                l_Buffer << uint32(3801) << uint32(1);
                l_Buffer << uint32(3826) << uint32(4);
                l_Buffer << uint32(3901) << uint32(3);
                l_Buffer << uint32(4020) << uint32(1094);
                l_Buffer << uint32(4021) << uint32(7);
                l_Buffer << uint32(4022) << uint32(3);
                l_Buffer << uint32(4023) << uint32(4);
                l_Buffer << uint32(4024) << uint32(825);
                l_Buffer << uint32(4025) << uint32(269);
                l_Buffer << uint32(4062) << uint32(0);
                l_Buffer << uint32(4131) << uint32(60);
                l_Buffer << uint32(4273) << uint32(0);
                l_Buffer << uint32(4354) << uint32(time(NULL));
                l_Buffer << uint32(4375) << uint32(0);
                l_Buffer << uint32(4417) << uint32(1);
                l_Buffer << uint32(4418) << uint32(50);
                l_Buffer << uint32(4419) << uint32(0);
                l_Buffer << uint32(4485) << uint32(0);
                l_Buffer << uint32(4486) << uint32(0);
                l_Buffer << uint32(4862) << uint32(1000);
                l_Buffer << uint32(4863) << uint32(300);
                l_Buffer << uint32(4864) << uint32(100);
                l_Buffer << uint32(5037) << uint32(6);
                l_Buffer << uint32(5071) << uint32(6);
                l_Buffer << uint32(5115) << uint32(0);
                l_Buffer << uint32(5192) << uint32(0);
                l_Buffer << uint32(5193) << uint32(0);
                l_Buffer << uint32(5194) << uint32(0);
                l_Buffer << uint32(5195) << uint32(0);
                l_Buffer << uint32(5196) << uint32(0);
                l_Buffer << uint32(5332) << uint32(time(NULL));
                l_Buffer << uint32(5333) << uint32(0);
                l_Buffer << uint32(5334) << uint32(1);
                l_Buffer << uint32(5344) << uint32(0);
                l_Buffer << uint32(5360) << uint32(0);
                l_Buffer << uint32(5361) << uint32(0);
                l_Buffer << uint32(5508) << uint32(1);
                l_Buffer << uint32(5677) << uint32(0);
                l_Buffer << uint32(5678) << uint32(0);
                l_Buffer << uint32(5679) << uint32(0);
                l_Buffer << uint32(5684) << uint32(0);
                l_Buffer << uint32(6078) << uint32(0);
                l_Buffer << uint32(6095) << uint32(0);
                l_Buffer << uint32(6164) << uint32(35);
                l_Buffer << uint32(6174) << uint32(0);
                l_Buffer << uint32(6267) << uint32(25);
                l_Buffer << uint32(6306) << uint32(0);
                l_Buffer << uint32(6436) << uint32(0);
                l_Buffer << uint32(6895) << uint32(10);
                l_Buffer << uint32(6897) << uint32(10);
                l_Buffer << uint32(6898) << uint32(10);
                l_Buffer << uint32(7022) << uint32(0);
                l_Buffer << uint32(7242) << uint32(82);
                l_Buffer << uint32(7243) << uint32(1);
                l_Buffer << uint32(7244) << uint32(82);
                l_Buffer << uint32(7245) << uint32(1);
                l_Buffer << uint32(7511) << uint32(0);
                l_Buffer << uint32(7617) << uint32(5);
                l_Buffer << uint32(7618) << uint32(5);
                l_Buffer << uint32(7671) << uint32(0);
                l_Buffer << uint32(7738) << uint32(0);
                l_Buffer << uint32(7752) << uint32(0);
                l_Buffer << uint32(7774) << uint32(0);
                l_Buffer << uint32(7796) << uint32(0);
                l_Buffer << uint32(7797) << uint32(0);
                l_Buffer << uint32(7876) << uint32(0);
                l_Buffer << uint32(8012) << uint32(1);
                l_Buffer << uint32(8295) << uint32(15);
                l_Buffer << uint32(8306) << uint32(20);
                l_Buffer << uint32(8307) << uint32(20);
                l_Buffer << uint32(8391) << uint32(0);
                l_Buffer << uint32(8524) << uint32(0);
                l_Buffer << uint32(8525) << uint32(0);
                l_Buffer << uint32(8526) << uint32(0);
                l_Buffer << uint32(8527) << uint32(0);
                l_Buffer << uint32(8528) << uint32(0);
                l_Buffer << uint32(8529) << uint32(0);
                l_Buffer << uint32(8712) << uint32(0);
                l_Buffer << uint32(8722) << uint32(0);
                l_Buffer << uint32(8859) << uint32(0);
                l_Buffer << uint32(8860) << uint32(0);
                l_Buffer << uint32(8861) << uint32(0);
                l_Buffer << uint32(8862) << uint32(0);
                l_Buffer << uint32(8863) << uint32(1);
                l_Buffer << uint32(8890) << uint32(0);
                l_Buffer << uint32(8892) << uint32(0);
                l_Buffer << uint32(8911) << uint32(10);
                l_Buffer << uint32(8933) << uint32(65);
                l_Buffer << uint32(8934) << uint32(5);
                l_Buffer << uint32(8935) << uint32(1);
                l_Buffer << uint32(8938) << uint32(0);
                l_Buffer << uint32(8945) << uint32(time(NULL));
                l_Buffer << uint32(8946) << uint32(0);
                l_Buffer << uint32(8949) << uint32(1);
                l_Buffer << uint32(8950) << uint32(0);
                l_Buffer << uint32(8955) << uint32(0);
            }
            break;
        /// - Kotmogu Temple BG
        case 6051:
        {
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_KT)
                bg->FillInitialWorldStates(l_Buffer);
            break;
        }
        ///< Upper Blackrock Spire
        case 7307:
        {
            if (instance && mapid == 1358)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(9524) << uint32(0);              // WorldStateChickenTimer
                l_Buffer << uint32(9523) << uint32(0);              // WorldStateEnableChicken
            }

            break;
        }
        /// Highmaul
        case 6996:
        {
            if (instance && mapid == 1228)
                instance->FillInitialWorldStates(l_Buffer);
            else
            {
                l_Buffer << uint32(9722) << uint32(0); /// Iron Bombers - activation
                l_Buffer << uint32(9723) << uint32(0); /// Iron Bombers remaining
                l_Buffer << uint32(9724) << uint32(0); /// Drunken Bileslinger - activation
                l_Buffer << uint32(9725) << uint32(0); /// Drunken Bileslinger remaining
            }

            break;
        }
        case 7107:
        {
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TARRENMILL)
                pvp->FillInitialWorldStates(l_Buffer);
            break;
        }
        default:
            l_Buffer << uint32(0x914) << uint32(0x0);           // 7
            l_Buffer << uint32(0x913) << uint32(0x0);           // 8
            l_Buffer << uint32(0x912) << uint32(0x0);           // 9
            l_Buffer << uint32(0x915) << uint32(0x0);           // 10
            break;
    }

    uint32 l_WorldStateCount = l_Buffer.size() / 8;
    l_Buffer.rpos(0);

    for (uint32 l_I = 0; l_I < l_WorldStateCount; ++l_I)
    {
        uint32 l_Field, l_Value;
        l_Buffer >> l_Field >> l_Value;

        SetWorldState(l_Field, l_Value);
    }

    WorldPacket data(SMSG_INIT_WORLD_STATES, 4 + 4 + 4 + 4 + l_Buffer.size());
    data << uint32(mapid);                                  // mapid
    data << uint32(zoneid);                                 // zone id
    data << uint32(areaid);                                 // area id, new 2.1.0
    data << uint32(l_WorldStateCount);
    data.append(l_Buffer);

    GetSession()->SendPacket(&data);

    SendBGWeekendWorldStates();
}

void Player::SendBGWeekendWorldStates()
{
    for (uint32 i = 1; i < sBattlemasterListStore.GetNumRows(); ++i)
    {
        BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(i);
        if (bl && bl->HolidayWorldState)
        {
            if (MS::Battlegrounds::BattlegroundMgr::IsBGWeekend((BattlegroundTypeId)bl->ID))
                SendUpdateWorldState(bl->HolidayWorldState, 1);
            else
                SendUpdateWorldState(bl->HolidayWorldState, 0);
        }
    }
}

uint32 Player::GetXPRestBonus(uint32 xp)
{
    uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus

    if (rested_bonus > xp)                                   // max rested_bonus == xp or (r+x) = 200% xp
        rested_bonus = xp;

    SetRestBonus(GetRestBonus() - rested_bonus);

    sLog->outInfo(LOG_FILTER_PLAYER, "Player gain %u xp (+ %u Rested Bonus). Rested points=%f", xp+rested_bonus, rested_bonus, GetRestBonus());
    return rested_bonus;
}

void Player::SetBindPoint(uint64 p_Guid)
{
    WorldPacket l_Data(SMSG_BINDER_CONFIRM, 2 + 16);
    l_Data.appendPackGUID(p_Guid);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendTalentWipeConfirm(uint64 guid, bool specialization)
{
    uint32 cost = 0;

    if (!specialization)
        cost = sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) ? 0 : GetNextResetTalentsCost();
    else
        cost = sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) ? 0 : GetNextResetSpecializationCost();

    cost = cost > MAX_TALENT_WIPE_COST ? MAX_TALENT_WIPE_COST : cost;

    WorldPacket data(SMSG_RESPEC_WIPE_CONFIRM);

    data << uint8(specialization); // 0 : talent 1 : specialization
    data << uint32(cost);
    data.appendPackGUID(guid);

    GetSession()->SendPacket(&data);
}

/*********************************************************/
/***                    STORAGE SYSTEM                 ***/
/*********************************************************/
void Player::SetVirtualItemSlot(uint8 i, Item* item)
{
    ASSERT(i < 3);
    if (i < 2 && item)
    {
        if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
            return;
        uint32 charges = item->GetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT);
        if (charges == 0)
            return;
        if (charges > 1)
            item->SetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT, charges-1);
        else if (charges <= 1)
        {
            ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
            item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
        }
    }
}

void Player::SetSheath(SheathState sheathed)
{
    switch (sheathed)
    {
        case SHEATH_STATE_UNARMED:                          // no prepared weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_MELEE:                            // prepared melee weapon
            SetVirtualItemSlot(0, GetWeaponForAttack(WeaponAttackType::BaseAttack, true));
            SetVirtualItemSlot(1, GetWeaponForAttack(WeaponAttackType::OffAttack, true));
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_RANGED:                           // prepared ranged weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, GetWeaponForAttack(WeaponAttackType::RangedAttack, true));
            break;
        default:
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
    }

    Unit::SetSheath(sheathed);                              // this must visualize Sheath changing for other players...
}

uint8 Player::GetGuessedEquipSlot(ItemTemplate const* proto) const
{
    switch (proto->InventoryType)
    {
        case INVTYPE_HEAD:
            return EQUIPMENT_SLOT_HEAD;
        case INVTYPE_NECK:
            return EQUIPMENT_SLOT_NECK;
        case INVTYPE_SHOULDERS:
            return EQUIPMENT_SLOT_SHOULDERS;
        case INVTYPE_BODY:
            return EQUIPMENT_SLOT_BODY;
        case INVTYPE_CHEST:
            return EQUIPMENT_SLOT_CHEST;
        case INVTYPE_ROBE:
            return EQUIPMENT_SLOT_CHEST;
        case INVTYPE_WAIST:
            return EQUIPMENT_SLOT_WAIST;
        case INVTYPE_LEGS:
            return EQUIPMENT_SLOT_LEGS;
        case INVTYPE_FEET:
            return EQUIPMENT_SLOT_FEET;
        case INVTYPE_WRISTS:
            return EQUIPMENT_SLOT_WRISTS;
        case INVTYPE_HANDS:
            return EQUIPMENT_SLOT_HANDS;
        case INVTYPE_FINGER:
            return EQUIPMENT_SLOT_FINGER1;
        case INVTYPE_TRINKET:
            return EQUIPMENT_SLOT_TRINKET1;
        case INVTYPE_CLOAK:
            return EQUIPMENT_SLOT_BACK;
        case INVTYPE_WEAPON:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_SHIELD:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_RANGED:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_2HWEAPON:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_TABARD:
            return EQUIPMENT_SLOT_TABARD;
        case INVTYPE_WEAPONMAINHAND:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_WEAPONOFFHAND:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_HOLDABLE:
            return EQUIPMENT_SLOT_OFFHAND;
        case INVTYPE_THROWN:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_RANGEDRIGHT:
            return EQUIPMENT_SLOT_MAINHAND;
        case INVTYPE_BAG:
            return INVENTORY_SLOT_BAG_START;
        default:
            return NULL_SLOT;
    }
}

uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) const
{
    uint8 playerClass = getClass();

    uint8 slots[4];
    slots[0] = NULL_SLOT;
    slots[1] = NULL_SLOT;
    slots[2] = NULL_SLOT;
    slots[3] = NULL_SLOT;
    switch (proto->InventoryType)
    {
        case INVTYPE_HEAD:
            slots[0] = EQUIPMENT_SLOT_HEAD;
            break;
        case INVTYPE_NECK:
            slots[0] = EQUIPMENT_SLOT_NECK;
            break;
        case INVTYPE_SHOULDERS:
            slots[0] = EQUIPMENT_SLOT_SHOULDERS;
            break;
        case INVTYPE_BODY:
            slots[0] = EQUIPMENT_SLOT_BODY;
            break;
        case INVTYPE_CHEST:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_ROBE:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_WAIST:
            slots[0] = EQUIPMENT_SLOT_WAIST;
            break;
        case INVTYPE_LEGS:
            slots[0] = EQUIPMENT_SLOT_LEGS;
            break;
        case INVTYPE_FEET:
            slots[0] = EQUIPMENT_SLOT_FEET;
            break;
        case INVTYPE_WRISTS:
            slots[0] = EQUIPMENT_SLOT_WRISTS;
            break;
        case INVTYPE_HANDS:
            slots[0] = EQUIPMENT_SLOT_HANDS;
            break;
        case INVTYPE_FINGER:
            slots[0] = EQUIPMENT_SLOT_FINGER1;
            slots[1] = EQUIPMENT_SLOT_FINGER2;
            break;
        case INVTYPE_TRINKET:
            slots[0] = EQUIPMENT_SLOT_TRINKET1;
            slots[1] = EQUIPMENT_SLOT_TRINKET2;
            break;
        case INVTYPE_CLOAK:
            slots[0] = EQUIPMENT_SLOT_BACK;
            break;
        case INVTYPE_WEAPON:
        {
            slots[0] = EQUIPMENT_SLOT_MAINHAND;

            // suggest offhand slot only if know dual wielding
            // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
            if (CanDualWield())
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        }
        case INVTYPE_SHIELD:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_RANGED:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            /*if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (!CanTitanGrip() && mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (!CanTitanGrip() && proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }*/
            break;
        case INVTYPE_2HWEAPON:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
           /* if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }*/
            if (CanDualWield() && CanTitanGrip() && proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_TABARD:
            slots[0] = EQUIPMENT_SLOT_TABARD;
            break;
        case INVTYPE_WEAPONMAINHAND:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            break;
        case INVTYPE_WEAPONOFFHAND:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_HOLDABLE:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_THROWN:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            /*if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }*/
            break;
        case INVTYPE_RANGEDRIGHT:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            /*if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }*/
            break;
        case INVTYPE_BAG:
            slots[0] = INVENTORY_SLOT_BAG_START + 0;
            slots[1] = INVENTORY_SLOT_BAG_START + 1;
            slots[2] = INVENTORY_SLOT_BAG_START + 2;
            slots[3] = INVENTORY_SLOT_BAG_START + 3;
            break;
        case INVTYPE_RELIC:
        {
           if (playerClass == CLASS_PALADIN || playerClass == CLASS_DRUID ||
               playerClass == CLASS_SHAMAN || playerClass == CLASS_DEATH_KNIGHT)
           {
               slots[0] = EQUIPMENT_SLOT_MAINHAND;
               /*if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
               {
                   if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                   {
                       if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                       {
                           const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                           break;
                       }
                   }
               }

               if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
               {
                   if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                   {
                       const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                       break;
                   }
               }*/
           }
           break;
        }
        default:
            return NULL_SLOT;
    }

    if (slot != NULL_SLOT)
    {
        if (swap || !GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
            for (uint8 i = 0; i < 4; ++i)
                if (slots[i] == slot)
                    return slot;
    }
    else
    {
        // search free slot at first
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && !GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]))
                // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
                if (slots[i] != EQUIPMENT_SLOT_OFFHAND || !IsTwoHandUsed())
                    return slots[i];

        // if not found free and can swap return first appropriate from used
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && swap)
                return slots[i];
    }

    // no free position
    return NULL_SLOT;
}

InventoryResult Player::CanUnequipItems(uint32 item, uint32 count) const
{
    uint32 tempcount = 0;

    InventoryResult res = EQUIP_ERR_OK;

    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                InventoryResult ires = CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false);
                if (ires == EQUIP_ERR_OK)
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return EQUIP_ERR_OK;
                }
                else
                    res = ires;
            }

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }


    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = GetItemByPos(i, j))
                    if (pItem->GetEntry() == item)
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return EQUIP_ERR_OK;
                    }

    // not found req. item count and have unequippable items
    return res;
}

uint32 Player::GetItemCount(uint32 item, bool inBankAlso, Item* skipItem) const
{
    uint32 count = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCount(item, skipItem);

    if (skipItem && skipItem->GetTemplate()->GemProperties)
        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                    count += pItem->GetGemCountWithID(item);

    if (inBankAlso)
    {
        // checking every item from 39 to 74 (including bank bags)
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                count += pBag->GetItemCount(item, skipItem);

        if (skipItem && skipItem->GetTemplate()->GemProperties)
            for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
                if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                        count += pItem->GetGemCountWithID(item);
    }

    return count;
}

uint32 Player::GetItemCountWithLimitCategory(uint32 limitCategory, Item* skipItem) const
{
    uint32 count = 0;
    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    return count;
}

Item* Player::GetItemByGuid(uint64 guid) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;
		
    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;
		
    for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    return NULL;
}

Item* Player::GetItemByPos(uint16 pos) const
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    return GetItemByPos(bag, slot);
}

Item* Player::GetItemByPos(uint8 bag, uint8 slot) const
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot < REAGENT_BANK_SLOT_BAG_END))
        return m_items[slot];
    else if (Bag* pBag = GetBagByPos(bag))
        return pBag->GetItemByPos(slot);

    return NULL;
}

Bag* Player::GetBagByPos(uint8 bag) const
{
    if ((bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        || (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END))
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
            return item->ToBag();
    return NULL;
}

Item* Player::GetWeaponForAttack(WeaponAttackType attackType, bool useable /*= false*/) const
{
    uint8 slot;
    switch (attackType)
    {
        case WeaponAttackType::BaseAttack:   slot = EQUIPMENT_SLOT_MAINHAND; break;
        case WeaponAttackType::OffAttack:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
        case WeaponAttackType::RangedAttack: slot = EQUIPMENT_SLOT_MAINHAND;   break;
        default: return NULL;
    }

    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_WEAPON)
        return NULL;

    if (!useable)
        return item;

    if (item->CantBeUse() || IsInFeralForm())
        return NULL;

    return item;
}

Item* Player::GetShield(bool useable) const
{
    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_ARMOR)
        return NULL;

    if (!useable)
        return item;

    if (item->CantBeUse())
        return NULL;

    return item;
}

uint8 Player::GetAttackBySlot(uint8 slot)
{
    switch (slot)
    {
        case EQUIPMENT_SLOT_MAINHAND: return WeaponAttackType::BaseAttack;
        case EQUIPMENT_SLOT_OFFHAND:  return WeaponAttackType::OffAttack;
        default:                      return WeaponAttackType::MaxAttack;
    }
}

bool Player::IsInventoryPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot == NULL_SLOT)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END))
        return true;
    if (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsEquipmentPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot < EQUIPMENT_SLOT_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    if (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsReagentBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= REAGENT_BANK_SLOT_BAG_START && slot < REAGENT_BANK_SLOT_BAG_END))
        return true;
    if (bag >= REAGENT_BANK_SLOT_BAG_START && bag < REAGENT_BANK_SLOT_BAG_END)
        return true;

    return false;
}

bool Player::IsBagPos(uint16 pos)
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsValidPos(uint8 bag, uint8 slot, bool explicit_pos)
{
    // post selected
    if (bag == NULL_BAG && !explicit_pos)
        return true;

    if (bag == INVENTORY_SLOT_BAG_0)
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        // equipment
        if (slot < EQUIPMENT_SLOT_END)
            return true;

        // bag equip slots
        if (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END)
            return true;

        // backpack slots
        if (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END)
            return true;

        // bank main slots
        if (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END)
            return true;

        // bank bag slots
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
            return true;

        // reagent bank bag slots
        if (slot >= REAGENT_BANK_SLOT_BAG_START && slot < REAGENT_BANK_SLOT_BAG_END)
            return true;

        return false;
    }

    // bag content slots
    // bank bag content slots
    if (Bag* pBag = GetBagByPos(bag))
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        return slot < pBag->GetBagSize();
    }

    // where this?
    return false;
}

bool Player::HasItemCount(uint32 item, uint32 count, bool inBankAlso, bool inReagentBank) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* pItem = GetItemByPos(i, j);
                if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return true;
                }
            }
        }
    }

    if (inBankAlso)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return true;
            }
        }
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            if (Bag* pBag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                {
                    Item* pItem = GetItemByPos(i, j);
                    if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return true;
                    }
                }
            }
        }
    }

    if (inBankAlso || inReagentBank)
    {
        for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return true;
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithIdEquipped(uint32 item, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (pProto && pProto->GemProperties)
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (i == except_slot)
                continue;

            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetTemplate()->Socket[0].Color)
            {
                tempcount += pItem->GetGemCountWithID(item);
                if (tempcount >= count)
                    return true;
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithLimitCategoryEquipped(uint32 limitCategory, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (!pItem)
            continue;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (!pProto)
            continue;

        if (pProto->ItemLimitCategory == limitCategory)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }

        if (pProto->Socket[0].Color || pItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
        {
            tempcount += pItem->GetGemCountWithLimitCategory(limitCategory);
            if (tempcount >= count)
                return true;
        }
    }

    return false;
}

InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count) const
{
    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    if (pItem && pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // no maximum
    if ((pProto->MaxCount <= 0 && pProto->ItemLimitCategory == 0) || pProto->MaxCount == 2147483647)
        return EQUIP_ERR_OK;

    if (pProto->MaxCount > 0)
    {
        uint32 curcount = GetItemCount(pProto->ItemId, true, pItem);
        if (curcount + count > uint32(pProto->MaxCount))
        {
            if (no_space_count)
                *no_space_count = count + curcount - pProto->MaxCount;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // check unique-equipped limit
    if (pProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(pProto->ItemLimitCategory);
        if (!limitEntry)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_EQUIPPABLE;
        }

        if (limitEntry->mode == ITEM_LIMIT_CATEGORY_MODE_HAVE)
        {
            uint32 curcount = GetItemCountWithLimitCategory(pProto->ItemLimitCategory, pItem);
            if (curcount + count > uint32(limitEntry->maxCount))
            {
                if (no_space_count)
                    *no_space_count = count + curcount - limitEntry->maxCount;
                return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS;
            }
        }
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const
{
    Item* pItem2 = GetItemByPos(bag, slot);

    // ignore move item (this slot will be empty at move)
    if (pItem2 == pSrcItem)
        pItem2 = NULL;

    uint32 need_space;

    if (pSrcItem && pSrcItem->IsNotEmptyBag() && !IsBagPos(uint16(bag) << 8 | slot))
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    // empty specific slot - check item fit to slot
    if (!pItem2 || swap)
    {
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            // prevent cheating
            if ((slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END) || slot >= PLAYER_SLOT_END)
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }
        else
        {
            Bag* pBag = GetBagByPos(bag);
            if (!pBag)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            ItemTemplate const* pBagProto = pBag->GetTemplate();
            if (!pBagProto)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (slot >= pBagProto->ContainerSlots)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (!ItemCanGoIntoBag(pProto, pBagProto))
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }

        // non empty stack with space
        need_space = pProto->GetMaxStackSize();
    }
    // non empty slot, check item type
    else
    {
        // can be merged at least partly
        InventoryResult res  = pItem2->CanBeMergedPartlyWith(pProto);
        if (res != EQUIP_ERR_OK)
            return res;

        // free stack space or infinity
        need_space = pProto->GetMaxStackSize() - pItem2->GetCount();
    }

    if (need_space > count)
        need_space = count;

    ItemPosCount newPosition = ItemPosCount((bag << 8) | slot, need_space);
    if (!newPosition.isContainedIn(dest))
    {
        dest.push_back(newPosition);
        count -= need_space;
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InBag(uint8 bag, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    // skip specific bag already processed in first called CanStoreItem_InBag
    if (bag == skip_bag)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // skip not existed bag or self targeted bag
    Bag* pBag = GetBagByPos(bag);
    if (!pBag || pBag == pSrcItem)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    ItemTemplate const* pBagProto = pBag->GetTemplate();
    if (!pBagProto)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // specialized bag mode or non-specilized
    if (non_specialized != (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (!ItemCanGoIntoBag(pProto, pBagProto))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    for (uint32 j = 0; j < pBag->GetBagSize(); j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(bag, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((bag << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 slot_end, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    //this is never called for non-bag slots so we can do this
    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    for (uint32 j = slot_begin; j < slot_end; j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (INVENTORY_SLOT_BAG_0 == skip_bag && j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((INVENTORY_SLOT_BAG_0 << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count) const
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, entry, count);

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return swap ? EQUIP_ERR_CANT_SWAP :EQUIP_ERR_ITEM_NOT_FOUND;
    }

    if (pItem)
    {
        // item used
        if (pItem->m_lootGenerated)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_LOOT_GONE;
        }

        if (pItem->IsBindedNotWith(this))
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_OWNER;
        }
    }

    // check count of items (skip for auto move for same player from bank)
    uint32 no_similar_count = 0;                            // can't store this amount similar items
    InventoryResult res = CanTakeMoreSimilarItems(entry, count, pItem, &no_similar_count);
    if (res != EQUIP_ERR_OK)
    {
        if (count == no_similar_count)
        {
            if (no_space_count)
                *no_space_count = no_similar_count;
            return res;
        }
        count -= no_similar_count;
    }

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)               // inventory
            {
                res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            else                                            // equipped bag
            {
                // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        // search free slot in bag for place to
        if (bag == INVENTORY_SLOT_BAG_0)                     // inventory
        {
            res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
        else                                                // equipped bag
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        if (pProto->BagFamily)
        {
            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // search free slot - special bag case
    if (pProto->BagFamily)
    {
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    if (pItem && pItem->IsNotEmptyBag())
        return EQUIP_ERR_BAG_IN_BAG;

    // search free slot
    res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
    {
        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return res;
    }

    if (count == 0)
    {
        if (no_similar_count == 0)
            return EQUIP_ERR_OK;

        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    if (no_space_count)
        *no_space_count = count + no_similar_count;

    return EQUIP_ERR_INV_FULL;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanStoreItems(Item** pItems, int count) const
{
    Item* pItem2;

    // fill space table
    int inv_slot_items[INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START];
    int inv_bags[INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START][MAX_BAG_SIZE];

    memset(inv_slot_items, 0, sizeof(int) * (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));
    memset(inv_bags, 0, sizeof(int) * (INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START) * MAX_BAG_SIZE);

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->IsInTrade())
            inv_slot_items[i - INVENTORY_SLOT_ITEM_START] = pItem2->GetCount();
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                pItem2 = GetItemByPos(i, j);
                if (pItem2 && !pItem2->IsInTrade())
                    inv_bags[i - INVENTORY_SLOT_BAG_START][j] = pItem2->GetCount();
            }

    // check free space for all items
    for (int k = 0; k < count; ++k)
    {
        Item* pItem = pItems[k];

        // no item
        if (!pItem)
            continue;

        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItems %i. item = %u, count = %u", k + 1, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();

        // strange item
        if (!pProto)
            return EQUIP_ERR_ITEM_NOT_FOUND;

        // item used
        if (pItem->m_lootGenerated)
            return EQUIP_ERR_LOOT_GONE;

        // item it 'bind'
        if (pItem->IsBindedNotWith(this))
            return EQUIP_ERR_NOT_OWNER;

        ItemTemplate const* pBagProto;

        // item is 'one item only'
        InventoryResult res = CanTakeMoreSimilarItems(pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        // search stack for merge to
        if (pProto->Stackable != 1)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
            {
                pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, t);
                if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_slot_items[t-INVENTORY_SLOT_ITEM_START] + pItem->GetCount() <= pProto->GetMaxStackSize())
                {
                    inv_slot_items[t-INVENTORY_SLOT_ITEM_START] += pItem->GetCount();
                    b_found = true;
                    break;
                }
            }
            if (b_found)
                continue;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    if (ItemCanGoIntoBag(pItem->GetTemplate(), bag->GetTemplate()))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            pItem2 = GetItemByPos(t, j);
                            if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_bags[t-INVENTORY_SLOT_BAG_START][j] + pItem->GetCount() <= pProto->GetMaxStackSize())
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] += pItem->GetCount();
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // special bag case
        if (pProto->BagFamily)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    pBagProto = bag->GetTemplate();

                    // not plain container check
                    if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER) &&
                        ItemCanGoIntoBag(pProto, pBagProto))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // search free slot
        bool b_found = false;
        for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
        {
            if (inv_slot_items[t-INVENTORY_SLOT_ITEM_START] == 0)
            {
                inv_slot_items[t-INVENTORY_SLOT_ITEM_START] = 1;
                b_found = true;
                break;
            }
        }
        if (b_found)
            continue;

        // search free slot in bags
        for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
        {
            if (Bag* bag = GetBagByPos(t))
            {
                pBagProto = bag->GetTemplate();

                // special bag already checked
                if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER))
                    continue;

                for (uint32 j = 0; j < bag->GetBagSize(); j++)
                {
                    if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                    {
                        inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                        b_found = true;
                        break;
                    }
                }
            }
        }

        // no free slot found?
        if (!b_found)
            return EQUIP_ERR_INV_FULL;
    }

    return EQUIP_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanEquipNewItem(uint8 slot, uint16 &dest, uint32 item, bool swap) const
{
    dest = 0;
    Item* pItem = Item::CreateItem(item, 1, this);
    if (pItem)
    {
        InventoryResult result = CanEquipItem(slot, dest, pItem, swap);
        delete pItem;
        return result;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool swap, bool not_loading) const
{
    dest = 0;
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanEquipItem slot = %u, item = %u, count = %u", slot, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            // item used
            if (pItem->m_lootGenerated)
                return EQUIP_ERR_LOOT_GONE;

            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            // check count of items (skip for auto move for same player from bank)
            InventoryResult res = CanTakeMoreSimilarItems(pItem);
            if (res != EQUIP_ERR_OK)
                return res;

            // check this only in game
            if (not_loading)
            {
                // May be here should be more stronger checks; STUNNED checked
                // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
                if (HasUnitState(UNIT_STATE_STUNNED))
                    return EQUIP_ERR_GENERIC_STUNNED;

                // do not allow equipping gear except weapons, offhands, projectiles, relics in
                // - combat
                // - in-progress arenas
                if (!pProto->CanChangeEquipStateInCombat())
                {
                    if (isInCombat())
                        return EQUIP_ERR_NOT_IN_COMBAT;

                    if (Battleground* bg = GetBattleground())
                        if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                            return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
                }

                if (pProto->Class == ITEM_CLASS_WEAPON && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;

                if (isInCombat()&& (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer != 0)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;         // maybe exist better err

                if (IsNonMeleeSpellCasted(false))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }

            uint8 eslot = FindEquipSlot(pProto, slot, swap);
            if (eslot == NULL_SLOT)
                return EQUIP_ERR_NOT_EQUIPPABLE;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;

            if (!swap && GetItemByPos(INVENTORY_SLOT_BAG_0, eslot))
                return EQUIP_ERR_NO_SLOT_AVAILABLE;

            // if swap ignore item (equipped also)
            InventoryResult res2 = CanEquipUniqueItem(pItem, swap ? eslot : uint8(NULL_SLOT));
            if (res2 != EQUIP_ERR_OK)
                return res2;

            // check unique-equipped special item classes
            if (pProto->Class == ITEM_CLASS_QUIVER)
                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
                    if (Item* pBag = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                        if (pBag != pItem)
                            if (ItemTemplate const* pBagProto = pBag->GetTemplate())
                                if (pBagProto->Class == pProto->Class && (!swap || pBag->GetSlot() != eslot))
                                    return (pBagProto->SubClass == ITEM_SUBCLASS_AMMO_POUCH)
                                        ? EQUIP_ERR_ONLY_ONE_AMMO
                                        : EQUIP_ERR_ONLY_ONE_QUIVER;

            uint32 type = pProto->InventoryType;

            if (eslot == EQUIPMENT_SLOT_OFFHAND)
            {
                // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
                if (type == INVTYPE_WEAPON && pProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
                    return EQUIP_ERR_2HSKILLNOTFOUND;
                else if (type == INVTYPE_WEAPON || type == INVTYPE_WEAPONOFFHAND)
                {
                    if (!CanDualWield())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_2HWEAPON)
                {
                    if (!CanDualWield() || !CanTitanGrip())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }

                if (IsTwoHandUsed())
                    return EQUIP_ERR_2HANDED_EQUIPPED;
            }

            // equip two-hand weapon case (with possible unequip 2 items)
            /// Ranged weapons are two hands weapons since MoP
            if (type == INVTYPE_2HWEAPON || type == INVTYPE_RANGEDRIGHT)
            {
                if (eslot == EQUIPMENT_SLOT_OFFHAND)
                {
                    if (!CanTitanGrip())
                        return EQUIP_ERR_NOT_EQUIPPABLE;
                }
                else if (eslot != EQUIPMENT_SLOT_MAINHAND)
                    return EQUIP_ERR_NOT_EQUIPPABLE;

                if (!CanTitanGrip())
                {
                    // offhand item must can be stored in inventory for offhand item and it also must be unequipped
                    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                    ItemPosCountVec off_dest;
                    if (offItem && (!not_loading ||
                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
                        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_INV_FULL;
                }
            }
            dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
            return EQUIP_ERR_OK;
        }
    }

    return !swap ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_CANT_SWAP;
}

InventoryResult Player::CanUnequipItem(uint16 pos, bool swap) const
{
    // Applied only to equipped items and bank bags
    if (!IsEquipmentPos(pos) && !IsBagPos(pos))
        return EQUIP_ERR_OK;

    Item* pItem = GetItemByPos(pos);

    // Applied only to existed equipped item
    if (!pItem)
        return EQUIP_ERR_OK;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUnequipItem slot = %u, item = %u, count = %u", pos, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // do not allow unequipping gear except weapons, offhands, projectiles, relics in
    // - combat
    // - in-progress arenas
    if (!pProto->CanChangeEquipStateInCombat())
    {
        if (isInCombat())
            return EQUIP_ERR_NOT_IN_COMBAT;

        if (Battleground* bg = GetBattleground())
            if (bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
    }

    if ((pProto->Class & ITEM_CLASS_WEAPON) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
        return EQUIP_ERR_CLIENT_LOCKED_OUT;

    if (!swap && pItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());
    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // Currency tokens are not supposed to be swapped out of their hidden bag
    if (pItem->IsCurrencyToken())
    {
        sLog->outError(LOG_FILTER_PLAYER, "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
                GetName(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->ItemId);
        return EQUIP_ERR_CANT_SWAP;
    }

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);
    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
        {
            if (!pItem->IsBag())
                return EQUIP_ERR_WRONG_SLOT;

            if (slot - BANK_SLOT_BAG_START >= GetBankBagSlotCount())
                return EQUIP_ERR_NO_BANK_SLOT;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;
        }

        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        if (pItem->IsNotEmptyBag())
            return EQUIP_ERR_BAG_IN_BAG;

        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)
            {
                res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
            else
            {
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        // search free slot in bag
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
        else
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;

        // in special bags
        if (pProto->BagFamily)
        {
            for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free place in special bag
    if (pProto->BagFamily)
    {
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free space
    res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
            return EQUIP_ERR_OK;
    }
    return EQUIP_ERR_BANK_FULL;
}

bool Player::IsItemSupplies(ItemTemplate const *p_BagProto) const
{
    switch (p_BagProto->SubClass)
    {
        case ITEM_SUBCLASS_HERB_CONTAINER:
        case ITEM_SUBCLASS_ENGINEERING_CONTAINER:
        case ITEM_SUBCLASS_GEM_CONTAINER:
        case ITEM_SUBCLASS_ENCHANTING_CONTAINER:
        case ITEM_SUBCLASS_MINING_CONTAINER:
        case ITEM_SUBCLASS_LEATHERWORKING_CONTAINER:
        case ITEM_SUBCLASS_INSCRIPTION_CONTAINER:
        case ITEM_SUBCLASS_TACKLE_CONTAINER:
        case ITEM_SUBCLASS_COOKING_CONTAINER:
        case ITEM_SUBCLASS_ENCHANTING_CONTAINER_2:
        case ITEM_SUBCLASS_MATERIALS_CONTAINER:
        case ITEM_SUBCLASS_ITEM_ENCHANTMENT_CONTAINER:
        case ITEM_SUBCLASS_WEAPON_ENCHANTMENT_CONTAINER:
            return true;
    }
    return false;
}

InventoryResult Player::CanReagentBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanReagentBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    if ((pProto->Flags2 & ITEM_FLAG2_CRAFTING_MATERIAL) == 0)
        return EQUIP_ERR_WRONG_SLOT;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);

    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);

        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, true, pItem, bag, slot);

        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // search free space
    res = CanStoreItem_InInventorySlots(REAGENT_BANK_SLOT_BAG_START, REAGENT_BANK_SLOT_BAG_END, dest, pProto, count, false, pItem, bag, slot);

    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    return EQUIP_ERR_BANK_FULL;
}

InventoryResult Player::CanUseItem(Item* pItem, bool not_loading) const
{
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUseItem item = %u", pItem->GetEntry());

        if (!isAlive() && not_loading)
            return EQUIP_ERR_PLAYER_DEAD;

        //if (isStunned())
        //    return EQUIP_ERR_GENERIC_STUNNED;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            InventoryResult res = CanUseItem(pProto);
            if (res != EQUIP_ERR_OK)
                return res;

            if (pItem->GetSkill() != 0)
            {
                bool allowEquip = false;
                uint32 itemSkill = pItem->GetSkill();
                // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
                if (pProto->Quality == ITEM_QUALITY_HEIRLOOM && pProto->Class == ITEM_CLASS_ARMOR && !HasSkill(itemSkill))
                {
                    // TODO: when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.

                    // In fact it's a visual bug, everything works properly... I need sniffs of operations with
                    // binded to account items from off server.

                    switch (getClass())
                    {
                        case CLASS_HUNTER:
                        case CLASS_SHAMAN:
                            allowEquip = (itemSkill == SKILL_MAIL);
                            break;
                        case CLASS_PALADIN:
                        case CLASS_WARRIOR:
                            allowEquip = (itemSkill == SKILL_PLATE_MAIL);
                            break;
                    }
                }
                if (!allowEquip && GetSkillValue(itemSkill) == 0)
                    return EQUIP_ERR_PROFICIENCY_NEEDED;
            }

            if (pProto->RequiredReputationFaction && uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank)
                return EQUIP_ERR_CANT_EQUIP_REPUTATION;

            return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
{
    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player

    if (proto)
    {
        if ((proto->Flags2 & ITEM_FLAG2_HORDE_ONLY) && GetTeam() != HORDE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->Flags2 & ITEM_FLAG2_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if (proto->RequiredSkill != 0)
        {
            if (GetSkillValue(proto->RequiredSkill) == 0)
                return EQUIP_ERR_PROFICIENCY_NEEDED;
            else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
                return EQUIP_ERR_CANT_EQUIP_SKILL;
        }

        if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
            return EQUIP_ERR_PROFICIENCY_NEEDED;

        if (getLevel() < proto->RequiredLevel)
            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;

        // If World Event is not active, prevent using event dependant items
        if (proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
            return EQUIP_ERR_CLIENT_LOCKED_OUT;

        return EQUIP_ERR_OK;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanRollForItemInLFG(ItemTemplate const* proto, WorldObject const* lootedObject) const
{
    LfgDungeonSet const& dungeons = sLFGMgr->GetSelectedDungeons(GetGUID());
    if (dungeons.empty())
        return EQUIP_ERR_OK;    // not using LFG

    if (!GetGroup() || !GetGroup()->isLFGGroup())
        return EQUIP_ERR_OK;    // not in LFG group

    // check if looted object is inside the lfg dungeon
    bool lootedObjectInDungeon = false;
    Map const* map = lootedObject->GetMap();
    if (uint32 dungeonId = sLFGMgr->GetDungeon(GetGroup()->GetGUID(), true))
        if (LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId))
            if (uint32(dungeon->map) == map->GetId() && dungeon->difficulty == uint32(map->GetDifficultyID()))
                lootedObjectInDungeon = true;

    if (!lootedObjectInDungeon)
        return EQUIP_ERR_OK;

    if (!proto)
        return EQUIP_ERR_ITEM_NOT_FOUND;
   // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player

    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
    {
        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
        SKILL_STAVES,   0,              0,                   SKILL_FIST_WEAPONS,   0,
        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
        SKILL_FISHING
    }; //Copy from function Item::GetSkill()

    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
        return EQUIP_ERR_CANT_EQUIP_EVER;

    if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->RequiredSkill != 0)
    {
        if (!GetSkillValue(proto->RequiredSkill))
            return EQUIP_ERR_PROFICIENCY_NEEDED;
        else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
            return EQUIP_ERR_CANT_EQUIP_SKILL;
    }

    uint8 _class = getClass();

    if (proto->Class == ITEM_CLASS_WEAPON && GetSkillValue(item_weapon_skills[proto->SubClass]) == 0)
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass > ITEM_SUBCLASS_ARMOR_MISCELLANEOUS && proto->SubClass < ITEM_SUBCLASS_ARMOR_COSMETIC && proto->InventoryType != INVTYPE_CLOAK)
    {
        if (_class == CLASS_WARRIOR || _class == CLASS_PALADIN || _class == CLASS_DEATH_KNIGHT)
        {
            if (getLevel() < 40)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }
        else if (_class == CLASS_HUNTER || _class == CLASS_SHAMAN)
        {
            if (getLevel() < 40)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }

        if (_class == CLASS_ROGUE || _class == CLASS_DRUID)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;

        if (_class == CLASS_MAGE || _class == CLASS_PRIEST || _class == CLASS_WARLOCK)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_CLOTH)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
    }

    return EQUIP_ERR_OK;
}

Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId)
{
    AllowedLooterSet allowedLooters;
    return StoreNewItem(dest, item, update, randomPropertyId, allowedLooters);
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId, AllowedLooterSet& allowedLooters)
{
    uint32 count = 0;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end(); ++itr)
        count += itr->count;

    Item* pItem = Item::CreateItem(item, count, this);
    if (pItem)
    {
        ItemAddedQuestCheck(item, count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, 1);
        if (randomPropertyId)
            pItem->SetItemRandomProperties(randomPropertyId);
        pItem = StoreItem(dest, pItem, update);

        if (pItem->GetTemplate()->Quality == ITEM_QUALITY_HEIRLOOM)
            if (HeirloomEntry const* l_HeirloomEntry = GetHeirloomEntryByItemID(pItem->GetTemplate()->ItemId))
                AddHeirloom(l_HeirloomEntry, pItem->HasCustomFlags(ItemCustomFlags::FromStore));

        if (allowedLooters.size() > 1 && pItem->GetTemplate()->GetMaxStackSize() == 1 && pItem->IsSoulBound())
        {
            pItem->SetSoulboundTradeable(allowedLooters);
            pItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());
            AddTradeableItem(pItem);

            // save data
            std::ostringstream ss;
            AllowedLooterSet::const_iterator itr = allowedLooters.begin();
            ss << *itr;
            for (++itr; itr != allowedLooters.end(); ++itr)
                ss << ' ' << *itr;


            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_ITEM_BOP_TRADE);
            stmt->setUInt32(0, pItem->GetRealGUIDLow());
            stmt->setString(1, ss.str());
            RealmDatabase.Execute(stmt);
        }
    }
    return pItem;
}

Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
{
    if (!pItem)
        return NULL;

    Item* lastItem = pItem;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end();)
    {
        uint16 pos = itr->pos;
        uint32 count = itr->count;

        ++itr;

        if (itr == dest.end())
        {
            lastItem = _StoreItem(pos, pItem, count, false, update);
            break;
        }

        lastItem = _StoreItem(pos, pItem, count, true, update);
    }

    UpdateItemLevel();
    return lastItem;
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::_StoreItem(uint16 pos, Item* pItem, uint32 count, bool clone, bool update)
{
    if (!pItem)
        return NULL;

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: StoreItem bag = %u, slot = %u, item = %u, count = %u, guid = %u", bag, slot, pItem->GetEntry(), count, pItem->GetGUIDLow());

    Item* pItem2 = GetItemByPos(bag, slot);
    if (!pItem2)
    {
        if (clone)
            pItem = pItem->CloneItem(count, this);
        else
            pItem->SetCount(count);

        if (!pItem)
            return NULL;

        if (pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
            pItem->SetBinding(true);

        Bag* pBag = (bag == INVENTORY_SLOT_BAG_0) ? NULL : GetBagByPos(bag);
        if (!pBag)
        {
            for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
            {
                if (m_items[i] == pItem)
                {
                    ACE_Stack_Trace trace;
                    sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
                }
            }
            m_items[slot] = pItem;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());

            pItem->SetSlot(slot);
            pItem->SetContainer(NULL);
        }
        else
            pBag->StoreItem(slot, pItem, update);

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        pItem->SetState(ITEM_CHANGED, this);
        if (pBag)
            pBag->SetState(ITEM_CHANGED, this);

        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);


        const ItemTemplate* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                    if (!HasAura(proto->Spells[i].SpellId))
                        CastSpell(this, proto->Spells[i].SpellId, true, pItem);

        return pItem;
    }
    else
    {
        if (pItem2->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem2->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem2->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)))
            pItem2->SetBinding(true);

        pItem2->SetCount(pItem2->GetCount() + count);
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        if (!clone)
        {
            if (pItem != pItem2)
            {
                // delete item (it not in any slot currently)
                if (IsInWorld() && update)
                {
                    pItem->RemoveFromWorld();
                    pItem->DestroyForPlayer(this);
                }

                RemoveEnchantmentDurations(pItem);
                RemoveItemDurations(pItem);

                pItem->SetOwnerGUID(GetGUID());                 // prevent error at next SetState in case trade/mail/buy from vendor
                pItem->SetNotRefundable(this);
                pItem->ClearSoulboundTradeable(this);
                RemoveTradeableItem(pItem);
                pItem->SetState(ITEM_REMOVED, this);
            }
        }

        AddEnchantmentDurations(pItem2);

        pItem2->SetState(ITEM_CHANGED, this);

        const ItemTemplate* proto = pItem2->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                    if (!HasAura(proto->Spells[i].SpellId))
                        CastSpell(this, proto->Spells[i].SpellId, true, pItem2);

        return pItem2;
    }
}

Item* Player::EquipNewItem(uint16 pos, uint32 item, bool update)
{
    if (Item* pItem = Item::CreateItem(item, 1, this))
    {
        ItemAddedQuestCheck(item, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, 1);
        return EquipItem(pos, pItem, update);
    }

    return NULL;
}

Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
{
    if (pItem->GetTemplate()->Flags3 & ItemFlags3::ITEM_FLAG3_WARGAME_ONLY)
    {
        if (!GetBattleground() || !GetBattleground()->IsWargame())
            pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
    }
    else if (GetBattleground() && GetBattleground()->UseTournamentRules())
        pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);

    AddEnchantmentDurations(pItem);
    AddItemDurations(pItem);

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    Item* pItem2 = GetItemByPos(bag, slot);

    if (!pItem2)
    {
        VisualizeItem(slot, pItem);

        if (isAlive())
        {
            ItemTemplate const* pProto = pItem->GetTemplate();

            // item set bonuses applied only at equip and removed at unequip, and still active for broken items
            if (pProto && pProto->ItemSet)
                AddItemsSetItem(this, pItem);

            _ApplyItemMods(pItem, slot, true);

            if (pProto && isInCombat() && (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer == 0)
            {
                uint32 cooldownSpell = getClass() == CLASS_ROGUE ? 6123 : 6119;
                SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(cooldownSpell);

                if (!spellProto)
                    sLog->outError(LOG_FILTER_PLAYER, "Weapon switch cooldown spell %u couldn't be found in Spell.dbc", cooldownSpell);
                else
                {
                    m_weaponChangeTimer = spellProto->StartRecoveryTime;

                    GetGlobalCooldownMgr().AddGlobalCooldown(spellProto, m_weaponChangeTimer);

                    WorldPacket data(SMSG_SPELL_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
                    data.appendPackGUID(GetGUID());
                    data << uint8(CooldownFlags::CooldownFlagIncludeGCD);
                    data << uint32(1);
                    data << uint32(cooldownSpell);
                    data << uint32(0);

                    GetSession()->SendPacket(&data);
                }
            }
        }

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        ApplyEquipCooldown(pItem);
    }
    else
    {
        pItem2->SetCount(pItem2->GetCount() + pItem->GetCount());
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        // delete item (it not in any slot currently)
        //pItem->DeleteFromDB();
        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetOwnerGUID(GetGUID());                     // prevent error at next SetState in case trade/mail/buy from vendor
        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);
        pItem->SetState(ITEM_REMOVED, this);
        pItem2->SetState(ITEM_CHANGED, this);

        ApplyEquipCooldown(pItem2);

        return pItem2;
    }

    // only for full equip instead adding to stack
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);

    // Custom MoP script
    // Jab Override Driver
    if (getClass() == CLASS_MONK)
    {
        Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);

        // Glyph of Jab
        if (mainItem && mainItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && !HasAura(125660))
        {
            RemoveAura(108561); // 2H Staff Override
            RemoveAura(115697); // 2H Polearm Override
            RemoveAura(115689); // D/W Axes// Way of the Monk - 120277
            RemoveAura(115694); // D/W Maces
            RemoveAura(115696); // D/W Swords

            switch (mainItem->GetTemplate()->SubClass)
            {
                case ITEM_SUBCLASS_WEAPON_STAFF:
                    CastSpell(this, 108561, true);
                    break;
                case ITEM_SUBCLASS_WEAPON_POLEARM:
                    CastSpell(this, 115697, true);
                    break;
                case ITEM_SUBCLASS_WEAPON_AXE:
                    CastSpell(this, 115689, true);
                    break;
                case ITEM_SUBCLASS_WEAPON_MACE:
                    CastSpell(this, 115694, true);
                    break;
                case ITEM_SUBCLASS_WEAPON_SWORD:
                    CastSpell(this, 115696, true);
                    break;
                default:
                    break;
            }
        }
        else if (HasAura(125660))
        {
            RemoveAura(108561); // 2H Staff Override
            RemoveAura(115697); // 2H Polearm Override
            RemoveAura(115689); // D/W Axes
            RemoveAura(115694); // D/W Maces
            RemoveAura(115696); // D/W Swords
        }
    }
    // Way of the Monk - 120277
    if (getClass() == CLASS_MONK && HasAura(120277))
    {
        RemoveAurasDueToSpell(120275);
        RemoveAurasDueToSpell(108977);

        uint32 trigger = 0;
        if (IsTwoHandUsed())
            trigger = 120275;
        else
        {
            Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
            Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
            if (mainItem && mainItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && offItem && offItem->GetTemplate()->Class == ITEM_CLASS_WEAPON)
                trigger = 108977;
        }

        if (trigger)
            CastSpell(this, trigger, true);

        UpdateRating(CR_HASTE_MELEE);
    }
    // Assassin's Resolve - 84601
    if (getClass() == CLASS_ROGUE && GetSpecializationId() == SPEC_ROGUE_ASSASSINATION)
    {
        Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
        Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

        if (((mainItem && mainItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER) || (offItem && offItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)))
        {
            if (HasAura(84601))
                RemoveAura(84601);

            CastSpell(this, 84601, true);
        }
        else
            RemoveAura(84601);
    }
    /// Single-Minded Fury - 81099
    if (getClass() == CLASS_WARRIOR && GetSpecializationId() == SPEC_WARRIOR_FURY)
    {
        if (HasAura(81099))
        {
            RemoveAura(81099);
            AddAura(81099, this);
        }
        if (HasAura(23588))
        {
            RemoveAura(23588);
            AddAura(23588, this);
        }
    }

    // close gossips
    PlayerTalkClass->ClearMenus();
    PlayerTalkClass->SendCloseGossip();
    UpdateItemLevel();

    return pItem;
}

void Player::QuickEquipItem(uint16 pos, Item* pItem)
{
    if (pItem)
    {
        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        uint8 slot = pos & 255;
        VisualizeItem(slot, pItem);

        if (IsInWorld())
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
    }
}

void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
{
    if (pItem)
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 0, pItem->GetVisibleEntry());
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 0, pItem->GetVisibleAppearanceModID());
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 1, pItem->GetVisibleItemVisual());
    }
    else
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 0, 0);
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2) + 1, 0);
    }
}

void Player::VisualizeItem(uint8 slot, Item* pItem)
{
    if (!pItem)
        return;

    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
    if (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
        pItem->SetBinding(true);

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
    {
        if (m_items[i] == pItem)
        {
            ACE_Stack_Trace trace;
            sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
        }
    }

    m_items[slot] = pItem;
    SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());
    pItem->SetSlot(slot);
    pItem->SetContainer(NULL);

    if (slot < EQUIPMENT_SLOT_END)
        SetVisibleItemSlot(slot, pItem);

    pItem->SetState(ITEM_CHANGED, this);
}

void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
{
    // note: removeitem does not actually change the item
    // it only takes the item out of storage temporarily
    // note2: if removeitem is to be used for delinking
    // the item must be removed from the player's updatequeue

    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);
        RemoveTradeableItem(pItem);

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();
                // item set bonuses applied only at equip and removed at unequip, and still active for broken items

                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);

                // remove item dependent auras and casts (only weapon and armor slots)
                if (slot < EQUIPMENT_SLOT_END)
                {
                    RemoveItemDependentAurasAndCasts(pItem);

                    // remove held enchantments
                    if (slot == EQUIPMENT_SLOT_MAINHAND)
                    {
                        if (pItem->GetItemSuffixFactor())
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
                        }
                        else
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
                        }
                    }
                }
            }

            m_items[slot] = NULL;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);

            if (slot < EQUIPMENT_SLOT_END)
                SetVisibleItemSlot(slot, NULL);
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, 0);
        pItem->SetSlot(NULL_SLOT);
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
    }
    UpdateItemLevel();
}

// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
{
    if (Item* it = GetItemByPos(bag, slot))
    {
        ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
        RemoveItem(bag, slot, update);
        it->SetNotRefundable(this, false);
        it->RemoveFromUpdateQueueOf(this);
        if (it->IsInWorld())
        {
            it->RemoveFromWorld();
            it->DestroyForPlayer(this);
        }
    }
}

// Common operation need to add item from inventory without delete in trade, guild bank, mail....
void Player::MoveItemToInventory(ItemPosCountVec const& dest, Item* pItem, bool update, bool in_characterInventoryDB)
{
    // update quest counters
    ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());

    // store item
    Item* pLastItem = StoreItem(dest, pItem, update);

    // only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
    if (pLastItem == pItem)
    {
        // update owner for last item (this can be original item with wrong owner
        if (pLastItem->GetOwnerGUID() != GetGUID())
            pLastItem->SetOwnerGUID(GetGUID());

        // if this original item then it need create record in inventory
        // in case trade we already have item in other player inventory
        pLastItem->SetState(in_characterInventoryDB ? ITEM_CHANGED : ITEM_NEW, this);
    }

    if (pLastItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
        AddTradeableItem(pLastItem);
}

void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
{
    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
        sScriptMgr->OnItemDestroyed(this, pItem);

        // Also remove all contained items if the item is a bag.
        // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
        if (pItem->IsNotEmptyBag())
            for (uint8 i = 0; i < MAX_BAG_SIZE; ++i)
                DestroyItem(slot, i, update);

        if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_WRAPPED))
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_GIFT);
            stmt->setUInt32(0, pItem->GetRealGUIDLow());
            RealmDatabase.Execute(stmt);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);

        const ItemTemplate* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
                RemoveAurasDueToSpell(proto->Spells[i].SpellId);

        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);

            // equipment and equipped bags can have applied bonuses
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();

                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);
            }

            if (slot < EQUIPMENT_SLOT_END)
            {
                // remove item dependent auras and casts (only weapon and armor slots)
                RemoveItemDependentAurasAndCasts(pItem);

                // equipment visual show
                SetVisibleItemSlot(slot, NULL);
            }

            m_items[slot] = NULL;
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        //pItem->SetOwnerGUID(0);
        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, 0);
        pItem->SetSlot(NULL_SLOT);
        pItem->SetState(ITEM_REMOVED, this);
    }
}

void Player::DestroyItemCount(uint32 item, uint32 count, bool update, bool unequip_check)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item = %u, count = %u", item, count);
    uint32 remcount = 0;

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    // all items in inventory can unequipped
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    if (!unequip_check || CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false) == EQUIP_ERR_OK)
                    {
                        remcount += pItem->GetCount();
                        DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                        if (remcount >= count)
                            return;
                    }
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank
    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in regeant bank
    for (uint8 i = REAGENT_BANK_SLOT_BAG_START; i < REAGENT_BANK_SLOT_BAG_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank bags
    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }
}

void Player::DestroyZoneLimitedItem(bool update, uint32 new_zone)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyZoneLimitedItem in map %u and area %u", GetMapId(), new_zone);

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

void Player::DestroyConjuredItems(bool update)
{
    // used when entering arena
    // destroys all conjured items
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyConjuredItems");

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsConjuredConsumable())
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

Item* Player::GetItemByEntry(uint32 entry) const
{
    // in inventory
    for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEntry() == entry)
                        return pItem;

    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    return NULL;
}

void Player::DestroyItemCount(Item* pItem, uint32 &count, bool update)
{
    if (!pItem)
        return;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(), pItem->GetEntry(), count);

    if (pItem->GetCount() <= count)
    {
        count -= pItem->GetCount();

        DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), update);
    }
    else
    {
        ItemRemovedQuestCheck(pItem->GetEntry(), count);
        pItem->SetCount(pItem->GetCount() - count);
        count = 0;
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
        pItem->SetState(ITEM_CHANGED, this);
    }
}

void Player::SplitItem(uint16 src, uint16 dst, uint32 count)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    if (pSrcItem->m_lootGenerated)                           // prevent split looting item (item
    {
        //best error message found for attempting to split while looting
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split all items (can be only at cheating)
    if (pSrcItem->GetCount() == count)
    {
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split more existed items (can be only at cheating)
    if (pSrcItem->GetCount() < count)
    {
        SendEquipError(EQUIP_ERR_TOO_FEW_TO_SPLIT, pSrcItem, NULL);
        return;
    }

    //! If trading
    if (TradeData* tradeData = GetTradeData())
    {
        //! If current item is in trade window (only possible with packet spoofing - silent return)
        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
            return;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SplitItem bag = %u, slot = %u, item = %u, count = %u", dstbag, dstslot, pSrcItem->GetEntry(), count);
    Item* pNewItem = pSrcItem->CloneItem(count, this);
    if (!pNewItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    if (IsInventoryPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        StoreItem(dest, pNewItem, true);
    }
    else if (IsBankPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        BankItem(dest, pNewItem, true);
    }
    else if (IsEquipmentPos(dst))
    {
        // change item amount before check (for unique max count check), provide space for splitted items
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        uint16 dest;
        InventoryResult msg = CanEquipItem(dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        EquipItem(dest, pNewItem, true);
        AutoUnequipOffhandIfNeed();
    }
}

void Player::SwapItem(uint16 src, uint16 dst)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    Item* pDstItem = GetItemByPos(dstbag, dstslot);

    /// If we want to swap the same item it is useless.
    if (pSrcItem == pDstItem)
        return;

    if (!pSrcItem)
        return;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SwapItem bag = %u, slot = %u, item = %u", dstbag, dstslot, pSrcItem->GetEntry());

    if (!isAlive())
    {
        SendEquipError(EQUIP_ERR_PLAYER_DEAD, pSrcItem, pDstItem);
        return;
    }

    // close gossips
    PlayerTalkClass->ClearMenus();
    PlayerTalkClass->SendCloseGossip();

    // SRC checks

    if (pSrcItem->m_lootGenerated)                           // prevent swap looting item
    {
        //best error message found for attempting to swap while looting
        SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pSrcItem, NULL);
        return;
    }

    // check unequip potability for equipped items and bank bags
    if (IsEquipmentPos(src) || IsBagPos(src))
    {
        // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
        InventoryResult msg = CanUnequipItem(src, !IsBagPos(src) || IsBagPos(dst) || (pDstItem && pDstItem->ToBag() && pDstItem->ToBag()->IsEmpty()));
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, pSrcItem, pDstItem);
            return;
        }
        RemoveAuraDependentItem(pSrcItem);
    }

    // prevent put equipped/bank bag in self
    if (IsBagPos(src) && srcslot == dstbag)
    {
        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
        return;
    }

    // prevent equipping bag in the same slot from its inside
    if (IsBagPos(dst) && srcbag == dstslot)
    {
        SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
        return;
    }

    //! If trading
    if (TradeData* tradeData = GetTradeData())
    {
        //! If current item is in trade window (only possible with packet spoofing - silent return)
        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
            TradeCancel(true);
    }

    // DST checks

    if (pDstItem)
    {
        if (pDstItem->m_lootGenerated)                       // prevent swap looting item
        {
            //best error message found for attempting to swap while looting
            SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pDstItem, NULL);
            return;
        }

        // check unequip potability for equipped items and bank bags
        if (IsEquipmentPos(dst) || IsBagPos(dst))
        {
            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
            InventoryResult msg = CanUnequipItem(dst, !IsBagPos(dst) || IsBagPos(src) || (pSrcItem->ToBag() && pSrcItem->ToBag()->IsEmpty()));
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, pDstItem);
                return;
            }
        }
    }

    // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
    // or swap empty bag with another empty or not empty bag (with items exchange)

    // Move case
    if (!pDstItem)
    {
        if (IsInventoryPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }
            RemoveItem(srcbag, srcslot, true);
            StoreItem(dest, pSrcItem, true);
            if (IsBankPos(src))
                ItemAddedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsBankPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            BankItem(dest, pSrcItem, true);
            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsReagentBankPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanReagentBankItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            BankItem(dest, pSrcItem, true);
            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsEquipmentPos(dst))
        {
            if (pSrcItem->ToBag() && GetTrader())
            {
                SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, NULL);
                return;
            }

            uint16 dest;
            InventoryResult msg = CanEquipItem(dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }
            RemoveItem(srcbag, srcslot, true);
            EquipItem(dest, pSrcItem, true);
            AutoUnequipOffhandIfNeed();
        }

        // Custom MoP script
        // Jab Override Driver
        if (getClass() == CLASS_MONK)
        {
            Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);

            if (mainItem && mainItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && !HasAura(125660))
            {
                RemoveAura(108561); // 2H Staff Override
                RemoveAura(115697); // 2H Polearm Override
                RemoveAura(115689); // D/W Axes
                RemoveAura(115694); // D/W Maces
                RemoveAura(115696); // D/W Swords

                switch (mainItem->GetTemplate()->SubClass)
                {
                    case ITEM_SUBCLASS_WEAPON_STAFF:
                        CastSpell(this, 108561, true);
                        break;
                    case ITEM_SUBCLASS_WEAPON_POLEARM:
                        CastSpell(this, 115697, true);
                        break;
                    case ITEM_SUBCLASS_WEAPON_AXE:
                        CastSpell(this, 115689, true);
                        break;
                    case ITEM_SUBCLASS_WEAPON_MACE:
                        CastSpell(this, 115694, true);
                        break;
                    case ITEM_SUBCLASS_WEAPON_SWORD:
                        CastSpell(this, 115696, true);
                        break;
                    default:
                        break;
                }
            }
            else
            {
                RemoveAura(108561); // 2H Staff Override
                RemoveAura(115697); // 2H Polearm Override
                RemoveAura(115689); // D/W Axes
                RemoveAura(115694); // D/W Maces
                RemoveAura(115696); // D/W Swords
            }
        }
        // Way of the Monk - 120277
        if (getClass() == CLASS_MONK && HasAura(120277))
        {
            RemoveAurasDueToSpell(120275);
            RemoveAurasDueToSpell(108977);

            uint32 trigger = 0;
            if (IsTwoHandUsed())
                trigger = 120275;
            else
            {
                Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
                Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                if (mainItem && mainItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && offItem && offItem->GetTemplate()->Class == ITEM_CLASS_WEAPON)
                    trigger = 108977;
            }

            if (trigger)
                CastSpell(this, trigger, true);

            UpdateRating(CR_HASTE_MELEE);
        }
        // Assassin's Resolve - 84601
        if (getClass() == CLASS_ROGUE && GetSpecializationId() == SPEC_ROGUE_ASSASSINATION)
        {
            Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
            Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

            if (((mainItem && mainItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER) || (offItem && offItem->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)))
            {
                if (HasAura(84601))
                    RemoveAura(84601);

                CastSpell(this, 84601, true);
            }
            else
                RemoveAura(84601);
        }

        return;
    }

    // attempt merge to / fill target item
    if (!pSrcItem->IsBag() && !pDstItem->IsBag())
    {
        InventoryResult msg;
        ItemPosCountVec sDest;
        uint16 eDest = 0;
        if (IsInventoryPos(dst))
            msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsBankPos(dst))
            msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsReagentBankPos(dst))
            msg = CanReagentBankItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsEquipmentPos(dst))
            msg = CanEquipItem(dstslot, eDest, pSrcItem, false);
        else
            return;

        // can be merge/fill
        if (msg == EQUIP_ERR_OK)
        {
            if (pSrcItem->GetCount() + pDstItem->GetCount() <= pSrcItem->GetTemplate()->GetMaxStackSize())
            {
                RemoveItem(srcbag, srcslot, true);

                if (IsInventoryPos(dst))
                    StoreItem(sDest, pSrcItem, true);
                else if (IsBankPos(dst))
                    BankItem(sDest, pSrcItem, true);
                else if (IsReagentBankPos(dst))
                    BankItem(sDest, pSrcItem, true);
                else if (IsEquipmentPos(dst))
                {
                    EquipItem(eDest, pSrcItem, true);
                    AutoUnequipOffhandIfNeed();
                }
            }
            else
            {
                pSrcItem->SetCount(pSrcItem->GetCount() + pDstItem->GetCount() - pSrcItem->GetTemplate()->GetMaxStackSize());
                pDstItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
                pSrcItem->SetState(ITEM_CHANGED, this);
                pDstItem->SetState(ITEM_CHANGED, this);
                if (IsInWorld())
                {
                    pSrcItem->SendUpdateToPlayer(this);
                    pDstItem->SendUpdateToPlayer(this);
                }
            }
            SendRefundInfo(pDstItem);
            return;
        }
    }

    // impossible merge/fill, do real swap
    InventoryResult msg = EQUIP_ERR_OK;

    // check src->dest move possibility
    ItemPosCountVec sDest;
    uint16 eDest = 0;
    if (IsInventoryPos(dst))
        msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsReagentBankPos(dst))
        msg = CanReagentBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        msg = CanEquipItem(dstslot, eDest, pSrcItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pSrcItem, pDstItem);
        return;
    }

    // check dest->src move possibility
    ItemPosCountVec sDest2;
    uint16 eDest2 = 0;
    if (IsInventoryPos(src))
        msg = CanStoreItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsBankPos(src))
        msg = CanBankItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsReagentBankPos(src))
        msg = CanReagentBankItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsEquipmentPos(src))
    {
        msg = CanEquipItem(srcslot, eDest2, pDstItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest2, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pDstItem, pSrcItem);
        return;
    }

    // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
    if (Bag* srcBag = pSrcItem->ToBag())
    {
        if (Bag* dstBag = pDstItem->ToBag())
        {
            if (GetTrader())
            {
                SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                return;
            }

            Bag* emptyBag = NULL;
            Bag* fullBag = NULL;
            if (srcBag->IsEmpty() && !IsBagPos(src))
            {
                emptyBag = srcBag;
                fullBag  = dstBag;
            }
            else if (dstBag->IsEmpty() && !IsBagPos(dst))
            {
                emptyBag = dstBag;
                fullBag  = srcBag;
            }

            // bag swap (with items exchange) case
            if (emptyBag && fullBag)
            {
                ItemTemplate const* emptyProto = emptyBag->GetTemplate();

                uint32 count = 0;

                for (uint32 i=0; i < fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    ItemTemplate const* bagItemProto = bagItem->GetTemplate();
                    if (!bagItemProto || !ItemCanGoIntoBag(bagItemProto, emptyProto))
                    {
                        // one from items not go to empty target bag
                        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
                        return;
                    }

                    ++count;
                }

                if (count > emptyBag->GetBagSize())
                {
                    // too small targeted bag
                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                    return;
                }

                // Items swap
                count = 0;                                      // will pos in new bag
                for (uint32 i = 0; i< fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    fullBag->RemoveItem(i, true);
                    emptyBag->StoreItem(count, bagItem, true);
                    bagItem->SetState(ITEM_CHANGED, this);

                    ++count;
                }
            }
        }
    }

    // now do moves, remove...
    RemoveItem(dstbag, dstslot, false);
    RemoveItem(srcbag, srcslot, false);

    // add to dest
    if (IsInventoryPos(dst))
        StoreItem(sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        BankItem(sDest, pSrcItem, true);
    else if (IsReagentBankPos(dst))
        BankItem(sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
        EquipItem(eDest, pSrcItem, true);

    // add to src
    if (IsInventoryPos(src))
        StoreItem(sDest2, pDstItem, true);
    else if (IsBankPos(src))
        BankItem(sDest2, pDstItem, true);
    else if (IsReagentBankPos(src))
        BankItem(sDest2, pDstItem, true);
    else if (IsEquipmentPos(src))
        EquipItem(eDest2, pDstItem, true);

    // if player is moving bags and is looting an item inside this bag
    // release the loot
    if (GetLootGUID())
    {
        bool released = false;
        if (IsBagPos(src))
        {
            Bag* bag = pSrcItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // so we don't need to look at dstBag
                        break;
                    }
                }
            }
        }

        if (!released && IsBagPos(dst) && pDstItem)
        {
            Bag* bag = pDstItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // not realy needed here ///< yeah because released is never read 01/18/16
                        break;
                    }
                }
            }
        }
    }
    AutoUnequipOffhandIfNeed();
}

void Player::AddItemToBuyBackSlot(Item* pItem)
{
    if (pItem)
    {
        uint32 slot = m_currentBuybackSlot;
        // if current back slot non-empty search oldest or free
        if (m_items[slot])
        {
            uint32 oldest_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP);
            uint32 oldest_slot = BUYBACK_SLOT_START;

            for (uint32 i = BUYBACK_SLOT_START+1; i < BUYBACK_SLOT_END; ++i)
            {
                // found empty
                if (!m_items[i])
                {
                    slot = i; ///< slot is never read 01/18/16
                    break;
                }

                uint32 i_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + i - BUYBACK_SLOT_START);

                if (oldest_time > i_time)
                {
                    oldest_time = i_time;
                    oldest_slot = i;
                }
            }

            // find oldest
            slot = oldest_slot;
        }

        RemoveItemFromBuyBackSlot(slot, true);
        sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: AddItemToBuyBackSlot item = %u, slot = %u", pItem->GetEntry(), slot);

        for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        {
            if (m_items[i] == pItem)
            {
                ACE_Stack_Trace trace;
                sLog->outAshran("VisualizeItem duplicate item ptr ! Try to put item in slot %u already exist in slot %u ! StackTrace : %s", i, slot, trace.c_str());
            }
        }
        m_items[slot] = pItem;
        time_t base = time(NULL);
        uint32 etime = uint32(base - m_logintime + (30 * 3600));
        uint32 eslot = slot - BUYBACK_SLOT_START;

        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (BUYBACK_SLOT_START * 4) + (eslot * 4), pItem->GetGUID());
        if (ItemTemplate const* proto = pItem->GetTemplate())
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, proto->SellPrice * pItem->GetCount());
        else
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, (uint32)etime);

        // move to next (for non filled list is move most optimized choice)
        if (m_currentBuybackSlot < BUYBACK_SLOT_END - 1)
            ++m_currentBuybackSlot;
    }
}

Item* Player::GetItemFromBuyBackSlot(uint32 slot)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: GetItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
        return m_items[slot];
    return NULL;
}

void Player::RemoveItemFromBuyBackSlot(uint32 slot, bool del)
{
    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
    {
        Item* pItem = m_items[slot];
        if (pItem)
        {
            pItem->RemoveFromWorld();
            if (del)
                pItem->SetState(ITEM_REMOVED, this);
        }

        m_items[slot] = NULL;

        uint32 eslot = slot - BUYBACK_SLOT_START;
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (BUYBACK_SLOT_START * 4) + (slot * 4), 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, 0);

        // if current backslot is filled set to now free slot
        if (m_items[m_currentBuybackSlot])
            m_currentBuybackSlot = slot;
    }
}

void Player::SendEquipError(InventoryResult msg, Item* pItem, Item* pItem2, uint32 itemid)
{
    if (msg != EQUIP_ERR_OK)
    {
        WorldPacket data(SMSG_INVENTORY_CHANGE_FAILURE);

        data << uint8(msg);
        data.appendPackGUID(pItem ? pItem->GetGUID() : 0);
        data.appendPackGUID(pItem2 ? pItem2->GetGUID() : 0);
        data << uint8(0);                                   // bag type subclass, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2

        if (msg == EQUIP_ERR_CANT_EQUIP_LEVEL_I || msg == EQUIP_ERR_PURCHASE_LEVEL_TOO_LOW)
        {
            ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
            data << uint32(proto ? proto->RequiredLevel : 0);
        }

        // no idea about this one...
        if (msg == EQUIP_ERR_NO_OUTPUT)
        {
            data.appendPackGUID(0);
            data << uint32(0); // slot
            data.appendPackGUID(0);
        }

        if (msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS ||
            msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED_IS ||
            msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS)
        {
            ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
            data << uint32(proto ? proto->ItemLimitCategory : 0);
        }

        GetSession()->SendPacket(&data);
    }
}

void Player::SendBuyError(BuyResult msg, Creature* creature, uint32 item, uint32 /*param*/)
{
    WorldPacket data(SMSG_BUY_FAILED, (8+4+4+1));
    ObjectGuid guid = creature ? creature->GetGUID() : 0;

    data.appendPackGUID(guid);
    data << uint32(item);
    data << uint8(msg);

    GetSession()->SendPacket(&data);
}

void Player::SendSellError(SellResult msg, Creature* creature, uint64 guid)
{
    ObjectGuid itemGuid = guid;
    ObjectGuid npcGuid = creature ? creature->GetGUID() : 0;
    WorldPacket data(SMSG_SELL_ITEM);

    data.appendPackGUID(npcGuid);
    data.appendPackGUID(itemGuid);
    data << uint8(msg);

    GetSession()->SendPacket(&data);
}

void Player::TradeCancel(bool sendback)
{
    if (m_trade)
    {
        Player* trader = m_trade->GetTrader();

        // send yellow "Trade canceled" message to both traders
        if (sendback)
            GetSession()->SendCancelTrade();

        trader->GetSession()->SendCancelTrade();

        // cleanup
        delete m_trade;
        m_trade = NULL;
        delete trader->m_trade;
        trader->m_trade = NULL;
    }
}

void Player::UpdateSoulboundTradeItems()
{
    if (m_itemSoulboundTradeable.empty())
        return;

    // also checks for garbage data
    for (ItemDurationList::iterator itr = m_itemSoulboundTradeable.begin(); itr != m_itemSoulboundTradeable.end();)
    {
        ASSERT(*itr);
        if ((*itr)->GetOwnerGUID() != GetGUID())
        {
            m_itemSoulboundTradeable.erase(itr++);
            continue;
        }
        if ((*itr)->CheckSoulboundTradeExpire())
        {
            m_itemSoulboundTradeable.erase(itr++);
            continue;
        }
        ++itr;
    }
}

void Player::AddTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.push_back(item);
}

//TODO: should never allow an item to be added to m_itemSoulboundTradeable twice
void Player::RemoveTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.remove(item);
}

void Player::UpdateItemDuration(uint32 time, bool realtimeonly)
{
    if (m_itemDuration.empty())
        return;

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Player::UpdateItemDuration(%u, %u)", time, realtimeonly);

    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end();)
    {
        Item* item = *itr;
        ++itr;                                              // current element can be erased in UpdateDuration

        if (!realtimeonly || item->GetTemplate()->FlagsCu & ITEM_FLAGS_CU_DURATION_REAL_TIME)
            item->UpdateDuration(this, time);
    }
}

void Player::UpdateEnchantTime(uint32 time)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr=next)
    {
        ASSERT(itr->item);
        next = itr;
        if (!itr->item->GetEnchantmentId(itr->slot))
        {
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration <= time)
        {
            ApplyEnchantment(itr->item, itr->slot, false, false);
            itr->item->ClearEnchantment(itr->slot);
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration > time)
        {
            itr->leftduration -= time;
            ++next;
        }
    }
}

void Player::AddEnchantmentDurations(Item* item)
{
    for (int x = 0; x < MAX_ENCHANTMENT_SLOT; ++x)
    {
        if (x > ENGINEERING_ENCHANTMENT_SLOT && x < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        if (!item->GetEnchantmentId(EnchantmentSlot(x)))
            continue;

        uint32 duration = item->GetEnchantmentDuration(EnchantmentSlot(x));
        if (duration > 0)
            AddEnchantmentDuration(item, EnchantmentSlot(x), duration);
    }
}

void Player::RemoveEnchantmentDurations(Item* item)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end();)
    {
        if (itr->item == item)
        {
            // save duration in item
            item->SetEnchantmentDuration(EnchantmentSlot(itr->slot), itr->leftduration, this);
            itr = m_enchantDuration.erase(itr);
        }
        else
            ++itr;
    }
}

void Player::RemoveArenaEnchantments(EnchantmentSlot slot)
{
    // remove enchantments from equipped items first to clean up the m_enchantDuration list
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr = next)
    {
        next = itr;
        if (itr->slot == slot)
        {
            if (itr->item && itr->item->GetEnchantmentId(slot))
            {
                // Poisons and DK runes are enchants which are allowed on arenas
                if (sSpellMgr->IsArenaAllowedEnchancment(itr->item->GetEnchantmentId(slot)))
                {
                    ++next;
                    continue;
                }
                // remove from stats
                ApplyEnchantment(itr->item, slot, false, false);
                // remove visual
                itr->item->ClearEnchantment(slot);
            }
            // remove from update list
            next = m_enchantDuration.erase(itr);
        }
        else
            ++next;
    }

    // remove enchants from inventory items
    // NOTE: no need to remove these from stats, since these aren't equipped
    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEnchantmentId(slot))
                pItem->ClearEnchantment(slot);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEnchantmentId(slot))
                        pItem->ClearEnchantment(slot);
}

// duration == 0 will remove item enchant
void Player::AddEnchantmentDuration(Item* item, EnchantmentSlot slot, uint32 duration)
{
    if (!item)
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
    {
        if (itr->item == item && itr->slot == slot)
        {
            itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
            m_enchantDuration.erase(itr);
            break;
        }
    }
    if (item && duration > 0)
    {
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), item->GetGUID(), slot, uint32(duration/1000));
        m_enchantDuration.push_back(EnchantDuration(item, slot, duration));
    }
}

void Player::ApplyEnchantment(Item* item, bool apply)
{
    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
        ApplyEnchantment(item, EnchantmentSlot(slot), apply);

    //ApplyItemUpgrade(item, apply);
}

void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
{
    if (!item || !item->IsEquipped())
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    uint32 enchant_id = item->GetEnchantmentId(slot);
    if (!enchant_id)
        return;

    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
    if (!pEnchant)
        return;

    if (!ignore_condition && pEnchant->EnchantmentCondition && !EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
        return;

    if (pEnchant->requiredLevel > getLevel())
        return;

    if (pEnchant->requiredSkill > 0 && pEnchant->requiredSkillValue > GetSkillValue(pEnchant->requiredSkill))
        return;

    // Cogwheel gems dont have requirement data set in SpellItemEnchantment.dbc, but they do have it in Item-sparse.db2
    if (ItemTemplate const* gem = sObjectMgr->GetItemTemplate(pEnchant->GemID))
        if (gem->RequiredSkill && GetSkillValue(gem->RequiredSkill) < gem->RequiredSkillRank)
            return;

    // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
    // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
    // If the socket is from an item bonus, it's a WoD item, so it can't be a "classical" enchant neither a prismatic enchant
    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
        && !item->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color && !item->HasItemBonusType(ItemBonusType::ITEM_BONUS_ADD_SOCKET))
    {
         // Check if the requirements for the prismatic socket are met before applying the gem stats
         SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
         if (!pPrismaticEnchant || (pPrismaticEnchant->requiredSkill > 0 && pPrismaticEnchant->requiredSkillValue > GetSkillValue(pPrismaticEnchant->requiredSkill)))
             return;
    }

    if (!item->CantBeUse())
    {
        for (int s = 0; s < MAX_ENCHANTMENT_SPELLS; ++s)
        {
            uint32 enchant_display_type = pEnchant->type[s];
            uint32 enchant_amount = CalculateEnchantmentBonus(pEnchant, pEnchant->amount[s], s, getLevel());
            uint32 enchant_spell_id = pEnchant->spellid[s];

            switch (enchant_display_type)
            {
                case ITEM_ENCHANTMENT_TYPE_NONE:
                    break;
                case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
                    // processed in Player::CastItemCombatSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND && (
                        item->GetTemplate()->InventoryType == INVTYPE_RANGED || item->GetTemplate()->InventoryType == INVTYPE_THROWN ||
                        item->GetTemplate()->InventoryType == INVTYPE_RANGEDRIGHT))
                        HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
                    if (enchant_spell_id)
                    {
                        if (apply)
                        {
                            int32 basepoints = 0;
                            // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
                            if (item->GetItemRandomPropertyId() < 0)
                            {
                                ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                                if (item_rand)
                                {
                                    // Search enchant_amount
                                    for (int k = 0; k < 5; ++k)
                                    {
                                        if (item_rand->enchant_id[k] == enchant_id)
                                        {
                                            basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
                                            break;
                                        }
                                    }
                                }
                            }
                            // Cast custom spell vs all equal basepoints got from enchant_amount
                            if (basepoints)
                                CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
                            else
                                CastSpell(this, enchant_spell_id, true, item);
                        }
                        else
                            RemoveAurasDueToItemSpell(item, enchant_spell_id);
                    }
                    break;
                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand)
                        {
                            for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
                            {
                                if (item_rand->enchant_id[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_STAT:
                {
                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand_suffix)
                        {
                            for (int k = 0; k < 5; ++k)
                            {
                                if (item_rand_suffix->enchant_id[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
                    switch (enchant_spell_id)
                    {
                        case ITEM_MOD_MANA:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_HEALTH:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_AGILITY:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u AGILITY", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_STRENGTH:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STRENGTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_INTELLECT:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u INTELLECT", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_SPIRIT:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPIRIT", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_SPIRIT, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_STAMINA:
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u STAMINA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_DODGE_RATING:
                            ApplyRatingMod(CR_DODGE, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u DODGE", enchant_amount);
                            break;
                        case ITEM_MOD_PARRY_RATING:
                            ApplyRatingMod(CR_PARRY, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u PARRY", enchant_amount);
                            break;
                        case ITEM_MOD_BLOCK_RATING:
                            ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SHIELD_BLOCK", enchant_amount);
                            break;
                        case ITEM_MOD_CRIT_RATING:
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u CRITICAL", enchant_amount);
                            break;
                        case ITEM_MOD_RESILIENCE_RATING:
                            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u RESILIENCE", enchant_amount);
                            break;
                        case ITEM_MOD_HASTE_RATING:
                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HASTE", enchant_amount);
                            break;
                        case ITEM_MOD_ATTACK_POWER:
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ATTACK_POWER", enchant_amount);
                            break;
                        case ITEM_MOD_VERSATILITY_RATING:
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, enchant_amount, apply);
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u VERSATILITY", enchant_amount);
                            break;
                        case ITEM_MOD_MANA_REGENERATION:
                            ApplyManaRegenBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MANA_REGENERATION", enchant_amount);
                            break;
                        case ITEM_MOD_SPELL_POWER:
                            ApplySpellPowerBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SPELL_POWER", enchant_amount);
                            break;
                        case ITEM_MOD_HEALTH_REGEN:
                            ApplyHealthRegenBonus(enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HEALTH_REGENERATION", enchant_amount);
                            break;
                        case ITEM_MOD_MASTERY_RATING:
                            ApplyRatingMod(CR_MASTERY, int32(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MASTERY_RATING", enchant_amount);
                            break;
                        case ITEM_MOD_FIRE_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u FIRE RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_FROST_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u FROST RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_HOLY_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u HOLY RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_SHADOW_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u SHADOW RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_NATURE_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u NATURE RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_ARCANE_RESISTANCE:
                            HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(enchant_amount), apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u ARCANE RESISTANCE", enchant_amount);
                            break;
                        case ITEM_MOD_PVP_POWER:
                            ApplyRatingMod(CR_PVP_POWER, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u POWER JCJ", enchant_amount);
                            break;
                        case ITEM_MOD_MULTISTRIKE_RATING:
                            ApplyRatingMod(CR_MULTISTRIKE, enchant_amount, apply);
                            sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u MULTISTRIKE", enchant_amount);
                            break;
                        case ITEM_MOD_DYNAMIC_STAT_AGI_STR_INT:
                        {
                            Stats stat = GetPrimaryStat();
                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case ITEM_MOD_DYNAMIC_STAT_AGI_STR:
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_AGILITY && stat != STAT_STRENGTH)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case ITEM_MOD_DYNAMIC_STAT_AGI_INT:
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_AGILITY && stat != STAT_INTELLECT)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        case ITEM_MOD_DYNAMIC_STAT_STR_INT:
                        {
                            Stats stat = GetPrimaryStat();
                            if (stat != STAT_INTELLECT && stat != STAT_STRENGTH)
                                break;

                            HandleStatModifier((UnitMods)stat, BASE_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(stat, float(enchant_amount), apply);
                            break;
                        }
                        default:
                            break;
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
                {
                    if (getClass() == CLASS_SHAMAN)
                    {
                        float addValue = 0.0f;
                        if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
                        }
                        else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
                        }
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
                    // processed in Player::CastItemUseSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
                    // nothing do..
                    break;
                default:
                    sLog->outError(LOG_FILTER_PLAYER, "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
                    break;
            }                                               /*switch (enchant_display_type)*/
        }                                                   /*for*/
    }

    // visualize enchantment at player and equipped items
    if (slot == PERM_ENCHANTMENT_SLOT || slot == TEMP_ENCHANTMENT_SLOT)
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + (item->GetSlot() * 2) + 1, 1, item->GetVisibleItemVisual());

    if (apply_dur)
    {
        if (apply)
        {
            // set duration
            uint32 duration = item->GetEnchantmentDuration(slot);
            if (duration > 0)
                AddEnchantmentDuration(item, slot, duration);
        }
        else
        {
            // duration == 0 will remove EnchantDuration
            AddEnchantmentDuration(item, slot, 0);
        }
    }
}

void Player::UpdateSkillEnchantments(uint16 skill_id, uint16 curr_value, uint16 new_value)
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            for (uint8 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
            {
                if (slot > ENGINEERING_ENCHANTMENT_SLOT && slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
                    continue;

                uint32 ench_id = m_items[i]->GetEnchantmentId(EnchantmentSlot(slot));
                if (!ench_id)
                    continue;

                SpellItemEnchantmentEntry const* Enchant = sSpellItemEnchantmentStore.LookupEntry(ench_id);
                if (!Enchant)
                    return;

                if (Enchant->requiredSkill == skill_id)
                {
                    // Checks if the enchantment needs to be applied or removed
                    if (curr_value < Enchant->requiredSkillValue && new_value >= Enchant->requiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                    else if (new_value < Enchant->requiredSkillValue && curr_value >= Enchant->requiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                }

                // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
                // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
                if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
                    && !m_items[i]->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
                {
                    SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(m_items[i]->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));

                    if (pPrismaticEnchant && pPrismaticEnchant->requiredSkill == skill_id)
                    {
                        if (curr_value < pPrismaticEnchant->requiredSkillValue && new_value >= pPrismaticEnchant->requiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                        else if (new_value < pPrismaticEnchant->requiredSkillValue && curr_value >= pPrismaticEnchant->requiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                    }
                }
            }
        }
    }
}

void Player::SendEnchantmentDurations()
{
    for (EnchantDurationList::const_iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), itr->item->GetGUID(), itr->slot, uint32(itr->leftduration) / 1000);
}

void Player::SendItemDurations()
{
    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
        (*itr)->SendTimeUpdate(this);
}

void Player::SendDisplayToast(uint32 p_Entry, uint32 p_Count, DisplayToastMethod p_Method, ToastTypes p_Type, bool p_BonusRoll, bool p_Mailed, std::vector<uint32> const& p_ItemBonus)
{
    ItemTemplate const* l_ItemTpl = sObjectMgr->GetItemTemplate(p_Entry);

    if (!l_ItemTpl && p_Entry && p_Type == TOAST_TYPE_NEW_ITEM)
        return;

    WorldPacket l_Data(SMSG_DISPLAY_TOAST, 30);

    l_Data << uint32(p_Count);
    l_Data << uint8(p_Method);                  ///< DisplayToastMethod

    l_Data.WriteBit(p_BonusRoll);               ///< Bonuses
    l_Data.WriteBits(p_Type, 2);                ///< Context

    if (p_Type == TOAST_TYPE_NEW_ITEM)
    {
        l_Data.WriteBit(p_Mailed);
        l_Data.FlushBits();

        Item::BuildDynamicItemDatas(l_Data, p_Entry, p_ItemBonus);

        l_Data << uint32(GetLootSpecId());          ///< LootSpec
        l_Data << uint32(0);                        ///< Quantity
    }
    else
        l_Data.FlushBits();

    if (p_Type == TOAST_TYPE_NEW_CURRENCY)
        l_Data << uint32(p_Entry);

    GetSession()->SendPacket(&l_Data);
}

void Player::SendNewItem(Item* p_Item, uint32 p_Quantity, bool p_Received, bool p_Created, bool p_Broadcast, uint32 p_EncounterID /*= 0*/, ItemContext p_Context /*= ItemContext::None*/)
{
    /// Prevent crash
    if (!p_Item)
        return;

    sScriptMgr->OnPlayerItemLooted(this, p_Item);

    WorldPacket l_Data(Opcodes::SMSG_ITEM_PUSH_RESULT, 16 + 2 + 1 + 4 + 100 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 16 + 2 + 1);

    l_Data.appendPackGUID(GetGUID());                               ///< Player GUID
    l_Data << uint8(p_Item->GetBagSlot());                          ///< Slot
    l_Data << uint32(0);                                            ///< SlotInBag

    Item::BuildDynamicItemDatas(l_Data, p_Item, p_Context);

    l_Data << uint32(0);                                            ///< QuestLogItemID
    l_Data << uint32(p_Quantity);                                   ///< Quantity
    l_Data << uint32(GetItemCount(p_Item->GetEntry()));             ///< count of items in inventory
    l_Data << uint32(p_EncounterID);                                ///< Dungeon Encounter ID
    l_Data << uint32(0);                                            ///< Battle Pet Species ID
    l_Data << uint32(0);                                            ///< Battle Pet Breed ID
    l_Data << uint32(0);                                            ///< Battle Pet Breed Quality
    l_Data << uint32(0);                                            ///< Battle Pet Level
    l_Data.appendPackGUID(p_Item->GetGUID());                       ///< Item GUID

    l_Data.WriteBit(p_Received);                                    ///< Pushed
    l_Data.WriteBit(p_Created);                                     ///< Created
    l_Data.WriteBits(p_Context == ItemContext::RaidLfr ? 3 : 1, 2); ///< Display Text
    l_Data.WriteBit(false);                                         ///< Is Bonus Roll
    l_Data.WriteBit(p_Context == ItemContext::RaidLfr);             ///< Is Encounter Loot
    l_Data.FlushBits();

    if (p_Broadcast && GetGroup())
        GetGroup()->BroadcastPacket(&l_Data, true);
    else
        GetSession()->SendPacket(&l_Data);
}

/*********************************************************/
/***                    GOSSIP SYSTEM                  ***/
/*********************************************************/
void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool showQuests /*= false*/)
{
    PlayerMenu* menu = PlayerTalkClass;
    menu->ClearMenus();

    menu->GetGossipMenu().SetMenuId(menuId);

    GossipMenuItemsMapBounds menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(menuId);

    // if default menuId and no menu options exist for this, use options from default options
    if (menuItemBounds.first == menuItemBounds.second && menuId == GetDefaultGossipMenuForSource(source))
        menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);

    uint32 npcflags = 0;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        npcflags = source->GetUInt32Value(UNIT_FIELD_NPC_FLAGS);
        if (showQuests && npcflags & UNIT_NPC_FLAG_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());
    }

    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
        if (showQuests && source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());

    for (GossipMenuItemsContainer::const_iterator itr = menuItemBounds.first; itr != menuItemBounds.second; ++itr)
    {
        bool canTalk = true;
        if (!sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            continue;

        if (Creature* creature = source->ToCreature())
        {
            if (!(itr->second.OptionNpcflag & npcflags))
                continue;

            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_ARMORER:
                    canTalk = false;                       // added in special mode
                    break;
                case GOSSIP_OPTION_SPIRITHEALER:
                    if (!isDead())
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_VENDOR:
                {
                    VendorItemData const* vendorItems = creature->GetVendorItems();
                    if (!vendorItems || vendorItems->Empty())
                    {
                        sLog->outError(LOG_FILTER_SQL, "Creature %u (Entry: %u) have UNIT_NPC_FLAG_VENDOR but have empty trading item list.", creature->GetGUIDLow(), creature->GetEntry());
                        canTalk = false;
                    }
                    break;
                }
                case GOSSIP_OPTION_TRAINER:
                    if (!creature->isCanTrainingOf(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_LEARNDUALSPEC:
                    if (!(GetSpecsCount() == 1 && creature->isCanTrainingAndResetTalentsOf(this) && !(getLevel() < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNTALENTS:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNPETTALENTS:
                    if (!GetPet() || GetPet()->getPetType() != HUNTER_PET || GetPet()->m_spells.size() <= 1 || creature->GetCreatureTemplate()->trainer_type != TRAINER_TYPE_PETS || creature->GetCreatureTemplate()->trainer_class != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNSPECIALIZATION:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_TAXIVENDOR:
                    if (GetSession()->SendLearnNewTaxiNode(creature))
                        return;
                    break;
                case GOSSIP_OPTION_BATTLEFIELD:
                    if (!creature->isCanInteractWithBattleMaster(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_STABLEPET:
                    if (getClass() != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_QUESTGIVER:
                    canTalk = false;
                    break;
                case GOSSIP_OPTION_GOSSIP:
                case GOSSIP_OPTION_SPIRITGUIDE:
                case GOSSIP_OPTION_INNKEEPER:
                case GOSSIP_OPTION_BANKER:
                case GOSSIP_OPTION_PETITIONER:
                case GOSSIP_OPTION_TABARDDESIGNER:
                case GOSSIP_OPTION_AUCTIONEER:
                    break;                                  // no checks
                case GOSSIP_OPTION_OUTDOORPVP:
                    if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
                        canTalk = false;
                    break;
                default:
                    sLog->outError(LOG_FILTER_SQL, "Creature entry %u have unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuId);
                    canTalk = false;
                    break;
            }
        }
        else if (GameObject* go = source->ToGameObject())
        {
            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_GOSSIP:
                    if (go->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && go->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
                        canTalk = false;
                    break;
                default:
                    canTalk = false;
                    break;
            }
        }

        if (canTalk)
        {
            std::string strOptionText = itr->second.OptionText;
            std::string strBoxText = itr->second.BoxText;

            int32 locale = GetSession()->GetSessionDbLocaleIndex();
            if (locale >= 0)
            {
                if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(MAKE_PAIR64(menuId, itr->second.OptionIndex)))
                {
                    ObjectMgr::GetLocaleString(no->OptionText, locale, strOptionText);
                    ObjectMgr::GetLocaleString(no->BoxText, locale, strBoxText);
                }
            }

            menu->GetGossipMenu().AddMenuItem(itr->second.OptionIndex, itr->second.OptionIcon, strOptionText, 0, itr->second.OptionType, strBoxText, itr->second.BoxMoney, itr->second.BoxCoded);
            menu->GetGossipMenu().AddGossipMenuItemData(itr->second.OptionIndex, itr->second.ActionMenuId, itr->second.ActionPoiId);
        }
    }
}

void Player::SendPreparedGossip(WorldObject* source)
{
    if (!source)
        return;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        // in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
        if (!source->ToCreature()->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }
    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        // probably need to find a better way here
        if (!PlayerTalkClass->GetGossipMenu().GetMenuId() && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }

    // in case non empty gossip menu (that not included quests list size) show it
    // (quest entries from quest menu will be included in list)

    uint32 textId = GetGossipTextId(source);

    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
        textId = GetGossipTextId(menuId, source);

    PlayerTalkClass->SendGossipMenu(textId, source->GetGUID());
}

void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 menuId)
{
    GossipMenu& gossipMenu = PlayerTalkClass->GetGossipMenu();

    // if not same, then something funky is going on
    if (menuId != gossipMenu.GetMenuId())
        return;

    GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
    if (!item)
        return;

    uint32 gossipOptionId = item->OptionType;
    uint64 guid = source->GetGUID();

    if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        if (gossipOptionId > GOSSIP_OPTION_QUESTGIVER)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player guid %u request invalid gossip option for GameObject entry %u", GetGUIDLow(), source->GetEntry());
            return;
        }
    }

    GossipMenuItemData const* menuItemData = gossipMenu.GetItemData(gossipListId);
    if (!menuItemData)
        return;

    int32 cost = int32(item->BoxMoney);
    if (!HasEnoughMoney(int64(cost)))
    {
        SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
        PlayerTalkClass->SendCloseGossip();
        return;
    }

    switch (gossipOptionId)
    {
        case GOSSIP_OPTION_GOSSIP:
        {
            if (menuItemData->GossipActionPoi)
                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);

            if (menuItemData->GossipActionMenuId)
            {
                PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
                SendPreparedGossip(source);
            }

            break;
        }
        case GOSSIP_OPTION_OUTDOORPVP:
            sOutdoorPvPMgr->HandleGossipOption(this, source->GetGUID(), gossipListId);
            break;
        case GOSSIP_OPTION_SPIRITHEALER:
            if (isDead())
                source->ToCreature()->CastSpell(source->ToCreature(), 17251, true, NULL, nullptr, GetGUID());
            break;
        case GOSSIP_OPTION_QUESTGIVER:
            PrepareQuestMenu(guid);
            SendPreparedQuest(guid);
            break;
        case GOSSIP_OPTION_VENDOR:
        case GOSSIP_OPTION_ARMORER:
            GetSession()->SendListInventory(guid);
            break;
        case GOSSIP_OPTION_STABLEPET:
            GetSession()->SendStablePet(guid);
            break;
        case GOSSIP_OPTION_TRAINER:
            GetSession()->SendTrainerList(guid);
            break;
        case GOSSIP_OPTION_LEARNDUALSPEC:
            if (GetSpecsCount() == 1 && getLevel() >= sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))
            {
                // Cast spells that teach dual spec
                // Both are also ImplicitTarget self and must be cast by player
                CastSpell(this, 63680, true, NULL, nullptr, GetGUID());
                CastSpell(this, 63624, true, NULL, nullptr, GetGUID());

                // Should show another Gossip text with "Congratulations..."
                PlayerTalkClass->SendCloseGossip();
            }
            break;
        case GOSSIP_OPTION_UNLEARNTALENTS:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, false);
            break;
        case GOSSIP_OPTION_UNLEARNPETTALENTS:
            PlayerTalkClass->SendCloseGossip();
            //ResetPetTalents();
            break;
         case GOSSIP_OPTION_UNLEARNSPECIALIZATION:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, true);
            break;
        case GOSSIP_OPTION_TAXIVENDOR:
            GetSession()->SendTaxiMenu(source->ToCreature());
            break;
        case GOSSIP_OPTION_INNKEEPER:
            PlayerTalkClass->SendCloseGossip();
            SetBindPoint(guid);
            break;
        case GOSSIP_OPTION_BANKER:
            GetSession()->SendShowBank(guid);
            break;
#ifndef CROSS
        case GOSSIP_OPTION_PETITIONER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendPetitionShowList(guid);
            break;
#endif /* not CROSS */
        case GOSSIP_OPTION_TABARDDESIGNER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendTabardVendorActivate(GetSession()->GetPlayer()->GetGUID());
            break;
        case GOSSIP_OPTION_AUCTIONEER:
#ifndef CROSS
            GetSession()->SendAuctionHello(guid, source->ToCreature());
#else /* CROSS */
            /// @TODO: Send notification to realm core and handle it
            /// We don't need it atm
            //GetSession()->SendAuctionHello(guid, source->ToCreature());
#endif /* CROSS */
            break;
        case GOSSIP_OPTION_SPIRITGUIDE:
            PrepareGossipMenu(source);
            SendPreparedGossip(source);
            break;
        case GOSSIP_OPTION_BATTLEFIELD:
        {
            BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());

            if (bgTypeId == BATTLEGROUND_TYPE_NONE)
            {
                sLog->outError(LOG_FILTER_PLAYER, "a user (guid %u) requested battlegroundlist from a npc who is no battlemaster", GetGUIDLow());
                return;
            }

            GetSession()->SendBattleGroundList(guid, bgTypeId);
            break;
        }
    }

    ModifyMoney(-cost);
}

uint32 Player::GetGossipTextId(WorldObject* source)
{
    if (!source)
        return DEFAULT_GOSSIP_MESSAGE;

    return GetGossipTextId(GetDefaultGossipMenuForSource(source), source);
}

uint32 Player::GetGossipTextId(uint32 menuId, WorldObject* source)
{
    uint32 textId = DEFAULT_GOSSIP_MESSAGE;

    if (!menuId)
        return textId;

    GossipMenusMapBounds menuBounds = sObjectMgr->GetGossipMenusMapBounds(menuId);

    for (GossipMenusContainer::const_iterator itr = menuBounds.first; itr != menuBounds.second; ++itr)
    {
        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.conditions))
            textId = itr->second.text_id;
    }

    return textId;
}

uint32 Player::GetDefaultGossipMenuForSource(WorldObject* source)
{
    switch (source->GetTypeId())
    {
        case TYPEID_UNIT:
            return source->ToCreature()->GetCreatureTemplate()->GossipMenuId;
        case TYPEID_GAMEOBJECT:
            return source->ToGameObject()->GetGOInfo()->GetGossipMenuId();
        default:
            break;
    }

    return 0;
}

/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/
void Player::PrepareQuestMenu(uint64 guid)
{
    QuestRelationBounds objectQR;
    QuestRelationBounds objectQIR;

    // pets also can have quests
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (creature)
    {
        objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
        objectQIR = sObjectMgr->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
    }
    else
    {
        //we should obtain map pointer from GetMap() in 99% of cases. Special case
        //only for quests which cast teleport spells on player
        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
        ASSERT(_map);
        GameObject* pGameObject = _map->GetGameObject(guid);
        if (pGameObject)
        {
            objectQR  = sObjectMgr->GetGOQuestRelationBounds(pGameObject->GetEntry());
            objectQIR = sObjectMgr->GetGOQuestInvolvedRelationBounds(pGameObject->GetEntry());
        }
        else
            return;
    }

    QuestMenu &qm = PlayerTalkClass->GetQuestMenu();
    qm.ClearMenu();

    std::set<uint32> l_AddedQuests;

    for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
    {
        uint32 quest_id = i->second;
        QuestStatus status = GetQuestStatus(quest_id);

        if (l_AddedQuests.find(quest_id) != l_AddedQuests.end())
            continue;

        if (status == QUEST_STATUS_COMPLETE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 4);
        }
        else if (status == QUEST_STATUS_INCOMPLETE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 4);
        }
        //else if (status == QUEST_STATUS_AVAILABLE)
        //    qm.AddMenuItem(quest_id, 2);
    }

    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
    {
        uint32 quest_id = i->second;
        Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
        if (!quest)
            continue;

        if (l_AddedQuests.find(quest_id) != l_AddedQuests.end())
            continue;

        if (!CanTakeQuest(quest, false))
            continue;

        if (GetQuestStatus(quest_id) == QUEST_STATUS_NONE)
        {
            l_AddedQuests.insert(quest_id);
            qm.AddMenuItem(quest_id, 2);
        }
    }
}

void Player::SendPreparedQuest(uint64 guid)
{
    QuestMenu& questMenu = PlayerTalkClass->GetQuestMenu();
    if (questMenu.Empty())
        return;

    // single element case
    if (questMenu.GetMenuItemCount() == 1)
    {
        QuestMenuItem const& qmi0 = questMenu.GetItem(0);
        uint32 questId = qmi0.QuestId;

        // Auto open -- maybe also should verify there is no greeting
        if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
        {
            if (qmi0.QuestIcon == 4)
                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
            // Send completable on repeatable and autoCompletable quest if player don't have quest
            // @todo: verify if check for !quest->IsDaily() is really correct (possibly not)
            else
            {
                Object* object = ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT | TYPEMASK_ITEM);
                if (!object || (!object->hasQuest(questId) && !object->hasInvolvedQuest(questId)))
                {
                    PlayerTalkClass->SendCloseGossip();
                    return;
                }

                PlayerTalkClass->SendQuestGiverQuestDetails(quest, guid);
            }
        }
    }
    // multiple entries
    else
    {
        QEmote qe;
        qe._Delay = 0;
        qe._Emote = 0;
        std::string title = "";

        // need pet case for some quests
        Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
        if (creature)
        {
            uint32 textid = GetGossipTextId(creature);
            GossipText const* gossiptext = sObjectMgr->GetGossipText(textid);
            if (!gossiptext)
            {
                qe._Delay = 0;                              //TEXTEMOTE_MESSAGE;              //zyg: player emote
                qe._Emote = 0;                              //TEXTEMOTE_HELLO;                //zyg: NPC emote
                title = "";
            }
            else
            {
                qe = gossiptext->Options[0].Emotes[0];

                if (!gossiptext->Options[0].Text_0.empty())
                {
                    title = gossiptext->Options[0].Text_0;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_0[0], loc_idx, title);
                }
                else
                {
                    title = gossiptext->Options[0].Text_1;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_1[0], loc_idx, title);
                }
            }
        }
        PlayerTalkClass->SendQuestGiverQuestList(qe, title, guid);
    }
}

bool Player::IsActiveQuest(uint32 quest_id) const
{
    return m_QuestStatus.find(quest_id) != m_QuestStatus.end();
}

Quest const* Player::GetNextQuest(uint64 p_Guid, Quest const* p_Quest)
{
    QuestRelationBounds l_ObjectQR;

    WorldObject* l_Object = ObjectAccessor::GetWorldObject(*this, p_Guid);

    if (l_Object == nullptr)
        return nullptr;

    switch (l_Object->GetTypeId())
    {
        case TYPEID_UNIT:
        {
            if (Creature* l_Creature = l_Object->ToCreature())
                l_ObjectQR = sObjectMgr->GetCreatureQuestRelationBounds(l_Creature->GetEntry());

            break;
        }
        case TYPEID_PLAYER:
        {
            if (Player* l_Player = l_Object->ToPlayer())
                return sObjectMgr->GetQuestTemplate(p_Quest->GetNextQuestInChain());

            break;
        }
        case TYPEID_GAMEOBJECT:
        {
            if (GameObject* l_Gob = l_Object->ToGameObject())
                l_ObjectQR = sObjectMgr->GetGOQuestRelationBounds(l_Gob->GetEntry());

            break;
        }
        default:
            break;
    }

    uint32 l_NextQuestID = p_Quest->GetNextQuestInChain();

    for (QuestRelations::const_iterator l_Itr = l_ObjectQR.first; l_Itr != l_ObjectQR.second; ++l_Itr)
    {
        if (l_Itr->second == l_NextQuestID)
            return sObjectMgr->GetQuestTemplate(l_NextQuestID);
    }

    return NULL;
}

bool Player::CanSeeStartQuest(Quest const* quest)
{
    if (!DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this) && SatisfyQuestClass(quest, false) && SatisfyQuestRace(quest, false) &&
        SatisfyQuestSkill(quest, false) && SatisfyQuestExclusiveGroup(quest, false) && SatisfyQuestReputation(quest, false) &&
        SatisfyQuestPreviousQuest(quest, false) && SatisfyQuestNextChain(quest, false) &&
        SatisfyQuestPrevChain(quest, false) && SatisfyQuestDay(quest) && SatisfyQuestWeek(quest, false) &&
        SatisfyQuestMonth(quest, false) && SatisfyQuestSeasonal(quest, false))
    {
        return getLevel() + sWorld->getIntConfig(CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF) >= quest->GetMinLevel();
    }

    return false;
}

bool Player::CanTakeQuest(Quest const* quest, bool msg)
{
    ///
    return !DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this)
        && SatisfyQuestStatus(quest, msg) && SatisfyQuestExclusiveGroup(quest, msg)
        && SatisfyQuestTeam(quest)
        && SatisfyQuestClass(quest, msg) && SatisfyQuestRace(quest, msg) && SatisfyQuestLevel(quest, msg)
        && SatisfyQuestSkill(quest, msg) && SatisfyQuestReputation(quest, msg)
        && SatisfyQuestPreviousQuest(quest, msg) && SatisfyQuestTimed(quest, msg)
        && SatisfyQuestNextChain(quest, msg) && SatisfyQuestPrevChain(quest, msg)
        && SatisfyQuestDay(quest) && SatisfyQuestWeek(quest, msg)
        && SatisfyQuestMonth(quest, msg) && SatisfyQuestSeasonal(quest, msg)
        && SatisfyQuestConditions(quest, msg);
}

bool Player::CanAddQuest(Quest const* quest, bool msg)
{
    if (!SatisfyQuestLog(msg))
        return false;

    uint32 srcitem = quest->GetSrcItemId();
    if (srcitem > 0)
    {
        ItemPosCountVec dest;
        InventoryResult msg2 = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);

        // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
        if (msg2 == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else if (msg2 != EQUIP_ERR_OK)
        {
            SendEquipError(msg2, NULL, NULL, srcitem);
            return false;
        }
    }
    return true;
}

bool Player::CanCompleteQuest(uint32 p_QuestID)
{
    if (p_QuestID)
    {
        Quest const* l_Quest = sObjectMgr->GetQuestTemplate(p_QuestID);

        if (!l_Quest)
            return false;

        if (!l_Quest->IsRepeatable() && m_RewardedQuests.find(p_QuestID) != m_RewardedQuests.end())
            return false;                                   // not allow re-complete quest

        // auto complete quest
        if (l_Quest->IsAutoComplete() && CanTakeQuest(l_Quest, false))
            return true;

        QuestStatusMap::iterator itr = m_QuestStatus.find(p_QuestID);
        if (itr == m_QuestStatus.end())
            return false;

        QuestStatusData &q_status = itr->second;

        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
        {
            if (l_Quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT) && !q_status.Explored)
                return false;

            if (l_Quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && q_status.Timer == 0)
                return false;

            for (QuestObjective l_Objective : l_Quest->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_AREATRIGGER)
                {

                }
                else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_SPELL)
                {
                    if (!HasSpell(l_Objective.ObjectID))
                        return false;
                }
                else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2)
                {
                    uint32 l_RepFactionID = l_Objective.ObjectID;

                    if (l_RepFactionID && GetReputationMgr().GetReputation(l_RepFactionID) < l_Objective.Amount)
                        return false;
                }
                else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY)
                {
                    if (!HasEnoughMoney(-int64(l_Objective.Amount)))
                        return false;
                }
                else
                {
                    if (GetQuestObjectiveCounter(l_Objective.ID) < uint32(l_Objective.Amount))
                        return false;
                }
            }

            return true;
        }
    }
    return false;
}

bool Player::CanCompleteRepeatableQuest(const Quest * p_Quest)
{
    // Solve problem that player don't have the quest and try complete it.
    // if repeatable she must be able to complete event if player don't have it.
    // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
    if (!CanTakeQuest(p_Quest, false))
        return false;

    for (QuestObjective l_Objective : p_Quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
        {
            if (!HasItemCount(l_Objective.Amount, l_Objective.Amount))
                return false;
        }
    }

    if (!CanRewardQuest(p_Quest, false))
        return false;

    return true;
}

bool Player::CanRewardQuest(Quest const* p_Quest, bool msg)
{
    // not auto complete quest and not completed quest (only cheating case, then ignore without message)
    if (!p_Quest->IsDFQuest() && !p_Quest->IsAutoComplete() && GetQuestStatus(p_Quest->GetQuestId()) != QUEST_STATUS_COMPLETE)
        return false;

    // daily quest can't be rewarded (25 daily quest already completed)
    if (!SatisfyQuestDay(p_Quest) || !SatisfyQuestWeek(p_Quest, true) || !SatisfyQuestMonth(p_Quest, true) || !SatisfyQuestSeasonal(p_Quest, true))
        return false;

    // rewarded and not repeatable quest (only cheating case, then ignore without message)
    if (GetQuestRewardStatus(p_Quest->GetQuestId()))
        return false;

    if (!SatisfyQuestSkill(p_Quest, msg))
        return false;

    for (QuestObjective l_Objective : p_Quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_UNK_4))
        {
            if (GetItemCount(l_Objective.ObjectID) < uint32(l_Objective.Amount))
            {
                if (msg)
                    SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, l_Objective.ObjectID);

                return false;
            }
        }
        else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CURRENCY)
        {
            if (!HasCurrency(l_Objective.ObjectID, l_Objective.Amount))
                return false;
        }
        else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY)
        {
            if (!HasEnoughMoney(uint64(l_Objective.Amount)))
                return false;
        }
    }

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, uint32 p_Reward, bool msg)
{
    // prevent receive reward with quest items in bank or for not completed quest
    if (!CanRewardQuest(quest, msg))
        return false;

    /// - Quest have dynamic reward, skip legacy choice
    if (quest->GetQuestPackageID() != 0)
    {
        /// - Check if the reward is in dynamic reward list, and if player can take it (class/spec)
        for (QuestPackageItemEntry const* l_DynamicReward : quest->DynamicRewards)
        {
            if (l_DynamicReward->ItemId != p_Reward)
                continue;

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_DynamicReward->ItemId);
            if (!l_ItemTemplate)
                return false;

            /// Hackfix, but fix lot of quests since the selection work client-side
            /// See quest 24970 with a hunter
            {
                /// - We have find the reward, check if player can store it
                ItemPosCountVec l_Dest;
                InventoryResult l_Result = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemId, l_DynamicReward->Count);
                if (l_Result != EQUIP_ERR_OK)
                {
                    SendEquipError(l_Result, NULL, NULL, l_DynamicReward->ItemId);
                    return false;
                }

                return true;
            }

            uint32 l_Specialization = GetSpecializationId();
            if (!l_Specialization)
                l_Specialization = GetDefaultSpecId();

            switch (l_DynamicReward->Type)
            {
                case uint8(PackageItemRewardType::SpecializationReward):
                    if (!l_ItemTemplate->HasSpec((SpecIndex)l_Specialization, getLevel()))
                    {
                        GetSession()->SendNotification(LANG_NO_SPE_FOR_DYNAMIC_REWARD);
                        return false;
                    }
                    break;
                case uint8(PackageItemRewardType::ClassReward):
                    if (!l_ItemTemplate->HasClassSpec(getClass(), getLevel()))
                        return false;
                    break;
                case uint8(PackageItemRewardType::DefaultHiddenReward):                             ///< Yes, player can cheat to have it instead of his own specific item, but it's useless for him
                case uint8(PackageItemRewardType::NoRequire):
                    break;
                // Not implemented PackageItemRewardType
                default:
                    sLog->outError(LogFilterType::LOG_FILTER_PLAYER_ITEMS, "Not implemented PackageItemRewardType %u for quest %u", l_DynamicReward->Type, quest->GetQuestId());
                    continue;
            }

            /// - We have find the reward, check if player can store it
            ItemPosCountVec l_Dest;
            InventoryResult l_Result = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemId, l_DynamicReward->Count);
            if (l_Result != EQUIP_ERR_OK)
            {
                SendEquipError(l_Result, NULL, NULL, l_DynamicReward->ItemId);
                return false;
            }
            return true;
        }
        
        if (p_Reward == 0)
            return true;
        
        return false;
    }

    if (quest->GetRewChoiceItemsCount() > 0)
    {
        if (quest->RewardChoiceItemId[p_Reward])
        {
            ItemPosCountVec dest;
            InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardChoiceItemId[p_Reward], quest->RewardChoiceItemCount[p_Reward]);
            if (res != EQUIP_ERR_OK)
            {
                SendEquipError(res, NULL, NULL, quest->RewardChoiceItemId[p_Reward]);
                return false;
            }
        }
    }

    if (quest->GetRewItemsCount() > 0)
    {
        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
        {
            if (quest->RewardItemId[i])
            {
                ItemPosCountVec dest;
                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardItemId[i], quest->RewardItemIdCount[i]);
                if (res != EQUIP_ERR_OK)
                {
                    SendEquipError(res, NULL, NULL, quest->RewardItemId[i]);
                    return false;
                }
            }
        }
    }

    return true;
}

void Player::HandleAutoCompleteQuest(Quest const* p_Quest)
{
    if (p_Quest->IsAutoComplete())
    {
        for (QuestObjective l_Objective : p_Quest->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
            {
                uint32 id = l_Objective.ObjectID;
                uint32 count = l_Objective.Amount;

                if (!id || !count)
                    continue;

                uint32 curItemCount = GetItemCount(id, true);

                ItemPosCountVec dest;
                uint8 msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count - curItemCount);
                if (msg == EQUIP_ERR_OK)
                {
                    Item* item = StoreNewItem(dest, id, true);
                    SendNewItem(item, count - curItemCount, true, false);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC)
            {
                int32 creature = l_Objective.ObjectID;
                uint32 creaturecount = l_Objective.Amount;

                if (CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(creature))
                {
                    for (uint16 z = 0; z < creaturecount; ++z)
                        KilledMonster(cInfo, 0);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_GO)
            {
                for (uint16 z = 0; z < l_Objective.Amount; ++z)
                    CastedCreatureOrGO(l_Objective.ObjectID, 0, 0);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_SPELL)
            {
                /// @TODO
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CURRENCY)
            {
                if (!l_Objective.ObjectID || !l_Objective.Amount)
                    continue;

                ModifyCurrency(l_Objective.ObjectID, l_Objective.Amount);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2)
            {
                if (GetReputationMgr().GetReputation(l_Objective.ObjectID) < l_Objective.Amount)
                {
                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(l_Objective.ObjectID))
                        GetReputationMgr().SetReputation(factionEntry, l_Objective.Amount);
                }
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY)
            {
                ModifyMoney(l_Objective.Amount);
            }
            else if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE)
            {
                QuestObjectiveSatisfy(l_Objective.ObjectID, l_Objective.Amount, l_Objective.Type);
            }
        }

        CompleteQuest(p_Quest->GetQuestId());
    }
}

void Player::AddQuest(Quest const* quest, Object* questGiver)
{
    uint16 log_slot = FindQuestSlot(0);

    if (log_slot >= MAX_QUEST_LOG_SIZE) // Player does not have any free slot in the quest log
        return;

    uint32 quest_id = quest->GetQuestId();

    // if not exist then created with set uState == NEW and rewarded=false
    QuestStatusData& questStatusData = m_QuestStatus[quest_id];

    // check for repeatable quests status reset
    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
    questStatusData.Explored = false;

    for (QuestObjective l_Objective : quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2)
        {
            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(l_Objective.ObjectID))
                GetReputationMgr().SetVisible(factionEntry);
        }

        // not all Quest Objective types need to be tracked, some such as reputation are handled/checked externally
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_SPELL
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_MONEY
            || l_Objective.Type == QUEST_OBJECTIVE_TYPE_AREATRIGGER)
            continue;

        m_questObjectiveStatus.insert(std::make_pair(l_Objective.ID, uint32(0)));
    }

    GiveQuestSourceItem(quest);
    AdjustQuestReqItemCount(quest);

    uint32 qtime = 0;
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        uint32 limittime = quest->GetLimitTime();

        // shared timed quest
        if (questGiver && questGiver->IsPlayer())
            limittime = questGiver->ToPlayer()->getQuestStatusMap()[quest_id].Timer / IN_MILLISECONDS;

        AddTimedQuest(quest_id);
        questStatusData.Timer = limittime * IN_MILLISECONDS;
        qtime = static_cast<uint32>(time(NULL)) + limittime;
    }
    else
        questStatusData.Timer = 0;

    SetQuestSlot(log_slot, quest_id, qtime);

    m_QuestStatusSave[quest_id] = true;

    GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_QUEST, quest_id);

    //starting initial quest script
    if (questGiver && quest->GetQuestStartScript() != 0)
        GetMap()->ScriptsStart(sQuestStartScripts, quest->GetQuestStartScript(), questGiver, this);

    CheckSpellAreaOnQuestStatusChange(quest_id);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    UpdateForQuestWorldObjects();

#ifndef CROSS
    if (m_Garrison && IsInGarrison())
        m_Garrison->OnQuestStarted(quest);
#endif

    sScriptMgr->OnQuestAccept(this, quest);

    if (quest->QuestObjectives.empty())
        CompleteQuest(quest->GetQuestId());

    HandleAutoCompleteQuest(quest);
}

void Player::CompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_COMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_0_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_1_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_2_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_3_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_4_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_5_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_6_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_7_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_8_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_9_COMPLETE);
            SetQuestSlotState(log_slot, QUEST_STATE_OBJ_10_COMPLETE);
        }

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
        {
            if (qInfo->HasFlag(QUEST_FLAGS_AUTO_REWARDED))
                RewardQuest(qInfo, 0, this, false);
            else
                SendQuestComplete(qInfo);

            sScriptMgr->OnQuestComplete(this, qInfo);
        }

#ifndef CROSS
        if (Guild* l_Guild = GetGuild())
            l_Guild->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_GUILD, 1, 0, 0, nullptr, this);
#endif
    }
}

void Player::IncompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_INCOMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            RemoveQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
    }
}

void Player::RewardQuest(Quest const* p_Quest, uint32 p_Reward, Object* p_QuestGiver, bool p_Announce)
{
    //this THING should be here to protect code from quest, which cast on player far teleport as a reward
    //should work fine, cause far teleport will be executed in Player::Update()
    SetCanDelayTeleport(true);

    uint32 l_QuestId = p_Quest->GetQuestId();

    for (auto l_Objective : p_Quest->QuestObjectives)
    {
        switch (l_Objective.Type)
        {
            case QUEST_OBJECTIVE_TYPE_ITEM:
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_UNK_4))
                {
                    if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Objective.ObjectID))
                    {
                        if (!l_ItemProto->IsQuestItem())
                            DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true);
                    }
                }
                break;
            }
            case QUEST_OBJECTIVE_TYPE_CURRENCY:
            {
                ModifyCurrency(l_Objective.ObjectID, -int32(l_Objective.Amount));
                break;
            }
            case QUEST_OBJECTIVE_TYPE_MONEY:
            {
                ModifyMoney(-int64(l_Objective.Amount));
                break;
            }
            default:
                break;
        }
    }

    if (!p_Quest->HasFlag2(QUEST_FLAGS2_KEEP_ADDITIONAL_ITEMS))
    {
        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
        {
            if (p_Quest->RequiredSourceItemId[i])
            {
                uint32 count = p_Quest->RequiredSourceItemCount[i];
                DestroyItemCount(p_Quest->RequiredSourceItemId[i], count ? count : 9999, true);
            }
        }
    }

    RemoveTimedQuest(l_QuestId);

    /// - Quest have dynamic reward, skip legacy choice
    if (p_Quest->GetQuestPackageID() != 0)
    {
        /// - Check if the reward is in dynamic reward list, and if player can take it (class/spec)
        for (QuestPackageItemEntry const* l_DynamicReward : p_Quest->DynamicRewards)
        {
            if (l_DynamicReward->ItemId != p_Reward)
                continue;

            ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_DynamicReward->ItemId);
            if (!l_ItemTemplate)
                break;

            /*switch (l_DynamicReward->Type)
            {
                case uint8(PackageItemRewardType::SpecializationReward):
                {
                    if (!l_ItemTemplate->HasSpec((SpecIndex)GetSpecializationId(), getLevel()) && !l_ItemTemplate->HasClassSpec(getClass(), getLevel()))
                        continue;
                    break;
                }
                case uint8(PackageItemRewardType::ClassReward):
                    if (!l_ItemTemplate->HasClassSpec(getClass(), getLevel()))
                        continue;
                    break;
                case uint8(PackageItemRewardType::DefaultHiddenReward):                             ///< Yes, player can cheat to have it instead of his own specific item, but it's useless for him
                case uint8(PackageItemRewardType::NoRequire):
                    break;
                default:
                    continue;
            }*/

            ItemPosCountVec l_Dest;
            if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_DynamicReward->ItemId, l_DynamicReward->Count) == EQUIP_ERR_OK)
            {
                Item* l_Item = StoreNewItem(l_Dest, l_DynamicReward->ItemId, true, Item::GenerateItemRandomPropertyId(l_DynamicReward->ItemId));

                /// - If quest is WoD quest & item is stuff, there is a chance player get bonus on the item
                if (l_Item->IsStuffItem())
                {
                    AreaTableEntry const* l_AreaTable = GetAreaEntryByAreaID(p_Quest->GetZoneOrSort());
                    if (l_AreaTable != nullptr)
                    {
                        MapEntry const* l_Map = sMapStore.LookupEntry(l_AreaTable->ContinentID);
                        if (l_Map != nullptr
                            && l_Map->Expansion() == Expansion::EXPANSION_WARLORDS_OF_DRAENOR)
                        {
                            float l_Roll = frand(0.0f, 100.0f);
                            float l_Coeff = 1.0f;
#ifndef CROSS
                            if (GetGarrison() && GetGarrison()->HasBuildingType(MS::Garrison::Building::Type::Armory))
                                l_Coeff *= 2.0f;
#endif
                            //bool  l_SendDisplayToast = false;

                            // If item is uncommon & chance match, add uncommun to rare modifier
                            if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_UNCOMMON
                                && l_Roll > (gQuestRewardBonusRareChanceRange[0] * l_Coeff) && l_Roll < (gQuestRewardBonusRareChanceRange[1] * l_Coeff))
                            {
                                l_Item->AddItemBonus((uint32)QuestRewardItemBonus::UncommunToRare);
                                //l_SendDisplayToast = true;
                            }

                            if (l_Roll > (gQuestRewardBonusEpicChanceRange[0] * l_Coeff) && l_Roll < (gQuestRewardBonusEpicChanceRange[1] * l_Coeff))
                            {
                                if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_UNCOMMON)
                                {
                                    l_Item->AddItemBonus((uint32)QuestRewardItemBonus::UncommunToEpic);
                                    //l_SendDisplayToast = true;
                                }
                                else if (l_ItemTemplate->Quality == ItemQualities::ITEM_QUALITY_RARE)
                                {
                                    l_Item->AddItemBonus((uint32)QuestRewardItemBonus::RareToEpic);
                                    //l_SendDisplayToast = true;
                                }
                            }

                            /// - Look like the client automaticaly display the popup without send display toast if bonus is sended in SMSG_PUSH_ITEM_RESULT
                            //if (l_SendDisplayToast)
                                //SendDisplayToast(l_ItemTemplate->ItemId, l_DynamicReward->Count, DisplayToastMethod::DISPLAY_TOAST_METHOD_LOOT, TOAST_TYPE_NEW_ITEM, false, false, l_Item->GetAllItemBonuses());
                        }
                    }
                }

                SendNewItem(l_Item, l_DynamicReward->Count, true, false, false);
            }
            break;
        }
    }
    else
    {
        if (p_Quest->GetRewChoiceItemsCount() > 0)
        {
            if (uint32 itemId = p_Quest->RewardChoiceItemId[p_Reward])
            {
                ItemPosCountVec l_Dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, itemId, p_Quest->RewardChoiceItemCount[p_Reward]) == EQUIP_ERR_OK)
                {
                    Item* l_Item = StoreNewItem(l_Dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
                    SendNewItem(l_Item, p_Quest->RewardChoiceItemCount[p_Reward], true, false);
                }
            }
        }

        if (p_Quest->GetRewItemsCount() > 0)
        {
            for (uint32 l_I = 0; l_I < p_Quest->GetRewItemsCount(); ++l_I)
            {
                if (uint32 l_ItemId = p_Quest->RewardItemId[l_I])
                {
                    ItemPosCountVec l_Dest;
                    if (CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemId, p_Quest->RewardItemIdCount[l_I]) == EQUIP_ERR_OK)
                    {
                        Item* l_Item = StoreNewItem(l_Dest, l_ItemId, true, Item::GenerateItemRandomPropertyId(l_ItemId));
                        SendNewItem(l_Item, p_Quest->RewardItemIdCount[l_I], true, false);
                    }
                }
            }
        }
    }

    if (p_Quest->GetRewCurrencyCount() > 0)
    {
        for (uint32 i = 0; i < p_Quest->GetRewCurrencyCount(); ++i)
        {
            if (uint32 currencyId = p_Quest->RewardCurrencyId[i])
            {
                CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyId);
                if (uint32 countCurrency = p_Quest->RewardCurrencyCount[i])
                {
                    if (currency->Flags & CURRENCY_FLAG_HIGH_PRECISION)
                        countCurrency *= 100;
                    ModifyCurrency(currencyId, countCurrency);
                }
            }
        }
    }

    RewardReputation(p_Quest);
    RewardGuildReputation(p_Quest);
    RewardSkill(p_Quest);

    uint16 log_slot = FindQuestSlot(l_QuestId);
    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlot(log_slot, 0);

    bool rewarded = (m_RewardedQuests.find(l_QuestId) != m_RewardedQuests.end());

    float QuestXpRate = 1;

    if (GetPersonnalXpRate())
        QuestXpRate = GetPersonnalXpRate();
    else
        QuestXpRate = sWorld->getRate(RATE_XP_QUEST);

    // Not give XP in case already completed once repeatable quest
    uint32 XP = rewarded ? 0 : uint32(p_Quest->XPValue(this) * QuestXpRate);

    // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
    Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
    for (Unit::AuraEffectList::const_iterator l_I = ModXPPctAuras.begin(); l_I != ModXPPctAuras.end(); ++l_I)
        AddPct(XP, (*l_I)->GetAmount());

    //if (GetSession()->IsPremium())
    //    XP *= sWorld->getRate(RATE_XP_QUEST_PREMIUM);

    uint32 moneyRew = 0;
    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        GiveXP(XP, NULL);
    else
        moneyRew = uint32(p_Quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY));

    moneyRew += p_Quest->GetRewMoney();
    ModifyMoney(moneyRew);

    if (moneyRew > 0)
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_QUEST_REWARD, uint32(moneyRew));

    // honor reward
    if (uint32 honor = p_Quest->CalculateHonorGain(getLevel()))
        RewardHonor(NULL, 0, honor);

    // title reward
    if (p_Quest->GetCharTitleId())
    {
        if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(p_Quest->GetCharTitleId()))
            SetTitle(titleEntry);
    }

    if (uint32 talents = p_Quest->GetBonusTalents())
    {
        AddQuestRewardedTalentCount(talents);
        InitTalentForLevel();
    }

#ifndef CROSS
    // Send reward mail
    if (uint32 mail_template_id = p_Quest->GetRewMailTemplateId())
    {
        //- TODO: Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft(mail_template_id).SendMailTo(trans, this, p_QuestGiver, MAIL_CHECK_MASK_HAS_BODY, p_Quest->GetRewMailDelaySecs());
        CharacterDatabase.CommitTransaction(trans);
    }
#endif

    if (p_Quest->IsDaily() || p_Quest->IsDFQuest())
    {
        SetDailyQuestStatus(l_QuestId);
        if (p_Quest->IsDaily())
        {
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, l_QuestId);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, l_QuestId);
        }
    }
    else if (p_Quest->IsWeekly())
        SetWeeklyQuestStatus(l_QuestId);
    else if (p_Quest->IsMonthly())
        SetMonthlyQuestStatus(l_QuestId);
    else if (p_Quest->IsSeasonal())
        SetSeasonalQuestStatus(l_QuestId);

    m_RewardedQuests.insert(l_QuestId);
    m_RewardedQuestsSave[l_QuestId] = true;

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(l_QuestId);
    phaseMgr.NotifyConditionChanged(phaseUdateData);

    // Must come after the insert in m_RewardedQuests because of spell_area check
    RemoveActiveQuest(l_QuestId);

    phaseUdateData.AddQuestUpdate(l_QuestId);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    // StoreNewItem, mail reward, etc. save data directly to the database
    // to prevent exploitable data desynchronisation we save the quest status to the database too
    // (to prevent rewarding this quest another time while rewards were already given out)
    SQLTransaction trans = SQLTransaction(NULL);
    _SaveQuestStatus(trans);

    if (p_Announce)
        SendQuestReward(p_Quest, XP, p_QuestGiver);

    // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
    if (p_Quest->GetRewSpellCast() > 0)
        CastSpell(this, p_Quest->GetRewSpellCast(), true);
    else if (p_Quest->GetRewSpell() > 0)
        CastSpell(this, p_Quest->GetRewSpell(), true);

    sScriptMgr->OnQuestReward(this, p_Quest);

#ifndef CROSS
    if (m_Garrison && IsInGarrison())
        m_Garrison->OnQuestReward(p_Quest);
#endif

    if (p_Quest->GetZoneOrSort() > 0)
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_IN_ZONE, p_Quest->GetZoneOrSort());
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST_COUNT);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST, p_Quest->GetQuestId());

    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(l_QuestId))
        SetQuestBit(l_QuestBit, true);

    //lets remove flag for delayed teleports
    SetCanDelayTeleport(false);
}

void Player::FailQuest(uint32 questId)
{
    if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
    {
        SetQuestStatus(questId, QUEST_STATUS_FAILED);

        uint16 log_slot = FindQuestSlot(questId);

        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotTimer(log_slot, 1);
            SetQuestSlotState(log_slot, QUEST_STATE_FAIL);
        }

        if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
        {
            QuestStatusData& q_status = m_QuestStatus[questId];

            RemoveTimedQuest(questId);
            q_status.Timer = 0;

            SendQuestTimerFailed(questId);
        }
        else
            SendQuestFailed(questId);

        // Destroy quest items on quest failure.
        if (quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        {
            for (QuestObjective l_Objective : quest->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
                {
                    DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true, true);
                }
            }
        }

        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
            if (quest->RequiredSourceItemId[i] > 0 && quest->RequiredSourceItemCount[i] > 0)
                // Destroy items received during the quest.
                DestroyItemCount(quest->RequiredSourceItemId[i], quest->RequiredSourceItemCount[i], true, true);
    }
}

bool Player::SatisfyQuestSkill(Quest const* qInfo, bool msg) const
{
    uint32 skill = qInfo->GetRequiredSkill();

    // skip 0 case RequiredSkill
    if (skill == 0)
        return true;

    uint32 skill_value = qInfo->GetRequiredSkillValue();
    if (skill_value == 0)
        skill_value = 1;

    // check skill value
    if (GetSkillValue(skill) < skill_value)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

            if (m_IsDebugQuestLogs && GetSession())
                ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_MISSING_SKILL);
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestLevel(Quest const* qInfo, bool msg)
{
    if (getLevel() < qInfo->GetMinLevel())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_LOW_LEVEL);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_TOO_LOW_LVL);
        }

        return false;
    }
    else if (qInfo->GetMaxLevel() > 0 && getLevel() > qInfo->GetMaxLevel())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ); // There doesn't seem to be a specific response for too high player level

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_TOO_HIGH_LVL);
        }

        return false;
    }
    return true;
}

bool Player::SatisfyQuestLog(bool msg)
{
    // exist free slot
    if (FindQuestSlot(0) < MAX_QUEST_LOG_SIZE)
        return true;

    if (msg)
    {
        WorldPacket data(SMSG_QUEST_LOG_FULL, 0);
        GetSession()->SendPacket(&data);

        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_QUEST_LOG);
    }

    return false;
}

bool Player::SatisfyQuestPreviousQuest(Quest const* qInfo, bool msg)
{
    // No previous quest (might be first quest in a series)
    if (qInfo->prevQuests.empty())
        return true;

    for (Quest::PrevQuests::const_iterator iter = qInfo->prevQuests.begin(); iter != qInfo->prevQuests.end(); ++iter)
    {
        uint32 prevId = abs(*iter);

        Quest const* qPrevInfo = sObjectMgr->GetQuestTemplate(prevId);

        if (qPrevInfo)
        {
            // If any of the positive previous quests completed, return true
            if (*iter > 0 && m_RewardedQuests.find(prevId) != m_RewardedQuests.end())
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group completed and rewarded
                ObjectMgr::ExclusiveQuestGroups::iterator iter2 = sObjectMgr->mExclusiveQuestGroups.lower_bound(qPrevInfo->GetExclusiveGroup());
                ObjectMgr::ExclusiveQuestGroups::iterator end  = sObjectMgr->mExclusiveQuestGroups.upper_bound(qPrevInfo->GetExclusiveGroup());

                ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0

                for (; iter2 != end; ++iter2)
                {
                    uint32 exclude_Id = iter2->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be completed and rewarded(reported)
                    if (m_RewardedQuests.find(exclude_Id) == m_RewardedQuests.end())
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                            if (m_IsDebugQuestLogs)
                                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_EXCL_GRP_ALT_COMP);
                        }

                        return false;
                    }
                }
                return true;
            }

            // If any of the negative previous quests active, return true
            if (*iter < 0 && GetQuestStatus(prevId) != QUEST_STATUS_NONE)
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group active
                ObjectMgr::ExclusiveQuestGroups::iterator iter2 = sObjectMgr->mExclusiveQuestGroups.lower_bound(qPrevInfo->GetExclusiveGroup());
                ObjectMgr::ExclusiveQuestGroups::iterator end   = sObjectMgr->mExclusiveQuestGroups.upper_bound(qPrevInfo->GetExclusiveGroup());

                ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0

                for (; iter2 != end; ++iter2)
                {
                    uint32 exclude_Id = iter2->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be active
                    if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE)
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                            if (m_IsDebugQuestLogs)
                                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_EXCL_GRP_ALT_ACTIVE);
                        }

                        return false;
                    }
                }
                return true;
            }
        }
    }

    // Has only positive prev. quests in non-rewarded state
    // and negative prev. quests in non-active state
    if (msg)
    {
        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

        if (m_IsDebugQuestLogs)
            ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_PREV_QUEST);
    }

    return false;
}

bool Player::SatisfyQuestTeam(Quest const* qInfo)
{
    int8 reqteam = qInfo->GetRequiredTeam();

    if (reqteam < 0)
        return true;

    if (reqteam == GetTeamId())
        return true;

    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_FACTION);

    return false;
}

bool Player::SatisfyQuestClass(Quest const* qInfo, bool msg) const
{
    int32 reqClass = qInfo->GetRequiredClasses();

    if (!reqClass)
        return true;

    if (reqClass > 0)
    {
        // Positive = Only specified
        if ((reqClass & getClassMask()) == 0)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs && GetSession())
                    ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CLASS);
            }

            return false;
        }
    }
    else
    {
        // Negative = All except specified
        reqClass = -reqClass;

        if (reqClass & getClassMask())
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs && GetSession())
                    ChatHandler(GetSession()).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CLASS);
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestRace(Quest const* qInfo, bool msg)
{
    int32 reqraces = qInfo->GetRequiredRaces();
    if (!reqraces)
        return true;

    if (reqraces > 0)
    {
        // Positive = Only specified
        if ((reqraces & getRaceMask()) == 0)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_WRONG_RACE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_RACE);
            }

            return false;
        }
    }
    else
    {
        // Negative = All except specified
        reqraces = -reqraces;

        if (reqraces & getRaceMask())
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_WRONG_RACE);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_RACE);
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestReputation(Quest const* qInfo, bool msg)
{
    uint32 fIdMin = qInfo->GetRequiredMinRepFaction();      //Min required rep
    if (fIdMin && GetReputationMgr().GetReputation(fIdMin) < qInfo->GetRequiredMinRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_MIN_REP);
        }

        return false;
    }

    uint32 fIdMax = qInfo->GetRequiredMaxRepFaction();      //Max required rep
    if (fIdMax && GetReputationMgr().GetReputation(fIdMax) >= qInfo->GetRequiredMaxRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_MAX_REP);
        }

        return false;
    }

    // ReputationObjective2 does not seem to be an objective requirement but a requirement
    // to be able to accept the quest

    if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_FACTION_REP2))
        return true;

    for (QuestObjective l_Objective : qInfo->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2 && GetReputationMgr().GetReputation(l_Objective.ObjectID) >= l_Objective.Amount)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_OBJ_REP);
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestStatus(Quest const* p_QInfo, bool p_Msg)
{
    if (GetQuestStatus(p_QInfo->GetQuestId()) != QUEST_STATUS_NONE)
    {
        if (p_Msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ALREADY_ON);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_STATUS);
        }

        return false;
    }
    return true;
}

bool Player::SatisfyQuestConditions(Quest const* qInfo, bool msg)
{
    if (!sConditionMgr->IsObjectMeetingNotGroupedConditions(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, qInfo->GetQuestId(), this))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_CONDITION);
        }

        sLog->outDebug(LOG_FILTER_CONDITIONSYS, "Player::SatisfyQuestConditions: conditions not met for quest %u", qInfo->GetQuestId());

        return false;
    }
    return true;
}

bool Player::SatisfyQuestTimed(Quest const* qInfo, bool msg)
{
    if (!m_timedquests.empty() && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ONLY_ONE_TIMED);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WRONG_TIME);
        }

        return false;
    }
    return true;
}

bool Player::SatisfyQuestExclusiveGroup(Quest const* qInfo, bool msg)
{
    // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
    if (qInfo->GetExclusiveGroup() <= 0)
        return true;

    ObjectMgr::ExclusiveQuestGroups::iterator iter = sObjectMgr->mExclusiveQuestGroups.lower_bound(qInfo->GetExclusiveGroup());
    ObjectMgr::ExclusiveQuestGroups::iterator end  = sObjectMgr->mExclusiveQuestGroups.upper_bound(qInfo->GetExclusiveGroup());

    //ASSERT(iter != end);                                      // always must be found if qInfo->ExclusiveGroup != 0

    for (; iter != end; ++iter)
    {
        uint32 exclude_Id = iter->second;

        // skip checked quest id, only state of other quests in group is interesting
        if (exclude_Id == qInfo->GetQuestId())
            continue;

        // not allow have daily quest if daily quest from exclusive group already recently completed
        Quest const* Nquest = sObjectMgr->GetQuestTemplate(exclude_Id);
        if (!SatisfyQuestDay(Nquest) || !SatisfyQuestWeek(Nquest, false) || !SatisfyQuestSeasonal(Nquest,false))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DOUBLE_EXCL);
            }

            return false;
        }

        // alternative quest already started or completed - but don't check rewarded states if both are repeatable
        if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE || (!(qInfo->IsRepeatable() && Nquest->IsRepeatable()) && (m_RewardedQuests.find(exclude_Id) != m_RewardedQuests.end())))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_ALT_QUEST);
            }

            return false;
        }
    }
    return true;
}

bool Player::SatisfyQuestNextChain(Quest const* qInfo, bool msg)
{
    uint32 nextQuest = qInfo->GetNextQuestInChain();
    if (!nextQuest)
        return true;

    // next quest in chain already started or completed
    if (GetQuestStatus(nextQuest) != QUEST_STATUS_NONE) // GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_CHAIN_NEXT);
        }

        return false;
    }

    // check for all quests further up the chain
    // only necessary if there are quest chains with more than one quest that can be skipped
    //return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
    return true;
}

bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
{
    // No previous quest in chain
    if (qInfo->prevChainQuests.empty())
        return true;

    for (Quest::PrevChainQuests::const_iterator iter = qInfo->prevChainQuests.begin(); iter != qInfo->prevChainQuests.end(); ++iter)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(*iter);

        // If any of the previous quests in chain active, return false
        if (itr != m_QuestStatus.end() && itr->second.Status != QUEST_STATUS_NONE)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);

                if (m_IsDebugQuestLogs)
                    ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_CHAIN_PREV);
            }

            return false;
        }

        // check for all quests further down the chain
        // only necessary if there are quest chains with more than one quest that can be skipped
        //if (!SatisfyQuestPrevChain(prevId, msg))
        //    return false;
    }

    // No previous quest in chain active
    return true;
}

bool Player::SatisfyQuestDay(Quest const* qInfo)
{
    if (!qInfo->IsDaily() && !qInfo->IsDFQuest())
        return true;

    for (auto id : m_dailyQuestStorage)
    {
        if (qInfo->GetQuestId() == id)
        {
            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DAILY_DONE);

            return false;
        }
    }

    if (qInfo->IsDFQuest())
    {
        if (!m_DFQuests.empty())
        {
            if (m_IsDebugQuestLogs)
                ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_DF_DAILY);

            return false;
        }

        return true;
    }

    return true;
}

bool Player::SatisfyQuestWeek(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsWeekly() || m_weeklyquests.empty())
        return true;


    if (m_weeklyquests.find(qInfo->GetQuestId()) == m_weeklyquests.end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_WEEKLY_DONE);

    return false;
}

bool Player::SatisfyQuestSeasonal(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsSeasonal() || m_seasonalquests.empty())
        return true;

    uint16 l_EventId = sGameEventMgr->GetEventIdForQuest(qInfo);
    if (m_seasonalquests.find(l_EventId) == m_seasonalquests.end() || m_seasonalquests[l_EventId].empty())
        return true;

    if (m_seasonalquests[l_EventId].find(qInfo->GetQuestId()) == m_seasonalquests[l_EventId].end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_SEASONNAL_DONE);

    return false;
}

bool Player::SatisfyQuestMonth(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsMonthly() || m_monthlyquests.empty())
        return true;

    if (m_monthlyquests.find(qInfo->GetQuestId()) == m_monthlyquests.end())
        return true;

    /// if not found in cooldown list
    if (m_IsDebugQuestLogs)
        ChatHandler(this).PSendSysMessage(LANG_DEBUG_QUEST_LOGS_MONTHLY_DONE);

    return false;
}

bool Player::GiveQuestSourceItem(Quest const* quest)
{
    uint32 srcitem = quest->GetSrcItemId();
    if (srcitem > 0)
    {
        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);
        if (msg == EQUIP_ERR_OK)
        {
            Item* item = StoreNewItem(dest, srcitem, true);
            SendNewItem(item, QUEST_SOURCE_ITEM_COUNT, true, false);
            return true;
        }
        // player already have max amount required item, just report success
        else if (msg == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else
            SendEquipError(msg, NULL, NULL, srcitem);
        return false;
    }

    return true;
}

bool Player::TakeQuestSourceItem(uint32 questId, bool msg)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
    if (quest)
    {
        uint32 srcItemId = quest->GetSrcItemId();
        ItemTemplate const* item = sObjectMgr->GetItemTemplate(srcItemId);

        if (srcItemId > 0)
        {
            // exist two cases when destroy source quest item not possible:
            // a) non un-equippable item (equipped non-empty bag, for example)
            // b) when quest is started from an item and item also is needed in
            // the end as RequiredItemId
            InventoryResult res = CanUnequipItems(srcItemId, QUEST_SOURCE_ITEM_COUNT);
            if (res != EQUIP_ERR_OK)
            {
                if (msg)
                    SendEquipError(res, NULL, NULL, srcItemId);
                return false;
            }

            if (!quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
                return true;

            bool destroyItem = true;

            for (QuestObjective l_Objective : quest->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && item->StartQuest == questId && srcItemId == (uint32)l_Objective.ObjectID)
                    destroyItem = false;
            }

            if (destroyItem)
                DestroyItemCount(srcItemId, QUEST_SOURCE_ITEM_COUNT, true, true);
        }
    }

    return true;
}

bool Player::GetQuestRewardStatus(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (qInfo)
    {
        // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
        if (!qInfo->IsRepeatable())
            return m_RewardedQuests.find(quest_id) != m_RewardedQuests.end();

        return false;
    }
    return false;
}

QuestStatus Player::GetQuestStatus(uint32 quest_id) const
{
    if (quest_id)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
        if (itr != m_QuestStatus.end())
            return itr->second.Status;

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
            if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
                return QUEST_STATUS_REWARDED;
    }
    return QUEST_STATUS_NONE;
}

bool Player::CanShareQuest(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (qInfo && qInfo->HasFlag(QUEST_FLAGS_SHARABLE))
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
        if (itr != m_QuestStatus.end())
            return itr->second.Status == QUEST_STATUS_INCOMPLETE;
    }
    return false;
}

void Player::SetQuestStatus(uint32 quest_id, QuestStatus status)
{
    if (sObjectMgr->GetQuestTemplate(quest_id))
    {
        m_QuestStatus[quest_id].Status = status;
        m_QuestStatusSave[quest_id] = true;
    }

    CheckSpellAreaOnQuestStatusChange(quest_id);

    PhaseUpdateData phaseUdateData;
    phaseUdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUdateData);

    UpdateForQuestWorldObjects();
}

void Player::RemoveActiveQuest(uint32 quest_id, bool p_BonusQuest)
{
    QuestStatusMap::iterator itr = m_QuestStatus.find(quest_id);
    if (itr != m_QuestStatus.end())
    {
        m_QuestStatus.erase(itr);

        const Quest * l_Quest = sObjectMgr->GetQuestTemplate(quest_id);

        if (!p_BonusQuest)
        {
// Not sure, need to find real flag value (LANG_CANT_ABANDON_QUEST_FLAGGED undefined in trinity_string)
//             if ((l_Quest->GetFlags2() & QUEST_FLAGS2_NO_ABANDON_ON_ANY_OBJECTIVE_COMPLETE) != 0)
//             {
//                 for (QuestObjective l_Objective : l_Quest->QuestObjectives)
//                 {
//                     if (m_questObjectiveStatus[l_Objective.ID] == l_Objective.Amount)
//                     {
//                         if (GetSession())
//                             GetSession()->SendNotification(LANG_CANT_ABANDON_QUEST_FLAGGED);
//
//                         return;
//                     }
//                 }
//             }
            m_QuestStatusSave[quest_id] = false;

            if (l_Quest)
            {
                for (QuestObjective l_Objective : l_Quest->QuestObjectives)
                {
                    m_questObjectiveStatus[l_Objective.ID] = 0;

                    if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && !(l_Objective.Flags & QuestObjectiveFlags::QUEST_OBJECTIVE_FLAG_UNK_4))
                    {
                        if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Objective.ObjectID))
                        {
                            if (l_ItemProto->IsQuestItem())
                                DestroyItemCount(l_Objective.ObjectID, l_Objective.Amount, true);
                        }
                    }
                }
            }
        }

        CheckSpellAreaOnQuestStatusChange(quest_id);

        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(quest_id);

        phaseMgr.NotifyConditionChanged(phaseUdateData);

#ifndef CROSS
        if (m_Garrison && IsInGarrison())
            m_Garrison->OnQuestAbandon(l_Quest);
#endif

        if (!IsQuestRewarded(quest_id))
            sScriptMgr->OnQuestAbandon(this, l_Quest);

        return;
    }
}

void Player::RemoveRewardedQuest(uint32 p_QuestId)
{
    RewardedQuestSet::iterator rewItr = m_RewardedQuests.find(p_QuestId);
    if (rewItr != m_RewardedQuests.end())
    {
        m_RewardedQuests.erase(rewItr);
        m_RewardedQuestsSave[p_QuestId] = false;

        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(p_QuestId);

        phaseMgr.NotifyConditionChanged(phaseUdateData);

        if (uint32 l_QuestBit = GetQuestUniqueBitFlag(p_QuestId))
            SetQuestBit(l_QuestBit, false);
    }
}

// not used in Trinity, but used in scripting code
uint16 Player::GetReqKillOrCastCurrentCount(uint32 quest_id, int32 entry)
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);

    if (!qInfo)
        return 0;

    for (QuestObjective l_Objective : qInfo->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC && l_Objective.ObjectID == entry)
        {
            return GetQuestObjectiveCounter(l_Objective.ID);
        }
    }

    return 0;
}

void Player::AreaExploredOrEventHappens(uint32 questId)
{
    if (questId)
    {
        uint16 log_slot = FindQuestSlot(questId);
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            QuestStatusData& q_status = m_QuestStatus[questId];

            if (!q_status.Explored)
            {
                q_status.Explored = true;
                m_QuestStatusSave[questId] = true;
            }
        }
        if (CanCompleteQuest(questId))
            CompleteQuest(questId);
    }
}

void Player::AdjustQuestReqItemCount(Quest const* quest)
{
    if (!quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        return;

    for (QuestObjective l_Objective : quest->QuestObjectives)
    {
        if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM)
        {
            m_questObjectiveStatus[l_Objective.ID] = std::min(GetItemCount(l_Objective.ObjectID, true), uint32(l_Objective.Amount));
            m_QuestStatusSave[quest->GetQuestId()] = true;
        }
    }
}

uint16 Player::FindQuestSlot(uint32 quest_id) const
{
    for (uint16 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
        if (GetQuestSlotQuestId(i) == quest_id)
            return i;

    return MAX_QUEST_LOG_SIZE;
}

//not used in Trinityd, function for external script library
void Player::GroupEventHappens(uint32 questId, WorldObject const* pEventObject)
{
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* player = itr->getSource();

            // for any leave or dead (with not released body) group member at appropriate distance
            if (player && player->IsAtGroupRewardDistance(pEventObject) && !player->GetCorpse())
                player->AreaExploredOrEventHappens(questId);
        }
    }
    else
        AreaExploredOrEventHappens(questId);
}

void Player::ItemAddedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData& q_status = m_QuestStatus[questid];

        if (q_status.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        for (QuestObjective l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && (uint32)l_Objective.ObjectID == entry)
            {
                uint32 currentCounter = GetQuestObjectiveCounter(l_Objective.ID);
                uint32 requiredCounter = uint32(l_Objective.Amount);

                if (currentCounter < requiredCounter)
                {
                    uint16 addCount = currentCounter + count <= requiredCounter ? count : requiredCounter - currentCounter;
                    m_questObjectiveStatus[l_Objective.ID] += addCount;
                    m_QuestStatusSave[questid] = true;

                    SendQuestUpdateAddCredit(qInfo, l_Objective, ObjectGuid(0), currentCounter, addCount);
                }

                if (CanCompleteQuest(questid))
                    CompleteQuest(questid);

                return;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::ItemRemovedQuestCheck(int32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);

        if (!questid)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questid];
        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);

        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
            continue;

        for (QuestObjective l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_ITEM && l_Objective.ObjectID == entry)
            {
                uint32 currentCounter = questStatus.Status != QUEST_STATUS_COMPLETE ? GetQuestObjectiveCounter(l_Objective.ID) : GetItemCount(entry, true);
                uint32 requiredCounter = uint32(l_Objective.Amount);

                if (currentCounter < requiredCounter)
                {
                    uint16 remainingItems = currentCounter <= requiredCounter ? count : count + requiredCounter - currentCounter;

                    m_questObjectiveStatus[l_Objective.ID] = (currentCounter <= remainingItems) ? 0 : currentCounter - remainingItems;
                    m_QuestStatusSave[questid] = true;

                    IncompleteQuest(questid);
                }

                break;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::KilledMonster(CreatureTemplate const* cInfo, uint64 guid)
{
    if (cInfo->Entry)
        KilledMonsterCredit(cInfo->Entry, guid);

    for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
        if (cInfo->KillCredit[i])
            KilledMonsterCredit(cInfo->KillCredit[i], 0);
}

void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
{
    uint16 addkillcount = 1;
    uint32 real_entry = entry;
    if (guid)
    {
        Creature* killed = GetMap()->GetCreature(guid);
        if (killed && killed->GetEntry())
            real_entry = killed->GetEntry();
    }

    GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_CREATURE, real_entry);   // MUST BE CALLED FIRST
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, real_entry, addkillcount, 0, guid ? GetMap()->GetCreature(guid) : NULL);

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;
        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& q_status = m_QuestStatus[questid];
        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid()))
        {
            for (QuestObjective l_Objective : qInfo->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_NPC && l_Objective.ObjectID == (int32)real_entry)
                {
#ifndef CROSS
                    if (MS::Garrison::Manager* l_GarrisonMgr = GetGarrison())
                    {
                        if (!l_GarrisonMgr->CheckGarrisonStablesQuestsConditions(questid, this))
                            continue;
                    }
#endif
                    uint32 currentCounter = GetQuestObjectiveCounter(l_Objective.ID);
                    if (currentCounter < uint32(l_Objective.Amount))
                    {
                        m_questObjectiveStatus[l_Objective.ID] += addkillcount;
                        m_QuestStatusSave[questid] = true;
                        SendQuestUpdateAddCredit(qInfo, l_Objective, guid, currentCounter, addkillcount);
                    }

                    if ((uint32)l_Objective.Amount == m_questObjectiveStatus[l_Objective.ID])
                        sScriptMgr->OnObjectiveValidate(this, questid, l_Objective.ID);

                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);

                    break;
                }
            }
        }
    }
}

void Player::KilledPlayerCredit()
{
    uint16 addkillcount = 1;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;
        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& q_status = m_QuestStatus[questid];
        if (q_status.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid()))
        {
            for (QuestObjective l_Objective : qInfo->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_PLAYER)
                {
                    uint32 currentCounter = GetQuestObjectiveCounter(l_Objective.ID);
                    if (currentCounter < uint32(l_Objective.Amount))
                    {
                        m_questObjectiveStatus[l_Objective.ID] = currentCounter + addkillcount;
                        m_QuestStatusSave[questid] = true;

                        SendQuestUpdateAddPlayer(qInfo, l_Objective, currentCounter, addkillcount);
                    }

                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);

                    break;
                }
            }
        }
    }
}

void Player::CastedCreatureOrGO(uint32 /*entry*/, uint64 guid, uint32 spell_id)
{
    QuestObjectiveSatisfy(spell_id, 1, QUEST_OBJECTIVE_TYPE_SPELL, guid);
}

void Player::TalkedToCreature(uint32 entry, uint64 guid)
{
    QuestObjectiveSatisfy(entry, 1, QUEST_OBJECTIVE_TYPE_NPC_INTERACT, guid);
}

void Player::MoneyChanged(uint64 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (qInfo && qInfo->GetRewMoney() < 0)
        {
            QuestStatusData& q_status = m_QuestStatus[questid];

            if (q_status.Status == QUEST_STATUS_INCOMPLETE)
            {
                if (int32(count) >= -qInfo->GetRewMoney())
                {
                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);
                }
            }
            else if (q_status.Status == QUEST_STATUS_COMPLETE)
            {
                if (int32(count) < -qInfo->GetRewMoney())
                    IncompleteQuest(questid);
            }
        }
    }
}

void Player::ReputationChanged(FactionEntry const* factionEntry)
{
    ReputationChangedQuestCheck(factionEntry);
}

void Player::ReputationChanged2(FactionEntry const* factionEntry)
{
    ReputationChangedQuestCheck(factionEntry);
}

void Player::ReputationChangedQuestCheck(FactionEntry const* factionEntry)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_FACTION_REP2))
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];

        for (QuestObjective l_Objective : qInfo->QuestObjectives)
        {
            if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP2 || l_Objective.Type == QUEST_OBJECTIVE_TYPE_FACTION_REP)
            {
                if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) >= l_Objective.Amount)
                        if (CanCompleteQuest(questId))
                            CompleteQuest(questId);
                }
                else if (questStatus.Status == QUEST_STATUS_COMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) < l_Objective.Amount)
                        IncompleteQuest(questId);
                }
            }
        }
    }
}

void Player::QuestObjectiveSatisfy(uint32 objectId, uint32 amount, uint8 type, uint64 guid)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (!questId)
            continue;

        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
        if (!quest)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];
        if (questStatus.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        if (type)
        {
            if (!quest->GetQuestObjectiveCountType(type))
                continue;
        }

        for (QuestObjective l_Objective : quest->QuestObjectives)
        {
            if (l_Objective.Type == type && (uint32)l_Objective.ObjectID == objectId)
            {
                uint32 currentCounter   = GetQuestObjectiveCounter(l_Objective.ID);
                uint32 requiredCounter  = uint32(l_Objective.Amount);
                uint32 addCounter       = currentCounter + amount > requiredCounter ? requiredCounter : currentCounter +amount;

                m_questObjectiveStatus[l_Objective.ID] = addCounter;
                m_QuestStatusSave[questId] = true;

                SendQuestUpdateAddCredit(quest, l_Objective, guid, currentCounter, amount);

                if (CanCompleteQuest(questId))
                    CompleteQuest(questId);

                break;
            }
        }
    }
}

bool Player::HasQuestForItem(uint32 itemid) const
{
    if (!itemid)
        return false;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& q_status = qs_itr->second;

        if (q_status.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
            if (!qinfo)
                continue;

            // hide quest if player is in raid-group and quest is no raid quest
            if (GetGroup() && GetGroup()->isRaidGroup() && !qinfo->IsAllowedInRaid())
                if (!InBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                    continue;

            for (QuestObjective l_QuestObjective : qinfo->QuestObjectives)
            {
                if (itemid == (uint32)l_QuestObjective.ObjectID && GetQuestObjectiveCounter(l_QuestObjective.ID) < uint32(l_QuestObjective.Amount))
                    return true;
            }

            // This part - for ReqSource
            for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
            {
                // examined item is a source item
                if (qinfo->RequiredSourceItemId[j] == itemid)
                {
                    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemid);

                    // 'unique' item
                    if (pProto->MaxCount && int32(GetItemCount(itemid, true)) < pProto->MaxCount)
                        return true;

                    // allows custom amount drop when not 0
                    if (qinfo->RequiredSourceItemCount[j])
                    {
                        if (GetItemCount(itemid, true) < qinfo->RequiredSourceItemCount[j])
                            return true;
                    }
                    else if (GetItemCount(itemid, true) < pProto->GetMaxStackSize())
                        return true;
                }
            }
        }
    }
    return false;
}

bool Player::HasQuest(uint32 p_QuestID) const
{
    for (uint8 l_I = 0; l_I < MAX_QUEST_LOG_SIZE; ++l_I)
    {
        uint32 l_QuestID = GetQuestSlotQuestId(l_I);
        if (l_QuestID == 0)
            continue;

        if (l_QuestID == p_QuestID)
            return true;
    }

    return false;
}

void Player::SendQuestComplete(Quest const* quest)
{
    if (quest)
    {
        WorldPacket data(SMSG_QUEST_UPDATE_COMPLETE, 4);
        data << uint32(quest->GetQuestId());
        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestReward(Quest const* quest, uint32 XP, Object* questGiver)
{
    uint32 questId = quest->GetQuestId();
    sGameEventMgr->HandleQuestComplete(questId);

    uint32 xp;
    uint32 moneyReward;

    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        xp = XP;
        moneyReward = quest->GetRewMoney();
    }
    else // At max level, increase gold reward
    {
        xp = 0;
        moneyReward = uint32(quest->GetRewMoney() + int32(quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY)));
    }

    WorldPacket data(SMSG_QUEST_GIVER_QUEST_COMPLETE, 38);
    data << uint32(questId);
    data << uint32(xp);
    data << uint32(quest->GetRewardSkillId());             ///< Bonus skill id
    data << uint32(quest->GetBonusTalents());              ///< Bonus talents
    data << uint32(quest->GetRewardSkillPoints());         ///< Bonus skill points
    data << uint32(moneyReward);

    data << uint32(0);
    data << uint32(0);
    data << uint32(0);
    data.WriteBit(0);
    data.WriteBit(0);
    data.FlushBits();

    data.WriteBit(1);                                      ///< LaunchGossip
    data.WriteBit(1);                                      ///< UseQuestReward
    data.FlushBits();

    GetSession()->SendPacket(&data);

    if (quest->GetQuestCompleteScript() != 0)
        GetMap()->ScriptsStart(sQuestEndScripts, quest->GetQuestCompleteScript(), questGiver, this);
}

void Player::SendQuestFailed(uint32 questId, InventoryResult reason)
{
    if (questId)
    {
        WorldPacket data(SMSG_QUEST_GIVER_QUEST_FAILED, 4 + 4);
        data << uint32(questId);
        data << uint32(reason);                             // Failed reason (valid reasons: 4, 16, 50, 17, 74, other values show default message)
        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestTimerFailed(uint32 quest_id)
{
    if (quest_id)
    {
        WorldPacket data(SMSG_QUEST_UPDATE_FAILED_TIMER, 4);
        data << uint32(quest_id);
        GetSession()->SendPacket(&data);
    }
}

/// @TODO
/// according to c9e138d66d6a455a72d3fefbc0e4d5998bc338d6 from TrinityCore
/// the correct struct is
/// data << uint32(Reason);
/// data.WriteBit(SendErrorMessage);
/// data.WriteBits(ReasonText.length(), 9);
/// data.FlushBits();
/// data.WriteString(ReasonText);
void Player::SendCanTakeQuestResponse(uint32 msg) const
{
    WorldPacket data(SMSG_QUEST_GIVER_INVALID_QUEST, 4 + 2);
    data << uint32(msg);
    data.WriteBits(0, 9);       ///< Reason text
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendQuestConfirmAccept(const Quest* quest, Player* pReceiver)
{
    if (pReceiver)
    {
        std::string strTitle = quest->GetTitle();

        int loc_idx = pReceiver->GetSession()->GetSessionDbLocaleIndex();
        if (loc_idx >= 0)
            if (const QuestLocale* pLocale = sObjectMgr->GetQuestLocale(quest->GetQuestId()))
                ObjectMgr::GetLocaleString(pLocale->Title, loc_idx, strTitle);

        WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, 200);
        data << uint32(quest->GetQuestId());
        data.appendPackGUID(GetGUID());
        data.WriteBits(strTitle.size(), 10);
        data.FlushBits();
        data.WriteString(strTitle);
        pReceiver->GetSession()->SendPacket(&data);
    }
}

void Player::SendPushToPartyResponse(Player* player, uint32 msg)
{
    if (player)
    {
        WorldPacket data(SMSG_QUEST_PUSH_RESULT, 16 + 2 + 1);

        data.appendPackGUID(player->GetGUID());
        data << uint8(msg);

        GetSession()->SendPacket(&data);
    }
}

void Player::SendQuestUpdateAddCredit(Quest const* p_Quest, const QuestObjective & p_Objective, uint64 p_ObjGUID, uint16 p_OldCount, uint16 p_AddCount)
{
    ASSERT(p_OldCount + p_AddCount < 65536 && "mob/GO count store in 16 bits 2^16 = 65536 (0..65536)");

    uint16 log_slot = FindQuestSlot(p_Quest->GetQuestId());

    switch (p_Objective.Type)
    {
        case QUEST_OBJECTIVE_TYPE_CRITERIA_TREE:
        {
            WorldPacket data(SMSG_QUEST_UPDATE_ADD_CREDIT_SIMPLE, (4 * 4 + 8));
            data << uint32(p_Quest->GetQuestId());
            data << uint32(p_Objective.ObjectID);
            data << uint8(p_Objective.Type);

            GetSession()->SendPacket(&data);

            if (log_slot < MAX_QUEST_LOG_SIZE)
                SetQuestSlotState(log_slot, QUEST_STATE_OBJ_0_COMPLETE << p_Objective.Index);

            break;
        }

        case QUEST_OBJECTIVE_TYPE_NPC:
        case QUEST_OBJECTIVE_TYPE_ITEM:
        case QUEST_OBJECTIVE_TYPE_GO:
        case QUEST_OBJECTIVE_TYPE_NPC_INTERACT:
        case QUEST_OBJECTIVE_TYPE_CURRENCY:
        case QUEST_OBJECTIVE_TYPE_SPELL:
        case QUEST_OBJECTIVE_TYPE_FACTION_REP:
        case QUEST_OBJECTIVE_TYPE_FACTION_REP2:
        case QUEST_OBJECTIVE_TYPE_MONEY:
        case QUEST_OBJECTIVE_TYPE_PLAYER:
        case QUEST_OBJECTIVE_TYPE_AREATRIGGER:
        case QUEST_OBJECTIVE_TYPE_PET_BATTLE_TAMER:
        case QUEST_OBJECTIVE_TYPE_PET_BATTLE_ELITE:
        case QUEST_OBJECTIVE_TYPE_PET_BATTLE_PVP:
        case QUEST_OBJECTIVE_TYPE_PET_BATTLE_UNK2:
        default:
        {
            WorldPacket data(SMSG_QUEST_UPDATE_ADD_CREDIT, (4 * 4 + 8));
            data.appendPackGUID(p_ObjGUID);
            data << uint32(p_Quest->GetQuestId());
            data << uint32(p_Objective.ObjectID);
            data << uint16(p_OldCount + p_AddCount);
            data << uint16(p_Objective.Amount);
            data << uint8(p_Objective.Type);

            GetSession()->SendPacket(&data);

            if (log_slot < MAX_QUEST_LOG_SIZE)
                SetQuestSlotCounter(log_slot, p_Objective.Index, GetQuestSlotCounter(log_slot, p_Objective.Index) + p_AddCount);

            break;
        }
    }
}

void Player::SendQuestUpdateAddPlayer(Quest const* p_Quest, const QuestObjective & p_Objective, uint16 p_OldCount, uint16 p_AddCount)
{
    ASSERT(p_OldCount + p_AddCount < 65536 && "player count store in 16 bits");

    WorldPacket data(SMSG_QUEST_UPDATE_ADD_PVP_CREDIT, (2*4) + 1);
    data << uint32(p_Quest->GetQuestId());
    data << uint16(p_OldCount + p_AddCount);
    GetSession()->SendPacket(&data);

    uint16 log_slot = FindQuestSlot(p_Quest->GetQuestId());

    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlotCounter(log_slot, p_Objective.Index, GetQuestSlotCounter(log_slot, p_Objective.Index) + p_AddCount);
}

/*********************************************************/
/***                   LOAD SYSTEM                     ***/
/*********************************************************/
void Player::Initialize(uint32 guid)
{
    Object::_Create(guid, 0, HIGHGUID_PLAYER);
}

void Player::_LoadDeclinedNames(PreparedQueryResult result)
{
    if (!result)
        return;

    delete m_declinedname;
    m_declinedname = new DeclinedName;
    for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
        m_declinedname->name[i] = (*result)[i].GetString();
}

void Player::_LoadEquipmentSets(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
    if (!result)
        return;

    uint32 count = 0;
    do
    {
        Field* fields = result->Fetch();
        EquipmentSet eqSet;

        eqSet.Guid       = fields[0].GetUInt64();
        uint8 index      = fields[1].GetUInt8();
        eqSet.Name       = fields[2].GetString();
        eqSet.IconName   = fields[3].GetString();
        eqSet.IgnoreMask = fields[4].GetUInt32();
        eqSet.state      = EQUIPMENT_SET_UNCHANGED;

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
#ifndef CROSS
            eqSet.Items[i] = fields[5+i].GetUInt32();
#else /* CROSS */
        {
            uint32 originalItemGuidLow = fields[5 + i].GetUInt32();

            eqSet.OriginalItems[i] = originalItemGuidLow;
            eqSet.Items[i] = 0;

            // don't try to find item if originalGuid = 0
            if (originalItemGuidLow == 0)
                continue;

            // now find items at the cross-server
            for (uint8 j = 0; j < PLAYER_SLOTS_COUNT; ++j)
            {
                Item* item = m_items[j];
                if (!item)
                    continue;

                if (IsBagPos(item->GetPos()))
                {
                    if (Bag* pBag = item->ToBag())
                    {
                        for (uint8 k = 0; k < MAX_BAG_SIZE; ++k)
                        {
                            Item* itemInBag = pBag->GetItemByPos(k);
                            if (!itemInBag)
                                continue;

                            if (itemInBag->GetRealGUIDLow() == originalItemGuidLow)
                            {
                                eqSet.Items[i] = itemInBag->GetGUIDLow();
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (item->GetRealGUIDLow() == originalItemGuidLow)
                    {
                        eqSet.Items[i] = item->GetGUIDLow();
                        break;
                    }
                }
            }
        }
#endif /* CROSS */

        m_EquipmentSets[index] = eqSet;

        ++count;

        if (count >= MAX_EQUIPMENT_SET_INDEX)                // client limit
            break;
    }
    while (result->NextRow());
}

void Player::_LoadArenaData(PreparedQueryResult result)
{
    if (!result)
        return;

    Field* fields = result->Fetch();
    //        0        1                  2                    3                  4           5          6              7             8            9        10                 11                   12                 13          14         15             16            17           18       19                 20                   21                 22          23         24             25            26
    // SELECT rating0, bestRatingOfWeek0, bestRatingOfSeason0, matchMakerRating0, weekGames0, weekWins0, prevWeekWins0, seasonGames0, seasonWins0, rating1, bestRatingOfWeek1, bestRatingOfSeason1, matchMakerRating1, weekGames1, weekWins1, prevWeekWins1, seasonGames1, seasonWins1, rating2, bestRatingOfWeek2, bestRatingOfSeason2, matchMakerRating2, weekGames2, weekWins2, prevWeekWins2, seasonGames2, seasonWins2 FROM character_arena_data WHERE guid = ?

    uint8 j = 0;
    for (uint8 i = 0; i < MAX_PVP_SLOT; ++i)
    {
        m_ArenaPersonalRating[i] = fields[j++].GetUInt32();
        m_BestRatingOfWeek[i] = fields[j++].GetUInt32();
        m_BestRatingOfSeason[i] = fields[j++].GetUInt32();
        m_ArenaMatchMakerRating[i] = fields[j++].GetInt32();
        m_WeekGames[i] = fields[j++].GetUInt32();
        m_WeekWins[i] = fields[j++].GetUInt32();
        m_PrevWeekWins[i] = fields[j++].GetUInt32();
        m_PrevWeekGames[i] = fields[j++].GetUInt32();
        m_SeasonGames[i] = fields[j++].GetUInt32();
        m_SeasonWins[i] = fields[j++].GetUInt32();
    }
}

void Player::_LoadBGData(PreparedQueryResult result)
{
    if (!result)
        return;

    Field* fields = result->Fetch();
    // Expecting only one row
    //        0           1     2      3      4      5      6          7          8        9            10
    // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell, lastActiveSpec FROM character_battleground_data WHERE guid = ?

#ifndef CROSS
    m_bgData.bgInstanceID = fields[0].GetUInt32();
    m_bgData.bgTeam       = fields[1].GetUInt16();
#else /* CROSS */
    m_bgData.m_ReconnectBgTeam = fields[1].GetUInt16();
#endif /* CROSS */
    m_bgData.joinPos      = WorldLocation(fields[6].GetUInt16(),    // Map
                                          fields[2].GetFloat(),     // X
                                          fields[3].GetFloat(),     // Y
                                          fields[4].GetFloat(),     // Z
                                          fields[5].GetFloat());    // Orientation
    m_bgData.taxiPath[0]  = fields[7].GetUInt32();
    m_bgData.taxiPath[1]  = fields[8].GetUInt32();
    m_bgData.mountSpell   = fields[9].GetUInt32();
    m_bgData.m_LastActiveSpec = fields[10].GetUInt16();
#ifndef CROSS
    m_bgData.bgTypeID = (BattlegroundTypeId)fields[11].GetUInt32();
#endif
}

bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return false;

    Field* fields = result->Fetch();

    x = fields[0].GetFloat();
    y = fields[1].GetFloat();
    z = fields[2].GetFloat();
    o = fields[3].GetFloat();
    mapid = fields[4].GetUInt16();
    in_flight = !fields[5].GetString().empty();
#endif
    return true;
}

void Player::SetHomebind(WorldLocation const& loc, uint32 area_id)
{
    m_homebindMapId  = loc.GetMapId();
    m_homebindAreaId = area_id;
    m_homebindX      = loc.GetPositionX();
    m_homebindY      = loc.GetPositionY();
    m_homebindZ      = loc.GetPositionZ();

    // update sql homebind
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_HOMEBIND);
    stmt->setUInt16(0, m_homebindMapId);
    stmt->setUInt16(1, m_homebindAreaId);
    stmt->setFloat (2, m_homebindX);
    stmt->setFloat (3, m_homebindY);
    stmt->setFloat (4, m_homebindZ);
    stmt->setUInt32(5, GetRealGUIDLow());
    RealmDatabase.Execute(stmt);
}

uint32 Player::GetUInt32ValueFromArray(Tokenizer const& data, uint16 index)
{
    if (index >= data.size())
        return 0;

    return (uint32)atoi(data[index]);
}

uint64 Player::GetUInt64ValueFromArray(Tokenizer const& p_Datas, uint16 p_Index)
{
    if (p_Index >= p_Datas.size())
        return 0;

    return (uint64)strtoull(p_Datas[p_Index], nullptr, 10);
}

float Player::GetFloatValueFromArray(Tokenizer const& data, uint16 index)
{
    float result;
    uint32 temp = Player::GetUInt32ValueFromArray(data, index);
    memcpy(&result, &temp, sizeof(result));

    return result;
}

bool Player::LoadFromDB(uint32 guid, SQLQueryHolder* holder, SQLQueryHolder* p_LoginDBQueryHolder)
{
    /// 0             1               2               3                  4                         5                         6                7                  8                    9
    /// guid,         account,        name,           race,              class,                    gender,                   level,           xp,                money,               playerBytes,
    /// 10            11              12              13                 14                        15                        16               17                 18                   19
    /// playerBytes2, playerFlags,    position_x,     position_y,        position_z,               map,                      orientation,     taximask,          cinematic,           totaltime,
    /// 20            21              22              23                 24                        25                        26               27                 28                   29
    /// leveltime,    rest_bonus,     logout_time,    is_logout_resting, resettalents_cost,        resettalents_time,        talentTree,      trans_x,           trans_y,             trans_z,
    /// 30            31              32              33                 34                        35                        36               37                 38                   39
    /// trans_o,      transguid,      extra_flags,    stable_slots,      at_login,                 zone,                     online,          death_expire_time, taxi_path,           DungeonDifficulty,
    /// 40            41              42              43                 44                        45                        46               47                 48                   49
    /// totalKills,   todayKills,     yesterdayKills, chosenTitle,       watchedFaction,           drunk,                    health,          power1,            power2,              power3,
    /// 50            51              52      53              54                 55                        56                        57               58                 59                   60
    /// power4,       power5,         power6, instance_id,    speccount,         activespec,               specialization1,          specialization2, exploredZones,     equipmentCache,      knownTitles,
    /// 61            62              63              64                 65                        66                        67               68                 69                   70             71
    /// actionBars,   currentpetslot, petslotused,    grantableLevels,   resetspecialization_cost, resetspecialization_time, playerFlagsEx,   RaidDifficulty,    LegacyRaidDifficuly, lastbattlepet, xprate

    uint32 l_StartTime = getMSTime();
    std::vector<uint32> l_Times;

    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADFROM);
    if (!result)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) not found in table `characters`, can't load. ", guid);
        return false;
    }

    Field* fields = result->Fetch();

    m_atLoginFlags = fields[34].GetUInt16();

    m_EndSalesTimestamp = fields[72].GetUInt32();
    if (m_EndSalesTimestamp > time(nullptr))
        return false;

    if (m_atLoginFlags & AT_LOGIN_LOCKED_FOR_TRANSFER)
        return false;

    uint32 dbAccountId = fields[1].GetUInt32();

    // check if the character's account in the db and the logged in account match.
    // player should be able to load/delete character only with correct account!
    if (dbAccountId != GetSession()->GetAccountId())
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) loading from wrong account (is: %u, should be: %u)", guid, GetSession()->GetAccountId(), dbAccountId);
        return false;
    }

    if (holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBANNED))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) is banned, can't load.", guid);
        return false;
    }

    Object::_Create(guid, 0, HIGHGUID_PLAYER);

    if (m_atLoginFlags & AT_LOGIN_CHANGE_ITEM_FACTION)
    {
        uint8 l_CurrentRace = fields[3].GetUInt8();

        BattlegroundTeamId l_Team = BG_TEAM_ALLIANCE;
        switch (l_CurrentRace)
        {
            case RACE_ORC:
            case RACE_GOBLIN:
            case RACE_TAUREN:
            case RACE_UNDEAD_PLAYER:
            case RACE_TROLL:
            case RACE_BLOODELF:
            case RACE_PANDAREN_HORDE:
                l_Team = BG_TEAM_HORDE;
                break;
            default:
                break;
        }

        /// Item conversion
        SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
        for (std::map<uint32, uint32>::const_iterator l_Iterator = sObjectMgr->FactionChange_Items.begin(); l_Iterator != sObjectMgr->FactionChange_Items.end(); ++l_Iterator)
        {
            uint32 l_ItemAlliance = l_Iterator->first;
            uint32 l_ItemHorde = l_Iterator->second;

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE);
            l_Statement->setUInt32(0, (l_Team == BG_TEAM_ALLIANCE ? l_ItemAlliance : l_ItemHorde));
            l_Statement->setUInt32(1, (l_Team == BG_TEAM_ALLIANCE ? l_ItemHorde : l_ItemAlliance));
            l_Statement->setUInt32(2, guid);
            l_Transaction->Append(l_Statement);
        }

        CharacterDatabase.DirectCommitTransaction(l_Transaction);

        RemoveAtLoginFlag(AT_LOGIN_CHANGE_ITEM_FACTION, true);
        return false;
    }

    m_name = fields[2].GetString();

#ifndef CROSS
    // check name limitations
    if (ObjectMgr::CheckPlayerName(m_name) != CHAR_NAME_SUCCESS ||
        (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && sObjectMgr->IsReservedName(m_name)))
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);

        stmt->setUInt16(0, uint16(AT_LOGIN_RENAME));
        stmt->setUInt32(1, guid);

        CharacterDatabase.Execute(stmt);

        return false;
    }

#endif /* not CROSS */
    l_Times.push_back(getMSTime() - l_StartTime);

    // overwrite possible wrong/corrupted guid
    SetGuidValue(OBJECT_FIELD_GUID, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

    uint8 Gender = fields[5].GetUInt8();
    if (!IsValidGender(Gender))
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (GUID: %u) has wrong gender (%hhu), can't be loaded.", guid, Gender);
        return false;
    }

    // overwrite some data fields
    uint32 bytes0 = 0;
    bytes0 |= fields[3].GetUInt8();                         // race
    bytes0 |= fields[4].GetUInt8() << 8;                    // class
    bytes0 |= Gender << 24;                                 // gender
    SetUInt32Value(UNIT_FIELD_SEX, bytes0);

    SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
    SetUInt32Value(PLAYER_FIELD_XP, fields[7].GetUInt32());

    _LoadIntoDataField(fields[58].GetCString(), PLAYER_FIELD_EXPLORED_ZONES, PLAYER_EXPLORED_ZONES_SIZE, false);
    _LoadIntoDataField(fields[60].GetCString(), PLAYER_FIELD_KNOWN_TITLES, KNOWN_TITLES_SIZE, true);

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, DEFAULT_WORLD_OBJECT_SIZE);
    SetFloatValue(UNIT_FIELD_COMBAT_REACH, 1.5f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);

    // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
    m_achievementMgr.LoadFromDB(this, NULL, holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACHIEVEMENTS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCRITERIAPROGRESS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACCOUNTACHIEVEMENTS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACCOUNTCRITERIAPROGRESS));

    uint64 money = fields[8].GetUInt64();
    if (money > MAX_MONEY_AMOUNT)
        money = MAX_MONEY_AMOUNT;
    SetMoney(money);

    l_Times.push_back(getMSTime() - l_StartTime);

    SetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID, fields[9].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_REST_STATE, fields[10].GetUInt32());
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_3_OFFSET_GENDER, fields[5].GetUInt8());
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, PLAYER_BYTES_3_OFFSET_INEBRIATION, fields[45].GetUInt8());
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS, fields[11].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX, fields[67].GetUInt32());
    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fields[44].GetUInt32());

    SetGuidValue(PLAYER_FIELD_WOW_ACCOUNT, GetSession()->GetWoWAccountGUID());

    // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
    SetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES, fields[61].GetUInt8());

    m_currentPetSlot = (PetSlot)fields[62].GetUInt8();

    InitDisplayIds();

    // cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), 0);
        SetVisibleItemSlot(slot, NULL);

        delete m_items[slot];
        m_items[slot] = NULL;
    }

    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Load Basic value of player %s is: ", m_name.c_str());
    outDebugValues();

    //Need to call it to initialize m_team (m_team can be calculated from race)
    //Other way is to saves m_team into characters table.
    setFactionForRace(getRace());

    // load home bind and check in same time class/race pair, it used later for restore broken positions
    if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADHOMEBIND)))
        return false;

    InitPrimaryProfessions();                               // to max set before any spell loaded

    l_Times.push_back(getMSTime() - l_StartTime);

    // init saved position, and fix it later if problematic
    uint32 transGUID = uint32(fields[31].GetUInt32());

    Relocate(fields[12].GetFloat(), fields[13].GetFloat(), fields[14].GetFloat(), fields[16].GetFloat());

    uint32 mapId = fields[15].GetUInt16();
    uint32 instanceId = fields[53].GetUInt32();

    SetDungeonDifficultyID(CheckLoadedDungeonDifficultyID(Difficulty(fields[39].GetUInt8())));
    SetRaidDifficultyID(CheckLoadedRaidDifficultyID(Difficulty(fields[68].GetUInt8())));
    SetLegacyRaidDifficultyID(CheckLoadedLegacyRaidDifficultyID(Difficulty(fields[69].GetUInt8())));

    std::string taxi_nodes = fields[38].GetString();
    l_Times.push_back(getMSTime() - l_StartTime);

#define RelocateToHomebind(){ mapId = m_homebindMapId; instanceId = 0; Relocate(m_homebindX, m_homebindY, m_homebindZ); }

    _LoadHeirloomCollection(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_HEIRLOOM_COLLECTION));
    _LoadToyBox(p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINDB_TOYS));
    _LoadBossLooted(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_BOSS_LOOTED));
    _LoadWorldStates(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_WORLD_STATES));

#ifndef CROSS
    _LoadGroup(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADGROUP));
#endif

    _LoadArenaData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADARENADATA));
    _LoadCurrency(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCURRENCY));
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[40].GetUInt32());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0, fields[41].GetUInt16());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, fields[42].GetUInt16());

#ifndef CROSS
    _LoadBoundInstances(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBOUNDINSTANCES));
#endif /* not CROSS */
    _LoadInstanceTimeRestrictions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADINSTANCELOCKTIMES));
    _LoadBGData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBGDATA));
    _LoadCUFProfiles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CUF_PROFILES));
    l_Times.push_back(getMSTime() - l_StartTime);

    GetSession()->SetPlayer(this);
#ifndef CROSS
    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);

    bool mustResurrectFromUnlock = false;

    if (m_atLoginFlags & AT_LOGIN_UNLOCK)
    {
        bool BGdesert = false;
        bool DungeonDesert = false;
        bool MalDeRez = false;

        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        if (HasAura(26013)) // deserteur
            BGdesert = true;
        if (HasAura(71041)) // deserteur de donjon
            DungeonDesert = true;
        if (HasAura(15007))
            MalDeRez = true;

        RemoveAllAuras();
        RemoveFromGroup();
        CleanupAfterTaxiFlight();

        if (BGdesert)
            AddAura(26013, this);
        if (DungeonDesert)
            AddAura(71041, this);
        /*if (MalDeRez)
            AddAura(15007, this);*/

        mustResurrectFromUnlock = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST);
        RelocateToHomebind();
    }
    else if (!mapEntry || !IsPositionValid())
    {
        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (MapId: %u X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        RelocateToHomebind();
    }
    // currently we do not support transport in bg
    else if (transGUID)
    {
        m_movementInfo.t_guid = MAKE_NEW_GUID(transGUID, 0, HIGHGUID_MO_TRANSPORT);
        m_movementInfo.t_pos.Relocate(fields[27].GetFloat(), fields[28].GetFloat(), fields[29].GetFloat(), fields[30].GetFloat());

        if (!JadeCore::IsValidMapCoord(
            GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
            GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation()) ||
            // transport size limited
            m_movementInfo.t_pos.m_positionX > 250 || m_movementInfo.t_pos.m_positionY > 250 || m_movementInfo.t_pos.m_positionZ > 250)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid transport coordinates (X: %f Y: %f Z: %f O: %f). Teleport to bind location.",
                guid, GetPositionX()+m_movementInfo.t_pos.m_positionX, GetPositionY()+m_movementInfo.t_pos.m_positionY,
                GetPositionZ()+m_movementInfo.t_pos.m_positionZ, GetOrientation()+m_movementInfo.t_pos.GetOrientation());

            RelocateToHomebind();
        }
        else
        {
            if (GameObject* go = HashMapHolder<GameObject>::Find(m_movementInfo.t_guid))
                m_transport = go->ToTransport();

            if (m_transport)
            {
                m_transport->AddPassenger(this);
                mapId = m_transport->GetMapId();
            }
            else
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have problems with transport guid (%u). Teleport to bind location.",
                    guid, transGUID);

                RelocateToHomebind();
            }
        }
    }
    // currently we do not support taxi in instance
    else if (!taxi_nodes.empty())
    {
        instanceId = 0;

        // Not finish taxi flight path
        if (m_bgData.HasTaxiPath())
        {
            for (int i = 0; i < 2; ++i)
                m_taxi.AddTaxiDestination(m_bgData.taxiPath[i]);
        }
        else if (!m_taxi.LoadTaxiDestinationsFromString(taxi_nodes, GetTeam()))
        {
            // problems with taxi path loading
            TaxiNodesEntry const* nodeEntry = NULL;
            if (uint32 node_id = m_taxi.GetTaxiSource())
                nodeEntry = sTaxiNodesStore.LookupEntry(node_id);

            if (!nodeEntry)                                      // don't know taxi start node, to homebind
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u have wrong data in taxi destination list, teleport to homebind.", GetGUIDLow());
                RelocateToHomebind();
            }
            else                                                // have start node, to it
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u have too short taxi destination list, teleport to original node.", GetGUIDLow());
                mapId = nodeEntry->MapID;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }
            m_taxi.ClearTaxiDestinations();
        }

        if (uint32 node_id = m_taxi.GetTaxiSource())
        {
            // save source node as recall coord to prevent recall and fall from sky
            TaxiNodesEntry const* nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
            if (nodeEntry && nodeEntry->MapID == GetMapId())
            {
                ASSERT(nodeEntry);                                  // checked in m_taxi.LoadTaxiDestinationsFromString
                mapId = nodeEntry->MapID;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }

            // flight will started later
        }
    }

    // Map could be changed before
    mapEntry = sMapStore.LookupEntry(mapId);
    // client without expansion support
    if (mapEntry)
    {
        if (GetSession()->Expansion() < mapEntry->Expansion())
        {
            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player %s using client without required expansion tried login at non accessible map %u", GetName(), mapId);
            RelocateToHomebind();
        }

        // fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
        if (instanceId)
            if (InstanceSave* save = GetInstanceSave(mapId))
                if (save->GetInstanceId() != instanceId)
                    instanceId = 0;
    }

    l_Times.push_back(getMSTime() - l_StartTime);

    /// Player was saved in BG or arena.
    if (mapEntry && mapEntry->IsBattlegroundOrArena())
    {
        InterRealmSession* l_Tunnel = sWorld->GetInterRealmSession();

        /// Cross realm battleground
        if (l_Tunnel && l_Tunnel->IsTunnelOpened() && m_bgData.bgInstanceID != 0)
        {
            /// Send reconnect notification to cross realm
            l_Tunnel->SendPlayerReconnect(GetGUID(), m_bgData.bgInstanceID, m_bgData.bgTypeID);

            /// Teleport the player to join position
            /// Cross will tell us later if the player need to go in battleground/arena
            {
                const WorldLocation& _loc = GetBattlegroundEntryPoint();
                mapId = _loc.GetMapId();
                instanceId = 0;

                /// Db field type is type int16, so it can never be MAPID_INVALID.
                /// if (mapId == MAPID_INVALID) -- code kept for reference
                if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
                {
                    sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid);
                    RelocateToHomebind();
                }
                else
                    Relocate(&_loc);
            }
        }
        else
        {
            Battleground* currentBg = NULL;
            if (m_bgData.bgInstanceID)                                                //saved in Battleground
                currentBg = sBattlegroundMgr->GetBattleground(m_bgData.bgInstanceID, MS::Battlegrounds::Maps::FindAssociatedType(mapEntry->MapID));

            bool player_at_bg = currentBg && currentBg->IsPlayerInBattleground(GetGUID());

            if (player_at_bg && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
            {
                MS::Battlegrounds::BattlegroundType::Type bgQueueTypeId = MS::Battlegrounds::GetTypeFromId(currentBg->GetTypeID(), currentBg->GetArenaType(), currentBg->IsSkirmish());
                AddBattlegroundQueueId(bgQueueTypeId);

                m_bgData.bgTypeID = currentBg->GetTypeID();

                //join player to battleground group
                currentBg->EventPlayerLoggedIn(this);
                currentBg->AddOrSetPlayerToCorrectBgGroup(this, m_bgData.bgTeam);

                SetInviteForBattlegroundQueueType(bgQueueTypeId, currentBg->GetInstanceID());

                /// We give the deserter aura by default when we leave a battleground
                /// so if we succeed at re-entering the battleground, we remove the aura.
                if (HasAura(MS::Battlegrounds::Spells::DeserterBuff))
                    RemoveAura(MS::Battlegrounds::Spells::DeserterBuff);
            }
            // Bg was not found - go to Entry Point
            else
            {
                /// Leave bg.
                if (player_at_bg)
                    currentBg->RemovePlayerAtLeave(GetGUID(), false, true);

                /// Do not look for instance if bg not found.
                const WorldLocation& _loc = GetBattlegroundEntryPoint();
                mapId = _loc.GetMapId(); instanceId = 0;

                /// Db field type is type int16, so it can never be MAPID_INVALID.
                /// if (mapId == MAPID_INVALID) -- code kept for reference
                if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
                {
                    sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid);
                    RelocateToHomebind();
                }
                else
                    Relocate(&_loc);

                /// We are not in BG anymore.
                m_bgData.bgInstanceID = 0;
            }
        }
    }
    else if (m_bgData.bgInstanceID != 0)
    {
        /// Map isn't battleground or arena, clean battleground id / type
        SetBattlegroundId(0, BattlegroundTypeId::BATTLEGROUND_TYPE_NONE);
    }

    // NOW player must have valid map
    // load the player's map here if it's not already loaded
    Map* map = sMapMgr->CreateMap(mapId, this);

    if (!map)
    {
        instanceId = 0;
        AreaTriggerStruct const* at = sObjectMgr->GetGoBackTrigger(mapId);
        if (at)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
            mapId = at->target_mapId;
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            RelocateToHomebind();
        }

        map = sMapMgr->CreateMap(mapId, this);
        if (!map)
        {
            PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
            mapId = info->mapId;
            Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
            sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            map = sMapMgr->CreateMap(mapId, this);
            if (!map)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player (guidlow %d) has invalid default map coordinates (X: %f Y: %f Z: %f O: %f). or instance couldn't be created", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                return false;
            }
        }
    }

    l_Times.push_back(getMSTime() - l_StartTime);

    // if the player is in an instance and it has been reset in the meantime teleport him to the entrance
    if (instanceId && !sInstanceSaveMgr->GetInstanceSave(instanceId) && !map->IsBattlegroundOrArena())
    {
        AreaTriggerStruct const* at = sObjectMgr->GetMapEntranceTrigger(mapId);
        if (at)
            Relocate(at->target_X, at->target_Y, at->target_Z, at->target_Orientation);
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s(GUID: %u) logged in to a reset instance (map: %u) and there is no area-trigger leading to this map. Thus he can't be ported back to the entrance. This _might_ be an exploit attempt.", GetName(), GetGUIDLow(), mapId);
            RelocateToHomebind();
        }
    }

    SetMap(map);
#endif /* not CROSS */

    // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
    // this must help in case next save after mass player load after server startup
    m_nextSave = urand(m_nextSave/2, m_nextSave*3/2);

    SaveRecallPosition();

    time_t now = time(NULL);
    time_t logoutTime = time_t(fields[22].GetUInt32());

    // since last logout (in seconds)
    uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.

    // set value, including drunk invisibility detection
    // calculate sobering. after 15 minutes logged out, the player will be sober again
    uint8 newDrunkValue = 0;
    if (time_diff < uint32(GetDrunkValue()) * 9)
        newDrunkValue = GetDrunkValue() - time_diff / 9;

    SetDrunkValue(newDrunkValue);

    m_cinematic = fields[18].GetUInt8();
    m_Played_time[PLAYED_TIME_TOTAL]= fields[19].GetUInt32();
    m_Played_time[PLAYED_TIME_LEVEL]= fields[20].GetUInt32();

    SetTalentResetCost(fields[24].GetUInt32());
    SetTalentResetTime(time_t(fields[25].GetUInt32()));

    SetSpecializationResetCost(fields[65].GetUInt32());
    SetSpecializationResetTime(time_t(fields[66].GetUInt32()));

    m_taxi.LoadTaxiMask(fields[17].GetCString());            // must be before InitTaxiNodesForLevel

    uint32 extraflags = fields[32].GetUInt16();

    l_Times.push_back(getMSTime() - l_StartTime);

    m_stableSlots = fields[33].GetUInt8();
    if (m_stableSlots > MAX_PET_STABLES)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player can have not more %u stable slots, but have in DB %u", MAX_PET_STABLES, uint32(m_stableSlots));
        m_stableSlots = MAX_PET_STABLES;
    }

    // Honor system
    // Update Honor kills data
    m_lastHonorUpdateTime = logoutTime;
    UpdateHonorFields();

    m_deathExpireTime = time_t(fields[37].GetUInt32());
    if (m_deathExpireTime > now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP)
        m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP-1;

    m_LastSummonedBattlePet = fields[70].GetUInt32();
    m_PersonnalXpRate = fields[71].GetFloat();

    // clear channel spell data (if saved at channel spell casting)
    SetGuidValue(UNIT_FIELD_CHANNEL_OBJECT, 0);
    SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL, 0);
    SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL_XSPELL_VISUAL, 0);

    // clear charm/summon related fields
    SetOwnerGUID(0);
    SetGuidValue(UNIT_FIELD_CHARMED_BY, 0);
    SetGuidValue(UNIT_FIELD_CHARM, 0);
    SetGuidValue(UNIT_FIELD_SUMMON, 0);
    SetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, 0);
    SetCreatorGUID(0);

    RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FORCE_MOVEMENT);

    // reset some aura modifiers before aura apply
    SetUInt32Value(PLAYER_FIELD_TRACK_CREATURE_MASK, 0);
    SetUInt32Value(PLAYER_FIELD_TRACK_RESOURCE_MASK, 0);

    // make sure the unit is considered out of combat for proper loading
    ClearInCombat();

    // make sure the unit is considered not in duel for proper loading
    SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, 0);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    l_Times.push_back(getMSTime() - l_StartTime);

    // reset stats before loading any modifiers
    InitStatsForLevel();
    InitGlyphsForLevel();
    InitTaxiNodesForLevel();
    InitRunes();

    l_Times.push_back(getMSTime() - l_StartTime);

    // rest bonus can only be calculated after InitStatsForLevel()
    m_rest_bonus = fields[21].GetFloat();

    if (time_diff > 0)
    {
        //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
        float bubble0 = 0.031f;
        //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
        float bubble1 = 0.125f;
        float bubble = fields[23].GetUInt8() > 0
            ? bubble1*sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY)
            : bubble0*sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);

        SetRestBonus(GetRestBonus()+ time_diff*((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)/72000)*bubble);
    }

    // load skills after InitStatsForLevel because it triggering aura apply also
    _LoadSkills(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSKILLS));
    m_archaeologyMgr.LoadArchaeology(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY),
                                     holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY_PROJECTS),
                                     holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY_SITES));

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()

#ifndef CROSS
    //mails are loaded only when needed ;-) - when player in game click on mailbox.
    _LoadMail(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAIL));
    _LoadMailedItems(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAIL_ITEMS));
#endif

    SetSpecsCount(fields[54].GetUInt8());
    SetActiveSpec(fields[55].GetUInt8());

    SetSpecializationId(0, fields[56].GetUInt32(), true);
    SetSpecializationId(1, fields[57].GetUInt32(), true);

    SetFreeTalentPoints(CalculateTalentsPoints());

    l_Times.push_back(getMSTime() - l_StartTime);

    // sanity check
    if (GetSpecsCount() > MAX_TALENT_SPECS || GetActiveSpec() > MAX_TALENT_SPEC || GetSpecsCount() < MIN_TALENT_SPECS)
    {
        SetActiveSpec(0);
        sLog->outError(LOG_FILTER_PLAYER, "Player %s(GUID: %u) has SpecCount = %u and ActiveSpec = %u.", GetName(), GetGUIDLow(), GetSpecsCount(), GetActiveSpec());
    }

    _LoadGlyphs(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADGLYPHS));
    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadGlyphAuras();
    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADTALENTS));
    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadSpells(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_CHAR_LOADSPELLS));

    l_Times.push_back(getMSTime() - l_StartTime);

#ifndef CROSS
    uint32 l_AllowedGroupRealmMask = sWorld->getIntConfig(CONFIG_ACCOUNT_BIND_ALLOWED_GROUP_MASK);
#else /* CROSS */
    uint32 l_AllowedGroupRealmMask = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber())->allowedGroupRealmMask;
#endif /* CROSS */

    // Load of account spell, we must load it like that because it's stored in realmd database
    // With actual implementation, we can use QueryHolder only with single database
    if (PreparedQueryResult accountResult = p_LoginDBQueryHolder->GetPreparedResult(PLAYER_LOGINGB_SPELL))
    {
        do
        {
            uint32 l_GroupRealmMask = (*accountResult)[4].GetUInt32();
            if ((l_GroupRealmMask & l_AllowedGroupRealmMask) == 0)
                continue;

            uint32 l_SpellID = (*accountResult)[0].GetUInt32();
            for (uint32 l_I = 0; l_I < sBattlePetSpeciesStore.GetNumRows(); l_I++)
            {
                BattlePetSpeciesEntry const* speciesInfo = sBattlePetSpeciesStore.LookupEntry(l_I);

                if (speciesInfo && speciesInfo->spellId == l_SpellID)
                {
                    m_OldPetBattleSpellToMerge.push_back(std::make_pair(l_SpellID, speciesInfo->id));
                    break;
                }
            }

            addSpell((*accountResult)[0].GetUInt32(), (*accountResult)[1].GetBool(), false, false, (*accountResult)[2].GetBool(), true, (*accountResult)[3].GetBool());
        }
        while (accountResult->NextRow());
    }

    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadAuras(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS_EFFECTS), time_diff);

    l_Times.push_back(getMSTime() - l_StartTime);

    // add ghost flag (must be after aura load: PLAYER_FIELD_PLAYER_FLAGS_GHOST set in aura)
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
        m_deathState = DEAD;

    l_Times.push_back(getMSTime() - l_StartTime);

    // after spell load, learn rewarded spell if need also
    _LoadQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUS));
    _LoadQuestObjectiveStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_OBJECTIVE_STATUS));
    _LoadQuestStatusRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUSREW));
    _LoadDailyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDAILYQUESTSTATUS));
    _LoadWeeklyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADWEEKLYQUESTSTATUS));
    _LoadSeasonalQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSEASONALQUESTSTATUS));
    _LoadMonthlyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MONTHLY_QUEST_STATUS));
    _LoadRandomBGStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADRANDOMBG));

    l_Times.push_back(getMSTime() - l_StartTime);

    // after spell and quest load
    InitTalentForLevel();
    l_Times.push_back(getMSTime() - l_StartTime);

    InitSpellForLevel();
    l_Times.push_back(getMSTime() - l_StartTime);

    learnDefaultSpells();
    l_Times.push_back(getMSTime() - l_StartTime);

    // must be before inventory (some items required reputation check)
    m_reputationMgr.LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADREPUTATION));

    l_Times.push_back(getMSTime() - l_StartTime);


    _LoadInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADINVENTORY), time_diff);

    l_Times.push_back(getMSTime() - l_StartTime);


    if (IsVoidStorageUnlocked())
        _LoadVoidStorage(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADVOIDSTORAGE));

    m_VoidStorageLoaded = true;

    l_Times.push_back(getMSTime() - l_StartTime);

    // update items with duration and realtime
    UpdateItemDuration(time_diff, true);

    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadActions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACTIONS));

#ifndef CROSS
    // unread mails and next delivery time, actual mails not loaded
    _LoadMailInit(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILCOUNT), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILDATE));

    m_social = sSocialMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSOCIALLIST), GetGUIDLow(), GetSession()->GetAccountId());
#else /* CROSS */
    m_social = nullptr;
#endif /* CROSS */

    // check PLAYER_CHOSEN_TITLE compatibility with PLAYER_FIELD_KNOWN_TITLES
    // note: PLAYER_FIELD_KNOWN_TITLES updated at quest status loaded
    uint32 curTitle = fields[43].GetUInt32();
    if (curTitle && !HasTitle(curTitle))
        curTitle = 0;

    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, curTitle);

    // has to be called after last Relocate() in Player::LoadFromDB
    SetFallInformation(0, GetPositionZ());

    l_Times.push_back(getMSTime() - l_StartTime);

    _LoadSpellCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSPELLCOOLDOWNS));
    _LoadChargesCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CHARGES_COOLDOWNS));
    _LoadCompletedChallenges(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_COMPLETED_CHALLENGES));
    _LoadDailyLootsCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_DAILY_LOOT_COOLDOWNS));

    l_Times.push_back(getMSTime() - l_StartTime);

    // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
    // Do now before stats re-calculation cleanup for ghost state unexpected auras
    if (!isAlive())
        RemoveAllAurasOnDeath();
    else
        RemoveAllAurasRequiringDeadTarget();

    // Command Demon
    RemoveAura(119904);

#ifdef CROSS
    /// Remove garrisons ability on cross
    RemoveAura(161693); ///< GARRISON_SPELL_GARR_ABILITY_HORDE_BASE
    RemoveAura(161694); ///< GARRISON_SPELL_GARR_ABILITY_ALLIANCE_BASE

#endif /* CROSS */
    //apply all stat bonuses from items and auras
    SetCanModifyStats(true);
    UpdateAllStats();

    // restore remembered power/health values (but not more max values)
    uint32 savedHealth = fields[46].GetUInt32();
    SetHealth(savedHealth > GetMaxHealth() ? GetMaxHealth() : savedHealth);
    uint32 loadedPowers = 0;
    for (uint32 i = 0; i < MAX_POWERS; ++i)
    {
        if (GetPowerIndex(Powers(i), getClass()) != MAX_POWERS)
        {
            uint32 savedPower = fields[47+loadedPowers].GetUInt32();
            uint32 maxPower = GetUInt32Value(UNIT_FIELD_MAX_POWER + loadedPowers);
            SetPower(Powers(i), (savedPower > maxPower) ? maxPower : savedPower);
            if (++loadedPowers >= MAX_POWERS_PER_CLASS)
                break;
        }
    }

    for (; loadedPowers < MAX_POWERS_PER_CLASS; ++loadedPowers)
        SetUInt32Value(UNIT_FIELD_POWER + loadedPowers, 0);

    SetPower(POWER_ECLIPSE, 0);

    l_Times.push_back(getMSTime() - l_StartTime);

    // must be after loading spells and talents
    Tokenizer talentTrees(fields[26].GetString(), ' ', MAX_TALENT_SPECS);
    /*for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
    {
        if (i >= talentTrees.size())
            break;

        uint32 talentTree = atol(talentTrees[i]);
        if (sTalentTabStore.LookupEntry(talentTree))
            SetPrimaryTalentTree(i, talentTree);
        else if (i == GetActiveSpec())
            SetAtLoginFlag(AT_LOGIN_RESET_TALENTS); // invalid tree, reset talents
    }*/

    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "The value of player %s after load item and aura is: ", m_name.c_str());
    outDebugValues();

    // GM state
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
    {
        switch (sWorld->getIntConfig(CONFIG_GM_LOGIN_STATE))
        {
            default:
            case 0:                      break;             // disable
            case 1: SetGameMaster(true); break;             // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_ON)
                    SetGameMaster(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_VISIBLE_STATE))
        {
            default:
            case 0: SetGMVisible(false); break;             // invisible
            case 1:                      break;             // visible
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_INVISIBLE)
                    SetGMVisible(false);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_CHAT))
        {
            default:
            case 0:                  break;                 // disable
            case 1: SetGMChat(true); break;                 // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_CHAT)
                    SetGMChat(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_WHISPERING_TO))
        {
            default:
            case 0:                          break;         // disable
            case 1: SetAcceptWhispers(true); break;         // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_ACCEPT_WHISPERS)
                    SetAcceptWhispers(true);
                break;
        }
    }

    l_Times.push_back(getMSTime() - l_StartTime);

    // RaF stuff.
    m_grantableLevels = fields[64].GetUInt8();

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    /// Commented due to action bar fix, need more research
    ///if (m_grantableLevels > 0)
    ///    SetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 1, 0x01);

    _LoadDeclinedNames(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDECLINEDNAMES));

    m_achievementMgr.CheckAllAchievementCriteria(this);

    _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));

#ifndef CROSS
    if (mustResurrectFromUnlock)
        ResurrectPlayer(1, true);

    if (GmTicket* ticket = sTicketMgr->GetTicketByPlayer(GetGUID()))
        if (!ticket->IsClosed() && ticket->IsCompleted())
            ticket->SendResponse(GetSession());
#endif

    l_Times.push_back(getMSTime() - l_StartTime);

    // Set realmID
#ifndef CROSS
    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, g_RealmID);
#else /* CROSS */
    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, GetSession()->GetInterRealmNumber());
#endif /* CROSS */
    ReloadPetBattles();

#ifndef CROSS
    MS::Garrison::Manager* l_Garrison = new MS::Garrison::Manager(this);

    if (l_Garrison->Load(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_BUILDINGS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_FOLLOWERS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_MISSIONS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_WORKORDERS)))
        m_Garrison = l_Garrison;
    else
        delete l_Garrison;

    _LoadGarrisonDailyTavernDatas(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_MISSIONS_TAVERNDATA));
    _LoadCharacterGarrisonWeeklyTavernDatas(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_GARRISON_WEEKLY_TAVERNDATA));

#endif /* not CROSS */
    l_Times.push_back(getMSTime() - l_StartTime);
#ifndef CROSS
    RewardCompletedAchievementsIfNeeded();
#endif /* not CROSS */
    CheckTalentSpells();
    l_Times.push_back(getMSTime() - l_StartTime);

    if ((getMSTime() - l_StartTime) > 50)
    {
        sLog->outInfo(LOG_FILTER_PROFILING, "Player::LoadFromDB profiling =======");
        for (int32 l_I = 0; l_I < (int32)l_Times.size(); l_I++)
            sLog->outInfo(LOG_FILTER_PROFILING, "Index [%u] : %u ms", l_I, l_Times[l_I]);
        sLog->outInfo(LOG_FILTER_PROFILING, "====================================");

    }

    return true;
}

bool Player::isAllowedToLoot(const Creature* creature)
{
    if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
        return false;

    if (HasPendingBind())
        return false;

    const Loot* loot = &creature->loot;
    if (loot->isLooted()) // nothing to loot or everything looted.
        return false;

    if (loot->AllowedPlayers.IsEnabled())
    {
        if (!loot->AllowedPlayers.HasPlayerGuid(GetGUID()))
            return false;
    }

    Group* thisGroup = GetGroup();
    if (!thisGroup)
        return this == creature->GetLootRecipient();
    else if (thisGroup != creature->GetLootRecipientGroup())
        return false;

    switch (thisGroup->GetLootMethod())
    {
        case FREE_FOR_ALL:
            return true;
        case ROUND_ROBIN:
        case MASTER_LOOT:
            // may only loot if the player is the loot roundrobin player
            // or if there are free/quest/conditional item for the player
            if (loot->RoundRobinPlayer == 0 || loot->RoundRobinPlayer == GetGUID())
                return true;

            return loot->hasItemFor(this);
        case GROUP_LOOT:
        case NEED_BEFORE_GREED:
            // may only loot if the player is the loot roundrobin player
            // or item over threshold (so roll(s) can be launched)
            // or if there are free/quest/conditional item for the player
            if (loot->RoundRobinPlayer == 0 || loot->RoundRobinPlayer == GetGUID())
                return true;

            if (loot->hasOverThresholdItem())
                return true;

            return loot->hasItemFor(this);
    }

    return false;
}

void Player::_LoadActions(PreparedQueryResult result)
{
    m_actionButtons.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint8 button = fields[0].GetUInt8();
            uint32 action = fields[1].GetUInt32();
            uint8 type = fields[2].GetUInt8();

            if (ActionButton* ab = addActionButton(button, action, type))
                ab->uState = ACTIONBUTTON_UNCHANGED;
            else
            {
                // Will deleted in DB at next save (it can create data until save but marked as deleted)
                m_actionButtons[button].uState = ACTIONBUTTON_DELETED;
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadAuras(PreparedQueryResult result, PreparedQueryResult resultEffect, uint32 timediff)
{
    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Loading auras for player %u", GetGUIDLow());

    std::list<auraEffectData> auraEffectList;
    if (resultEffect)
    {
        do
        {
            Field* fields = resultEffect->Fetch();
            uint8 slot = fields[0].GetUInt8();
            uint8 effect = fields[1].GetUInt8();
            uint32 baseamount = fields[2].GetUInt32();
            uint32 amount = fields[3].GetUInt32();

            auraEffectList.push_back(auraEffectData(slot, effect, amount, baseamount));
        }
        while (resultEffect->NextRow());
    }

    /*                                                           0       1        2         3                 4         5      6       7         8              9            10
    QueryResult* result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2,
                                                        11          12          13
                                                    maxduration, remaintime, remaincharges FROM character_aura WHERE guid = '%u'", GetGUIDLow());
    */

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            int32 damage[32];
            int32 baseDamage[32];
            uint64 caster_guid = fields[0].GetUInt64();
            uint8 slot = fields[1].GetUInt8();
            uint32 spellid = fields[2].GetUInt32();
            uint32 effmask = fields[3].GetUInt32();
            uint32 recalculatemask = fields[4].GetUInt32();
            uint8 stackcount = fields[5].GetUInt8();
            int32 maxduration = fields[6].GetInt32();
            int32 remaintime = fields[7].GetInt32();
            uint8 remaincharges = fields[8].GetUInt8();
            int32 castItemLevel = fields[9].GetInt32();

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
            if (!spellInfo)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Unknown aura (spellid %u), ignore.", spellid);
                continue;
            }

            // negative effects should continue counting down after logout
            if (remaintime != -1 && !spellInfo->IsPositive())
            {
                if (remaintime/IN_MILLISECONDS <= int32(timediff))
                    continue;

                remaintime -= timediff*IN_MILLISECONDS;
            }

            // prevent wrong values of remaincharges
            if (spellInfo->ProcCharges)
            {
                // we have no control over the order of applying auras and modifiers allow auras
                // to have more charges than value in SpellInfo
                if (remaincharges <= 0/* || remaincharges > spellproto->procCharges*/)
                    remaincharges = spellInfo->ProcCharges;
            }
            else
                remaincharges = 0;

            for(std::list<auraEffectData>::iterator itr = auraEffectList.begin(); itr != auraEffectList.end(); ++itr)
            {
                if (itr->_slot == slot)
                {
                    damage[itr->_effect] = itr->_amount;
                    baseDamage[itr->_effect] = itr->_baseamount;
                }
            }

            Aura* aura = Aura::TryCreate(spellInfo, effmask, this, NULL, &baseDamage[0], NULL, caster_guid, castItemLevel);
            if (aura != nullptr)
            {
                if (!aura->CanBeSaved())
                {
                    aura->Remove();
                    continue;
                }

                aura->SetLoadedState(maxduration, remaintime, remaincharges, stackcount, recalculatemask, &damage[0]);
                aura->ApplyForTargets();
                sLog->outInfo(LOG_FILTER_PLAYER, "Added aura spellid %u, effectmask %u", spellInfo->Id, effmask);
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadGlyphAuras()
{
    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
    {
        if (uint32 glyph = GetGlyph(GetActiveSpec(), i))
        {
            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
            {
                if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(GetGlyphSlot(i)))
                {
                    if (gp->TypeFlags == gs->TypeFlags)
                    {
                        CastSpell(this, gp->SpellId, true);
                        continue;
                    }
                    else
                        sLog->outError(LOG_FILTER_PLAYER, "Player %s has glyph with typeflags %u in slot with typeflags %u, removing.", m_name.c_str(), gp->TypeFlags, gs->TypeFlags);
                }
                else
                    sLog->outError(LOG_FILTER_PLAYER, "Player %s has not existing glyph slot entry %u on index %u", m_name.c_str(), GetGlyphSlot(i), i);
            }
            else
                sLog->outError(LOG_FILTER_PLAYER, "Player %s has not existing glyph entry %u on index %u", m_name.c_str(), glyph, i);

            // On any error remove glyph
            SetGlyph(i, 0);
        }
    }
}

bool Player::HasGlyph(uint32 spell_id) const
{
    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
        if (uint32 glyph = GetGlyph(GetActiveSpec(), i))
            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
                if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(GetGlyphSlot(i)))
                    if (gp->TypeFlags == gs->TypeFlags && gp->SpellId == spell_id)
                        return true;

    return false;
}

void Player::LoadCorpse()
{
    if (isAlive())
        sObjectAccessor->ConvertCorpseForPlayer(GetGUID());
    else
    {
        if (Corpse* corpse = GetCorpse())
            ApplyModFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_LOCAL_FLAG_RELEASE_TIMER, corpse && !sMapStore.LookupEntry(corpse->GetMapId())->Instanceable());
        else
            //Prevent Dead Player login without corpse
            ResurrectPlayer(0.5f);
    }
}

void Player::_LoadInventory(PreparedQueryResult result, uint32 timeDiff)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT data, text, bag, slot, item, item_template FROM character_inventory JOIN item_instance ON character_inventory.item = item_instance.guid WHERE character_inventory.guid = '%u' ORDER BY bag, slot", GetGUIDLow());
    //NOTE: the "order by `bag`" is important because it makes sure
    //the bagMap is filled before items in the bags are loaded
    //NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
    //expected to be equipped before offhand items (TODO: fixme)

#ifdef CROSS
    InterRealmDatabasePool* l_Database = GetRealmDatabase();
#else
    auto l_Database = &CharacterDatabase;
#endif

    if (result)
    {
        uint32 zoneId = GetZoneId(true);

        std::map<uint32, Bag*> bagMap;                                  // fast guid lookup for bags
        std::map<uint32, Item*> invalidBagMap;                          // fast guid lookup for bags
        std::list<Item*> problematicItems;
        SQLTransaction trans = l_Database->BeginTransaction();

        // Prevent items from being added to the queue while loading
        m_itemUpdateQueueBlocked = true;
        do
        {
            Field* fields = result->Fetch();
            if (Item* item = _LoadItem(trans, zoneId, timeDiff, fields))
            {
                uint32 bagGuid  = fields[16].GetUInt32();
                uint8  slot     = fields[17].GetUInt8();

                uint8 err = EQUIP_ERR_OK;
                // Item is not in bag
                if (!bagGuid)
                {
                    item->SetContainer(NULL);
                    item->SetSlot(slot);

                    if (IsInventoryPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        uint16 dest;
                        err = CanEquipItem(slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            QuickEquipItem(dest, item);
                    }
                    else if (IsBankPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            item = BankItem(dest, item, true);
                    }
                    else if (IsReagentBankPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanReagentBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                        if (err == EQUIP_ERR_OK)
                            item = BankItem(dest, item, true);
                    }

                    // Remember bags that may contain items in them
                    if (err == EQUIP_ERR_OK)
                    {
                        if (IsBagPos(item->GetPos()))
                            if (Bag* pBag = item->ToBag())
                                bagMap[item->GetRealGUIDLow()] = pBag;
                    }
                    else
                        if (IsBagPos(item->GetPos()))
                            if (item->IsBag())
                                invalidBagMap[item->GetRealGUIDLow()] = item;
                }
                else
                {
                    item->SetSlot(NULL_SLOT);
                    // Item is in the bag, find the bag
                    std::map<uint32, Bag*>::iterator itr = bagMap.find(bagGuid);
                    if (itr != bagMap.end())
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (invalidBagMap.find(bagGuid) != invalidBagMap.end())
                    {
                        std::map<uint32, Item*>::iterator itr = invalidBagMap.find(bagGuid);
                        if (std::find(problematicItems.begin(), problematicItems.end(),itr->second) != problematicItems.end())
                            err = EQUIP_ERR_INTERNAL_BAG_ERROR;
                    }
                    else
                    {
                        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which doesnt have a valid bag (Bag GUID: %u, slot: %u). Possible cheat?",
                            GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot);
                        item->DeleteFromInventoryDB(trans);
                        delete item;
                        continue;
                    }

                }

                // Item's state may have changed after storing
                if (err == EQUIP_ERR_OK)
                    item->SetState(ITEM_UNCHANGED, this);
                else
                {
                    sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which can't be loaded into inventory (Bag GUID: %u, slot: %u) by reason %u. Item will be sent by mail.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot, err);
                    item->DeleteFromInventoryDB(trans);
                    problematicItems.push_back(item);
                }

                if (item->GetTemplate()->Quality == ITEM_QUALITY_HEIRLOOM)
                    if (HeirloomEntry const* l_HeirloomEntry = GetHeirloomEntryByItemID(item->GetTemplate()->ItemId))
                        AddHeirloom(l_HeirloomEntry, item->HasCustomFlags(ItemCustomFlags::FromStore));
            }
        }
        while (result->NextRow());

        m_itemUpdateQueueBlocked = false;

        // Send problematic items by mail
        while (!problematicItems.empty())
        {
            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

            MailDraft draft(subject, "There were problems with equipping item(s).");
            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
            {
                draft.AddItem(problematicItems.front());
                problematicItems.pop_front();
            }
            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
        }
        l_Database->CommitTransaction(trans);
    }
    //if (isAlive())
    _ApplyAllItemMods();
}

void Player::_LoadVoidStorage(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
        Field* fields = result->Fetch();

        uint64 itemId = fields[0].GetUInt64();
        uint32 itemEntry = fields[1].GetUInt32();
        uint8 slot = fields[2].GetUInt8();
        uint32 creatorGuid = fields[3].GetUInt32();
        uint32 randomProperty = fields[4].GetUInt32();
        uint32 suffixFactor = fields[5].GetUInt32();
        Tokenizer l_BonusToken(fields[6].GetString(), ' ');

        if (!itemId)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName(), itemId, itemEntry);
            continue;
        }

        if (!sObjectMgr->GetItemTemplate(itemEntry))
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid entry (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName(), itemId, itemEntry);
            continue;
        }

        if (slot >= VOID_STORAGE_MAX_SLOT)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName(), itemId, itemEntry, slot);
            continue;
        }

        std::vector<uint32> l_Bonuses;
        for (uint8 l_I = 0; l_I < l_BonusToken.size(); ++l_I)
            l_Bonuses.push_back(atoi(l_BonusToken[l_I]));

        if (!sObjectMgr->GetPlayerByLowGUID(creatorGuid))
            creatorGuid = 0;

        _voidStorageItems[slot] = new VoidStorageItem(itemId, itemEntry, creatorGuid, randomProperty, suffixFactor, l_Bonuses);
    }
    while (result->NextRow());
}

Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
{
    Item* item = NULL;

#ifdef CROSS
    InterRealmDatabasePool* l_Database = GetRealmDatabase();
    uint32 l_RealmID = GetSession()->GetInterRealmNumber();
#else
    auto l_Database  = &CharacterDatabase;
    uint32 l_RealmID = g_RealmID;
#endif

    uint32 itemGuid  = fields[18].GetUInt32();
    uint32 itemEntry = fields[19].GetUInt32();

    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry))
    {
        bool remove = false;
        item = NewItemOrBag(proto);
        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry))
        {
            PreparedStatement* stmt = NULL;

            // Do not allow to have item limited to another map/zone in alive state
            if (isAlive() && item->IsLimitedToAnotherMapOrZone(GetMapId(), zoneId))
            {
                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', map: %u) has item (GUID: %u, entry: %u) limited to another map (%u). Deleting item.",
                    GetGUIDLow(), GetName(), GetMapId(), item->GetGUIDLow(), item->GetEntry(), zoneId);
                remove = true;
            }
            // "Conjured items disappear if you are logged out for more than 15 minutes"
            else if (timeDiff > 15 * MINUTE && proto->Flags & ITEM_FLAG_CONJURED)
            {
                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', diff: %u) has conjured item (GUID: %u, entry: %u) with expired lifetime (15 minutes). Deleting item.",
                    GetGUIDLow(), GetName(), timeDiff, item->GetGUIDLow(), item->GetEntry());
                remove = true;
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
            {
                if (item->GetPlayedTime() > (2 * HOUR))
                {
                    sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), item->GetPlayedTime());

                    stmt = l_Database->GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
                    stmt->setUInt32(0, item->GetRealGUIDLow());
                    trans->Append(stmt);

                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
                }
                else
                {
                    uint64 l_PlayerGUID = GetGUID();

                    PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_ITEM_REFUNDS);
                    l_Statement->setUInt32(0, item->GetRealGUIDLow());
                    l_Statement->setUInt32(1, GetRealGUIDLow());

                    AsyncQuery(*l_Database, l_Statement, [itemGuid, l_PlayerGUID](PreparedQueryResult p_Result) -> void
                    {
                        Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
                        if (l_Player == nullptr)
                            return;

                        Item* l_ItemRetreive = l_Player->GetItemByGuid(MAKE_NEW_GUID(itemGuid, 0, HIGHGUID_ITEM));
                        if (l_ItemRetreive == nullptr)
                            return;

                        if (p_Result)
                        {
                            l_ItemRetreive->SetRefundRecipient((*p_Result)[0].GetUInt32());
                            l_ItemRetreive->SetPaidMoney((*p_Result)[1].GetUInt32());
                            l_ItemRetreive->SetPaidExtendedCost((*p_Result)[2].GetUInt16());
                            l_Player->AddRefundReference(l_ItemRetreive->GetGUIDLow());
                        }
                        else
                        {
                            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with refundable flags, but without data in item_refund_instance. Removing flag.",
                                l_Player->GetGUIDLow(), l_Player->GetName(), l_ItemRetreive->GetGUIDLow(), l_ItemRetreive->GetEntry());
                            l_ItemRetreive->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
                        }
                    });
                }
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
            {
                uint64 l_PlayerGUID = GetGUID();

                PreparedStatement* l_Statement = l_Database->GetPreparedStatement(CHAR_SEL_ITEM_BOP_TRADE);
                l_Statement->setUInt32(0, item->GetRealGUIDLow());

                AsyncQuery(*l_Database, l_Statement, [itemGuid, l_PlayerGUID](PreparedQueryResult p_Result) -> void
                {
                    Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
                    if (l_Player == nullptr)
                        return;

                    Item* l_ItemRetreive = l_Player->GetItemByGuid(MAKE_NEW_GUID(itemGuid, 0, HIGHGUID_ITEM));
                    if (l_ItemRetreive == nullptr)
                        return;

                    if (p_Result)
                    {
                        std::string strGUID = (*p_Result)[0].GetString();
                        Tokenizer GUIDlist(strGUID, ' ');
                        AllowedLooterSet looters;
                        for (Tokenizer::const_iterator itr = GUIDlist.begin(); itr != GUIDlist.end(); ++itr)
                            looters.insert(atol(*itr));
                        l_ItemRetreive->SetSoulboundTradeable(looters);
                        l_Player->AddTradeableItem(l_ItemRetreive);
                    }
                    else
                    {
                        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with ITEM_FIELD_FLAG_BOP_TRADEABLE flag, but without data in item_soulbound_trade_data. Removing flag.",
                            l_Player->GetGUIDLow(), l_Player->GetName(), l_ItemRetreive->GetGUIDLow(), l_ItemRetreive->GetEntry());
                        l_ItemRetreive->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE);
                    }
                });
            }
            else if (proto->HolidayId)
            {
                remove = true;
                GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
                GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
                for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
                {
                    if (uint32(events[*itr].holiday_id) == proto->HolidayId)
                    {
                        remove = false;
                        break;
                    }
                }
            }
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has broken item (GUID: %u, entry: %u) in inventory. Deleting item.",
                GetGUIDLow(), GetName(), itemGuid, itemEntry);
            remove = true;
        }
        // Remove item from inventory if necessary
        if (remove)
        {
            Item::DeleteFromInventoryDB(trans, itemGuid, l_RealmID);
            item->FSetState(ITEM_REMOVED);
            item->SaveToDB(trans);                           // it also deletes item object!
            item = NULL;
        }
    }
    else
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has unknown item (entry: %u) in inventory. Deleting item.",
            GetGUIDLow(), GetName(), itemEntry);
    }
    return item;
}

// load mailed item which should receive current player
void Player::_LoadMailedItems(PreparedQueryResult p_MailedItems)
{
    // data needs to be at first place for Item::LoadFromDB
    if (!p_MailedItems)
        return;

    do
    {
        Field* l_Fields = p_MailedItems->Fetch();

        uint32 l_ItemGuid     = l_Fields[16].GetUInt32();
        uint32 l_ItemTemplate = l_Fields[17].GetUInt32();
        uint32 l_MailId       = l_Fields[19].GetUInt32();

        Mail* l_Mail = GetMail(l_MailId);
        if (l_Mail == nullptr)
            continue;

        l_Mail->AddItem(l_ItemGuid, l_ItemTemplate);

        ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(l_ItemTemplate);

        if (!l_Proto)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %u has unknown item_template (ProtoType) in mailed items(GUID: %u template: %u) in mail (%u), deleted.", GetGUIDLow(), l_ItemGuid, l_ItemTemplate, l_Mail->messageID);

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_MAIL_ITEM);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);

            l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);
            continue;
        }

        Item* l_Item = NewItemOrBag(l_Proto);
        if (!l_Item->LoadFromDB(l_ItemGuid, MAKE_NEW_GUID(l_Fields[18].GetUInt32(), 0, HIGHGUID_PLAYER), l_Fields, l_ItemTemplate))
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", l_Mail->messageID, l_ItemGuid);

            PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
            l_Statement->setUInt32(0, l_ItemGuid);
            CharacterDatabase.Execute(l_Statement);

            l_Item->FSetState(ITEM_REMOVED);

            SQLTransaction l_Tmp = SQLTransaction(NULL);
            l_Item->SaveToDB(l_Tmp);                               // it also deletes item object !
            continue;
        }

        AddMItem(l_Item);
    }
    while (p_MailedItems->NextRow());
}

void Player::_LoadMailInit(PreparedQueryResult resultUnread, PreparedQueryResult resultDelivery)
{
    //set a count of unread mails
    //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
    if (resultUnread)
        unReadMails = uint8((*resultUnread)[0].GetUInt64());

    // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
    //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
    if (resultDelivery)
        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
}

void Player::_LoadMail(PreparedQueryResult p_MailResult)
{
    m_mail.clear();

    if (p_MailResult)
    {
        do
        {
            Field* fields = p_MailResult->Fetch();
            Mail* m = new Mail;

            m->messageID      = fields[0].GetUInt32();
            m->messageType    = fields[1].GetUInt8();
            m->sender         = fields[2].GetUInt32();
            m->receiver       = fields[3].GetUInt32();
            m->subject        = fields[4].GetString();
            m->body           = fields[5].GetString();
            bool has_items    = fields[6].GetBool(); ///< hasitem is never read 01/18/16
            m->expire_time    = time_t(fields[7].GetUInt32());
            m->deliver_time   = time_t(fields[8].GetUInt32());
            m->money          = fields[9].GetUInt64();
            m->COD            = fields[10].GetUInt64();
            m->checked        = fields[11].GetUInt8();
            m->stationery     = fields[12].GetUInt8();
            m->mailTemplateId = fields[13].GetInt16();

            if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player::_LoadMail - Mail (%u) have not existed MailTemplateId (%u), remove at load", m->messageID, m->mailTemplateId);
                m->mailTemplateId = 0;
            }

            m->state = MAIL_STATE_UNCHANGED;

            m_mail.push_back(m);
        }
        while (p_MailResult->NextRow());
    }
}

void Player::LoadPet(PreparedQueryResult result)
{
    //fixme: the pet should still be loaded if the player is not in world
    // just not added to the map
    if (IsInWorld() && result)
    {
        Field* fields = result->Fetch();

#ifdef CROSS
        uint32 l_RealmID = GetSession()->GetInterRealmNumber();
#else
        uint32 l_RealmID = g_RealmID;
#endif

        PetQueryHolder* queryHolder = new PetQueryHolder(fields[0].GetUInt32(), l_RealmID, result);
        if (!queryHolder->Initialize())
        {
            delete queryHolder;
            return;
        }

        _petLoginCallback = RealmDatabase.DelayQueryHolder((SQLQueryHolder*)queryHolder);
    }
}

void Player::_LoadQuestStatus(PreparedQueryResult result)
{
    uint16 slot = 0;

    ////                                                       0      1       2        3
    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, explored, timer, FROM character_queststatus WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                // find or create
                QuestStatusData& questStatusData = m_QuestStatus[quest_id];

                uint8 qstatus = fields[1].GetUInt8();
                if (qstatus < MAX_QUEST_STATUS)
                    questStatusData.Status = QuestStatus(qstatus);
                else
                {
                    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
                    sLog->outError(LOG_FILTER_PLAYER, "Player %s (GUID: %u) has invalid quest %d status (%u), replaced by QUEST_STATUS_INCOMPLETE(3).",
                        GetName(), GetGUIDLow(), quest_id, qstatus);
                }

                questStatusData.Explored = (fields[2].GetUInt8() > 0);

                time_t quest_time = time_t(fields[3].GetUInt32());

                if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && !GetQuestRewardStatus(quest_id))
                {
                    AddTimedQuest(quest_id);

                    if (quest_time <= sWorld->GetGameTime())
                        questStatusData.Timer = 1;
                    else
                        questStatusData.Timer = uint32((quest_time - sWorld->GetGameTime()) * IN_MILLISECONDS);
                }
                else
                    quest_time = 0;


                // add to quest log
                if (slot < MAX_QUEST_LOG_SIZE && questStatusData.Status != QUEST_STATUS_NONE)
                {
                    SetQuestSlot(slot, quest_id, uint32(quest_time)); // cast can't be helped

                    if (questStatusData.Status == QUEST_STATUS_COMPLETE)
                        SetQuestSlotState(slot, QUEST_STATE_COMPLETE);
                    else if (questStatusData.Status == QUEST_STATUS_FAILED)
                        SetQuestSlotState(slot, QUEST_STATE_FAIL);

                    ++slot;
                }

                sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Quest status is {%u} for quest {%u} for player (GUID: %u)", questStatusData.Status, quest_id, GetGUIDLow());
            }
        }
        while (result->NextRow());
    }

    // clear quest log tail
    for (uint16 i = slot; i < MAX_QUEST_LOG_SIZE; ++i)
        SetQuestSlot(i, 0);
}

void Player::_LoadQuestObjectiveStatus(PreparedQueryResult result)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 objectiveId  = fields[0].GetUInt32();
            uint32 amount       = fields[1].GetUInt32();

            if (!sObjectMgr->QuestObjectiveExists(objectiveId))
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player %s (%u) has invalid Quest Objective Id %u in Quest Objective status data! Skipping.", GetName(), GetGUIDLow(), objectiveId);
                continue;
            }

            for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
            {
                uint32 questId = GetQuestSlotQuestId(i);
                if (!questId)
                    continue;

                uint32 objectiveQuestId = sObjectMgr->GetQuestObjectiveQuestId(objectiveId);
                if (questId != objectiveQuestId)
                    continue;

                // Quest existence is checked on Quest Objective load, no issue should arise
                QuestObjective const* objective = sObjectMgr->GetQuestTemplate(objectiveQuestId)->GetQuestObjective(objectiveId);

                SetQuestSlotCounter(i, objective->Index, amount);
                m_questObjectiveStatus.insert(std::make_pair(objectiveId, amount));

                if (objective->Type == QUEST_OBJECTIVE_TYPE_CRITERIA_TREE && (uint32)objective->Amount == amount)
                    SetQuestSlotState(i, QUEST_STATE_OBJ_0_COMPLETE << objective->Index);

                break;
            }
        } while (result->NextRow());
    }
}

void Player::_LoadQuestStatusRewarded(PreparedQueryResult result)
{
    // SELECT quest FROM character_queststatus_rewarded WHERE guid = ?

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                // learn rewarded spell if unknown
                learnQuestRewardedSpells(quest);

                // set rewarded title if any
                if (quest->GetCharTitleId())
                {
                    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
                        SetTitle(titleEntry);
                }

                /// Skip loading special quests - they are also added to rewarded quests but only once and remain there forever
                /// instead add them separately from load daily/weekly/monthly/seasonal
                if (!quest->IsDailyOrWeekly() && !quest->IsMonthly() && !quest->IsSeasonal())
                {
                    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(quest_id))
                        SetQuestBit(l_QuestBit, true);
                }

                if (uint32 talents = quest->GetBonusTalents())
                    AddQuestRewardedTalentCount(talents);
            }

            m_RewardedQuests.insert(quest_id);
        }
        while (result->NextRow());
    }
}

void Player::_LoadDailyQuestStatus(PreparedQueryResult result)
{
    m_dailyQuestStorage.clear();

    m_DFQuests.clear();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        uint32 quest_daily_idx = 0;
        do
        {
            Field* fields = result->Fetch();
            if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(fields[0].GetUInt32()))
            {
                if (qQuest->IsDFQuest())
                {
                    m_DFQuests.insert(qQuest->GetQuestId());
                    m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
                    continue;
                }
            }

            uint32 quest_id = fields[0].GetUInt32();

            // save _any_ from daily quest times (it must be after last reset anyway)
            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());

            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_dailyQuestStorage.insert(quest_id);
            if (++quest_daily_idx < DynamicFields::Count)
                SetDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED, quest_daily_idx++, quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit , true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Daily quest (%u) cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_DailyQuestChanged = false;
}

void Player::_LoadWeeklyQuestStatus(PreparedQueryResult result)
{
    m_weeklyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_weeklyquests.insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_WeeklyQuestChanged = false;
}

void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
{
    m_seasonalquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            uint32 event_id = fields[1].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_seasonalquests[event_id].insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Seasonal quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_SeasonalQuestChanged = false;
}

void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
{
    m_monthlyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_monthlyquests.insert(quest_id);

            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                SetQuestBit(questBit, true);

            sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "Monthly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_MonthlyQuestChanged = false;
}

void Player::_LoadSpells(PreparedQueryResult result)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 l_SpellID = fields[0].GetUInt32();

            for (uint32 l_I = 0; l_I < sBattlePetSpeciesStore.GetNumRows(); l_I++)
            {
                BattlePetSpeciesEntry const* speciesInfo = sBattlePetSpeciesStore.LookupEntry(l_I);

                if (speciesInfo && speciesInfo->spellId == l_SpellID)
                {
                    m_OldPetBattleSpellToMerge.push_back(std::make_pair(l_SpellID, speciesInfo->id));
                    break;
                }

            }

            addSpell(fields[0].GetUInt32(), fields[1].GetBool(), false, false, fields[2].GetBool(), true, fields[3].GetBool());
        }
        while (result->NextRow());
    }
}

#ifndef CROSS
void Player::_LoadGarrisonDailyTavernDatas(PreparedQueryResult p_Result)
{
    MS::Garrison::Manager* l_GarrisonMgr = GetGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    if (p_Result)
    {
        do
        {
            Field* fields = p_Result->Fetch();

            uint32 l_NpcEntry = fields[1].GetUInt32();
            l_GarrisonMgr->SetGarrisonDailyTavernData(l_NpcEntry);
        }
        while (p_Result->NextRow());
    }
    else
    {

        if (l_GarrisonMgr->HasActiveBuilding(MS::Garrison::Building::ID::LunarfallInn_FrostwallTavern_Level1))
        {
            if (roll_chance_i(50))
            {
                uint32 l_Entry = MS::Garrison::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::TavernDatas::g_QuestGiverEntries.size() - 1)];

                l_GarrisonMgr->CleanGarrisonDailyTavernData();
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_Entry);
            }
            else
            {
                uint32 l_FirstEntry  = MS::Garrison::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::TavernDatas::g_QuestGiverEntries.size() - 1)];
                uint32 l_SecondEntry = 0;

                do
                    l_SecondEntry = MS::Garrison::TavernDatas::g_QuestGiverEntries[urand(0, MS::Garrison::TavernDatas::g_QuestGiverEntries.size() - 1)];
                while (l_SecondEntry == l_FirstEntry);

                l_GarrisonMgr->CleanGarrisonDailyTavernData();
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_FirstEntry);
                l_GarrisonMgr->AddGarrisonDailyTavernData(l_SecondEntry);
            }
        }
    }
}

void Player::_LoadCharacterGarrisonWeeklyTavernDatas(PreparedQueryResult p_Result)
{
    MS::Garrison::Manager* l_GarrisonMgr = GetGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    if (p_Result)
    {
        do
        {
            Field* l_Fields = p_Result->Fetch();
            std::vector<uint32> l_AbilitiesVector;
            uint32 l_FollowerID = l_Fields[1].GetUInt32();
            std::string l_Abilities = l_Fields[2].GetString();

            Tokenizer l_Tokens(l_Abilities, ' ');

            for (Tokenizer::const_iterator l_Iter = l_Tokens.begin(); l_Iter != l_Tokens.end(); ++l_Iter)
                l_AbilitiesVector.push_back(uint32(atol(*l_Iter)));

            MS::Garrison::WeeklyTavernData l_TavernData = { l_FollowerID, l_AbilitiesVector };

            l_GarrisonMgr->SetGarrisonWeeklyTavernData(l_TavernData);
        }
        while (p_Result->NextRow());
    }
}
#endif

void Player::_LoadGroup(PreparedQueryResult result)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", GetGUIDLow());
    if (result)
    {
        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*result)[0].GetUInt32()))
        {
            uint8 subgroup = group->GetMemberGroup(GetGUID());
            SetGroup(group, subgroup);
            if (getLevel() >= LEVELREQUIREMENT_HEROIC)
            {
                // the group leader may change the instance difficulty while the player is offline
                SetDungeonDifficultyID(group->GetDungeonDifficultyID());
                SetRaidDifficultyID(group->GetRaidDifficultyID());
                SetLegacyRaidDifficultyID(group->GetLegacyRaidDifficultyID());
            }
        }
    }
}

void Player::_LoadBoundInstances(PreparedQueryResult result)
{
    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
        m_boundInstances[i].clear();

    Group* group = GetGroup();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            bool perm = fields[1].GetBool();
            uint32 mapId = fields[2].GetUInt16();
            uint32 instanceId = fields[0].GetUInt32();
            uint8 difficulty = fields[3].GetUInt8();

            time_t resetTime = time_t(fields[4].GetUInt32());
            // the resettime for normal instances is only saved when the InstanceSave is unloaded
            // so the value read from the DB may be wrong here but only if the InstanceSave is loaded
            // and in that case it is not used

            bool deleteInstance = false;

            MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
            if (!mapEntry || !mapEntry->IsDungeon())
            {
                sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed or not dungeon map %d", GetName(), GetGUIDLow(), mapId);
                deleteInstance = true;
            }
            else if (difficulty >= Difficulty::MaxDifficulties)
            {
                sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), difficulty, mapId);
                deleteInstance = true;
            }
            else
            {
                MapDifficulty const* mapDiff = GetMapDifficultyData(mapId, Difficulty(difficulty));
                if (!mapDiff)
                {
                    sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), difficulty, mapId);
                    deleteInstance = true;
                }
                else if (!perm && group)
                {
                    sLog->outError(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) is in group %d but has a non-permanent character bind to map %d, %d, %d", GetName(), GetGUIDLow(), GUID_LOPART(group->GetGUID()), mapId, instanceId, difficulty);
                    deleteInstance = true;
                }
            }

            if (deleteInstance)
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt32(1, instanceId);

                CharacterDatabase.Execute(stmt);

                continue;
            }

            // since non permanent binds are always solo bind, they can always be reset
            if (InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapId, instanceId, Difficulty(difficulty), resetTime, !perm, true))
               BindToInstance(save, perm, true);
        }
        while (result->NextRow());
    }
}

InstancePlayerBind* Player::GetBoundInstance(uint32 mapid, Difficulty difficulty)
{
    // some instances only have one difficulty
    MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(mapid, difficulty);
    if (!mapDiff)
        return NULL;

    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
    if (itr != m_boundInstances[difficulty].end())
        return &itr->second;
    else
        return NULL;
}

InstanceSave* Player::GetInstanceSave(uint32 p_MapID)
{
    MapEntry const     * l_MapEntry = sMapStore.LookupEntry(p_MapID);
    InstancePlayerBind * l_Bind     = GetBoundInstance(p_MapID, GetDifficultyID(l_MapEntry));
    InstanceSave       * l_Save     = l_Bind ? l_Bind->save : NULL;

    if (!l_Bind || !l_Bind->perm)
    {
        if (Group* l_Group = GetGroup())
        {
            if (InstanceGroupBind* l_GroupBind = l_Group->GetBoundInstance(this))
                l_Save = l_GroupBind->save;
        }
    }

    if (!l_Bind || !l_Bind->perm)
    {
        if (Group* l_Group = GetGroup())
        {
            if (InstanceGroupBind* l_GroupBind = l_Group->GetBoundInstance(this))
                l_Save = l_GroupBind->save;
        }
    }

    return l_Save;
}

void Player::UnbindInstance(uint32 mapid, Difficulty difficulty, bool unload)
{
    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
    UnbindInstance(itr, difficulty, unload);
}

void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficulty, bool unload)
{
    if (itr != m_boundInstances[difficulty].end())
    {
        if (!unload)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, itr->second.save->GetInstanceId());
            RealmDatabase.Execute(stmt);
        }

#ifndef CROSS
        if (itr->second.perm)
            GetSession()->SendCalendarRaidLockout(itr->second.save, false);
#endif

        itr->second.save->RemovePlayer(this);               // save can become invalid
        m_boundInstances[difficulty].erase(itr++);
    }
}

InstancePlayerBind* Player::BindToInstance(InstanceSave* p_InstanceSave, bool p_Permanent, bool p_Load)
{
    if (p_InstanceSave && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyRaidLFR && p_InstanceSave->GetDifficultyID() != Difficulty::DifficultyRaidTool)
    {
        InstancePlayerBind& l_InstanceBind = m_boundInstances[p_InstanceSave->GetDifficultyID()][p_InstanceSave->GetMapId()];
        if (l_InstanceBind.save)
        {
            // update the save when the group kills a boss
            if (p_Permanent != l_InstanceBind.perm || p_InstanceSave != l_InstanceBind.save)
            {
                if (!p_Load)
                {
                    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INSTANCE);
                    l_Statement->setUInt32(0, p_InstanceSave->GetInstanceId());
                    l_Statement->setBool(1, p_Permanent);
                    l_Statement->setUInt32(2, GetRealGUIDLow());
                    l_Statement->setUInt32(3, l_InstanceBind.save->GetInstanceId());
                    RealmDatabase.Execute(l_Statement);
                }
            }
        }
        else
        {
            if (!p_Load)
            {
                PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_INSTANCE);
                l_Statement->setUInt32(0, GetRealGUIDLow());
                l_Statement->setUInt32(1, p_InstanceSave->GetInstanceId());
                l_Statement->setBool(2, p_Permanent);
                RealmDatabase.Execute(l_Statement);
            }
        }

        if (l_InstanceBind.save != p_InstanceSave)
        {
            if (l_InstanceBind.save)
                l_InstanceBind.save->RemovePlayer(this);

            p_InstanceSave->AddPlayer(this);
        }

        if (p_Permanent)
            p_InstanceSave->SetCanReset(false);

        l_InstanceBind.save = p_InstanceSave;
        l_InstanceBind.perm = p_Permanent;

        if (!p_Load)
            sLog->outDebug(LOG_FILTER_MAPS, "Player::BindToInstance: %s(%d) is now bound to map %d, instance %d, difficulty %d", GetName(), GetGUIDLow(), p_InstanceSave->GetMapId(), p_InstanceSave->GetInstanceId(), p_InstanceSave->GetDifficultyID());

        sScriptMgr->OnPlayerBindToInstance(this, p_InstanceSave->GetDifficultyID(), p_InstanceSave->GetMapId(), p_Permanent);
        return &l_InstanceBind;
    }
    else
        return nullptr;
}

void Player::BindToInstance()
{
    InstanceSave* mapSave = sInstanceSaveMgr->GetInstanceSave(_pendingBindId);
    if (!mapSave) //it seems sometimes mapSave is NULL, but I did not check why
        return;

    WorldPacket data(SMSG_INSTANCE_SAVE_CREATED, 4);
    data.WriteBit(false);
    GetSession()->SendPacket(&data);
    BindToInstance(mapSave, true);

#ifndef CROSS
    GetSession()->SendCalendarRaidLockout(mapSave, true);
#endif
}

void Player::SendRaidInfo()
{
    uint32 l_Counter = 0;
    WorldPacket l_Data(SMSG_RAID_INSTANCE_INFO, 1024);
    ByteBuffer l_Buffer;
    time_t l_Now = time(NULL);

    for (uint8 l_Iter = 0; l_Iter < Difficulty::MaxDifficulties; ++l_Iter)
    {
        for (BoundInstancesMap::iterator l_Itr = m_boundInstances[l_Iter].begin(); l_Itr != m_boundInstances[l_Iter].end(); ++l_Itr)
        {
            if (l_Itr->second.perm)
            {
                InstanceSave* l_Save = l_Itr->second.save;
                l_Counter++;

                l_Buffer << uint32(l_Save->GetMapId());
                l_Buffer << uint32(l_Save->GetDifficultyID());
                l_Buffer << uint64(l_Save->GetInstanceId());
                l_Buffer << uint32(l_Save->GetResetTime() - l_Now);
                l_Buffer << uint32(l_Save->GetEncounterMask());
                l_Buffer.WriteBit(true);    ///< Locked
                l_Buffer.WriteBit(false);   ///< Extended
                l_Buffer.FlushBits();
            }
        }
    }

    l_Data << uint32(l_Counter);
    if (l_Counter)
        l_Data.append(l_Buffer);

    GetSession()->SendPacket(&l_Data);
}

/*
- called on every successful teleportation to a map
*/
void Player::SendSavedInstances()
{
    bool hasBeenSaved = false;
    WorldPacket data;

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)                               // only permanent binds are sent
            {
                hasBeenSaved = true;
                break;
            }
        }
    }

    //Send opcode SMSG_UPDATE_INSTANCE_OWNERSHIP. true or false means, whether you have current raid/heroic instances
    data.Initialize(SMSG_UPDATE_INSTANCE_OWNERSHIP, 4);
    data << uint32(hasBeenSaved);
    GetSession()->SendPacket(&data);

    if (!hasBeenSaved)
        return;

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)
            {
                data.Initialize(SMSG_UPDATE_LAST_INSTANCE, 4);
                data << uint32(itr->second.save->GetMapId());
                GetSession()->SendPacket(&data);
            }
        }
    }
}

/// convert the player's binds to the group
void Player::ConvertInstancesToGroup(Player* player, Group* group, bool switchLeader)
{
    // copy all binds to the group, when changing leader it's assumed the character
    // will not have any solo binds

    for (uint8 i = 0; i < Difficulty::MaxDifficulties; ++i)
    {
        for (BoundInstancesMap::iterator itr = player->m_boundInstances[i].begin(); itr != player->m_boundInstances[i].end();)
        {
            if (!switchLeader || !group->GetBoundInstance(itr->second.save->GetDifficultyID(), itr->first))
                group->BindToInstance(itr->second.save, itr->second.perm, false);

            // permanent binds are not removed
            if (switchLeader && !itr->second.perm)
            {
                // increments itr in call
                player->UnbindInstance(itr, Difficulty(i), false);
            }
            else
                ++itr;
        }
    }
}

bool Player::Satisfy(AccessRequirement const* ar, uint32 target_map, bool report)
{
    if (!isGameMaster() && ar)
    {
        uint8 LevelMin = 0;
        uint8 LevelMax = 0;

        MapEntry const* mapEntry = sMapStore.LookupEntry(target_map);
        if (!mapEntry)
            return false;

        if (!sWorld->getBoolConfig(CONFIG_INSTANCE_IGNORE_LEVEL))
        {
            if (ar->levelMin && getLevel() < ar->levelMin)
                LevelMin = ar->levelMin;
            if (ar->levelMax && getLevel() > ar->levelMax)
                LevelMax = ar->levelMax;
        }

        uint32 missingItem = 0;
        if (ar->item)
        {
            if (!HasItemCount(ar->item) &&
                (!ar->item2 || !HasItemCount(ar->item2)))
                missingItem = ar->item;
        }
        else if (ar->item2 && !HasItemCount(ar->item2))
            missingItem = ar->item2;

        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, target_map, this))
            return false;

        uint32 missingQuest = 0;
        if (GetTeam() == ALLIANCE && ar->quest_A && !GetQuestRewardStatus(ar->quest_A))
            missingQuest = ar->quest_A;
        else if (GetTeam() == HORDE && ar->quest_H && !GetQuestRewardStatus(ar->quest_H))
            missingQuest = ar->quest_H;

        uint32 missingAchievement = 0;
        Player* leader = this;
        uint64 leaderGuid = GetGroup() ? GetGroup()->GetLeaderGUID() : GetGUID();
        if (leaderGuid != GetGUID())
            leader = ObjectAccessor::FindPlayer(leaderGuid);

        if (ar->achievement)
            if (!leader || !leader->GetAchievementMgr().HasAchieved(ar->achievement))
                missingAchievement = ar->achievement;

        uint32 missingLeaderAchievement = 0;
        if (ar->leader_achievement)
        {
            if (GetGroup())
            {
                if (Player* pLeader = ObjectAccessor::FindPlayer(GetGroup()->GetLeaderGUID()))
                    if (!pLeader->GetAchievementMgr().HasAchieved(ar->leader_achievement))
                        missingLeaderAchievement = ar->leader_achievement;
            }
            else
                if (!GetAchievementMgr().HasAchieved(ar->leader_achievement))
                    missingLeaderAchievement = ar->leader_achievement;
        }

        Difficulty target_difficulty = GetDifficultyID(mapEntry);
        MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(target_map, target_difficulty);
        if (!mapDiff)
            return false;

        if (LevelMin || LevelMax || missingItem || missingQuest || missingAchievement || missingLeaderAchievement)
        {
            if (report)
            {
                if (missingQuest && !ar->questFailedText.empty())
                    ChatHandler(GetSession()).PSendSysMessage("%s", ar->questFailedText.c_str());
                else if (mapDiff->HasErrorMessage) // if (missingAchievement) covered by this case
                    SendTransferAborted(target_map, TRANSFER_ABORT_DIFFICULTY, target_difficulty);
            }
            return false;
        }
    }
    return true;
}

bool Player::CheckInstanceLoginValid()
{
    if (!GetMap())
        return false;

    if (!GetMap()->IsDungeon() || isGameMaster() || (GetMap()->IsDungeon() && GetMap()->Expansion() < 4))
        return true;

    if (GetMap()->IsRaid())
    {
        // cannot be in raid instance without a group
        if (!GetGroup())
            return false;
    }
    else
    {
        // cannot be in normal instance without a group and more players than 1 in instance
        if (!GetGroup() && GetMap()->GetPlayersCountExceptGMs() > 1)
            return false;
    }

    // do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
    return sMapMgr->CanPlayerEnter(GetMap()->GetId(), this, true);
}

bool Player::_LoadHomeBind(PreparedQueryResult result)
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player (Name %s) has incorrect race/class (%u/%u) pair. Can't be loaded.", GetName(), uint32(getRace()), uint32(getClass()));
        return false;
    }

    bool ok = false;
    // SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
    if (result)
    {
        Field* fields = result->Fetch();

        m_homebindMapId = fields[0].GetUInt16();
        m_homebindAreaId = fields[1].GetUInt16();
        m_homebindX = fields[2].GetFloat();
        m_homebindY = fields[3].GetFloat();
        m_homebindZ = fields[4].GetFloat();

        MapEntry const* bindMapEntry = sMapStore.LookupEntry(m_homebindMapId);

        // accept saved data only for valid position (and non instanceable), and accessable
        if (MapManager::IsValidMapCoord(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ) &&
            !bindMapEntry->Instanceable() && GetSession()->Expansion() >= bindMapEntry->Expansion())
            ok = true;
        else
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, GetRealGUIDLow());
            RealmDatabase.Execute(stmt);
        }
    }

    if (!ok)
    {
        m_homebindMapId = info->mapId;
        m_homebindAreaId = info->areaId;
        m_homebindX = info->positionX;
        m_homebindY = info->positionY;
        m_homebindZ = info->positionZ;

        PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt16(1, m_homebindMapId);
        stmt->setUInt16(2, m_homebindAreaId);
        stmt->setFloat (3, m_homebindX);
        stmt->setFloat (4, m_homebindY);
        stmt->setFloat (5, m_homebindZ);
        RealmDatabase.Execute(stmt);
    }

    sLog->outDebug(LOG_FILTER_PLAYER, "Setting player home position - mapid: %u, areaid: %u, X: %f, Y: %f, Z: %f",
        m_homebindMapId, m_homebindAreaId, m_homebindX, m_homebindY, m_homebindZ);

    return true;
}

/*********************************************************/
/***                   SAVE SYSTEM                     ***/
/*********************************************************/
void Player::SaveToDB(bool create /*=false*/, MS::Utilities::CallBackPtr p_Callback)
{
#ifdef CROSS
    if (!PlayOnCross())
        return;
#endif

    // delay auto save at any saves (manual, in code, or autosave)
    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

#ifndef CROSS
    if (GetSession()->GetInterRealmBG())
        return;

#endif /* not CROSS */
    //lets allow only players in world to be saved
#ifndef CROSS
    if (IsBeingTeleportedFar())
#else /* CROSS */
    if (IsBeingTeleportedFar() || GetSession()->PlayerLoading())
#endif /* CROSS */
    {
        ScheduleDelayedOperation(DELAYED_SAVE_PLAYER);
        return;
    }

    // first save/honor gain after midnight will also update the player's honor fields
    UpdateHonorFields();

    sLog->outDebug(LOG_FILTER_UNITS, "The value of player %s at save: ", m_name.c_str());
    outDebugValues();

    PreparedStatement* stmt = NULL;
    uint8 index = 0;

    if (create)
    {
        //! Insert query
        //! TO DO: Filter out more redundant fields that can take their default value at player create
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER);
        stmt->setUInt32(index++, GetRealGUIDLow());
        stmt->setUInt32(index++, GetSession()->GetAccountId());
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_REST_STATE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));
        stmt->setUInt16(index++, (uint16)GetMapId());
        stmt->setUInt32(index++, (uint32)GetInstanceId());
        stmt->setUInt8(index++, GetDungeonDifficultyID());
        stmt->setUInt8(index++, GetRaidDifficultyID());
        stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
        stmt->setFloat(index++, finiteAlways(GetPositionX()));
        stmt->setFloat(index++, finiteAlways(GetPositionY()));
        stmt->setFloat(index++, finiteAlways(GetPositionZ()));
        stmt->setFloat(index++, finiteAlways(GetOrientation()));

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());

        ss.str("");
        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
            ss << GetPrimaryTalentTree(i) << " ";
        stmt->setString(index++, ss.str());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId(true));
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(Powers(i), getClass()) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetSpecsCount());
        stmt->setUInt8(index++, GetActiveSpec());

        stmt->setUInt32(index++, 0);
        stmt->setUInt32(index++, 0);

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");

        /// Cache equipment...
        for (uint32 l_I = 0; l_I < EquipmentSlots::EQUIPMENT_SLOT_END; ++l_I)
        {
            if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            {
                ss << l_Item->GetVisibleEntry() << ' ';
                ss << GetItemDisplayID(l_Item->GetVisibleEntry(), l_Item->GetVisibleAppearanceModID()) << ' ';
                ss << l_Item->GetVisibleItemVisual() << ' ';
            }
            else
                ss << "0 0 0 ";
        }

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';

            ss << " 0";
            ss << " 0 ";
        }
        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';
        stmt->setString(index++, ss.str());

        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 1));
        stmt->setUInt8(index++, m_currentPetSlot);
        stmt->setUInt32(index++, m_grantableLevels);
        stmt->setUInt32(index++, m_LastSummonedBattlePet);
        stmt->setFloat(index++, m_PersonnalXpRate);
        stmt->setUInt32(index++, m_petSlotUsed);
        stmt->setUInt32(index++, GetAverageItemLevelTotal());
    }
    else
    {
        // Update query
        stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_REST_STATE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));

#ifndef CROSS
        uint16 l_MapID = IsInGarrison() ? MS::Garrison::Globals::BaseMap : (IsBeingTeleported() ? GetTeleportDest().GetMapId() : GetMapId());
#else
        uint16 l_MapID = (IsBeingTeleported() ? GetTeleportDest().GetMapId() : GetMapId());
#endif

        if (!IsBeingTeleported())
        {
            stmt->setUInt16(index++, (uint16)l_MapID);
            stmt->setUInt32(index++, (uint32)GetInstanceId());
            stmt->setUInt8(index++, GetDungeonDifficultyID());
            stmt->setUInt8(index++, GetRaidDifficultyID());
            stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
            stmt->setFloat(index++, finiteAlways(GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetOrientation()));
        }
        else
        {
            stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
            stmt->setUInt32(index++, (uint32)0);
            stmt->setUInt8(index++, GetDungeonDifficultyID());
            stmt->setUInt8(index++, GetRaidDifficultyID());
            stmt->setUInt8(index++, GetLegacyRaidDifficultyID());
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
        }

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());

        ss.str("");
        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
            ss << GetPrimaryTalentTree(i) << " ";
        stmt->setString(index++, ss.str());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId(true));
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(Powers(i), getClass()) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetSpecsCount());
        stmt->setUInt8(index++, GetActiveSpec());

        stmt->setUInt32(index++, GetSpecializationId(0));
        stmt->setUInt32(index++, GetSpecializationId(1));

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");

        /// Cache equipment...
        for (uint32 l_I = 0; l_I < EquipmentSlots::EQUIPMENT_SLOT_END; ++l_I)
        {
            if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            {
                ss << l_Item->GetVisibleEntry() << ' ';
                ss << GetItemDisplayID(l_Item->GetVisibleEntry(), l_Item->GetVisibleAppearanceModID()) << ' ';
                ss << l_Item->GetVisibleItemVisual() << ' ';
            }
            else
                ss << "0 0 0 ";
        }

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';
            ss << " 0";
            ss << " 0 ";
        }

        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';

        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 1));
        stmt->setUInt8(index++, m_currentPetSlot);
        stmt->setUInt32(index++, m_grantableLevels);

        stmt->setUInt8(index++, IsInWorld() ? 1 : 0);

        stmt->setUInt32(index++, GetSpecializationResetCost());
        stmt->setUInt32(index++, GetSpecializationResetTime());
        stmt->setUInt32(index++, m_LastSummonedBattlePet);

        stmt->setFloat(index++, m_PersonnalXpRate);
        stmt->setUInt32(index++, m_petSlotUsed);
        stmt->setUInt32(index++, GetAverageItemLevelTotal());

        // Index
        stmt->setUInt32(index++, GetRealGUIDLow());
    }

    SQLTransaction trans = RealmDatabase.BeginTransaction();
    SQLTransaction accountTrans = LoginDatabase.BeginTransaction();

    trans->Append(stmt);

#ifndef CROSS
    if (m_Garrison)
        m_Garrison->Save();
#endif

    if (m_mailsUpdated)                                     //save mails only when needed
        _SaveMail(trans);

    _SaveArenaData(trans);
    _SaveBGData(trans);
    _SaveInventory(trans);
    _SaveVoidStorage(trans);
    _SaveQuestStatus(trans);
    _SaveQuestObjectiveStatus(trans);
    _SaveDailyQuestStatus(trans);
    _SaveWeeklyQuestStatus(trans);
    _SaveSeasonalQuestStatus(trans);
    _SaveMonthlyQuestStatus(trans);
    _SaveTalents(trans);
    _SaveSpells(trans, accountTrans);
    _SaveSpellCooldowns(trans);
    _SaveChargesCooldowns(trans);
    _SaveActions(trans);
    _SaveAuras(trans);
    _SaveSkills(trans);
    m_achievementMgr.SaveToDB(trans);
    m_reputationMgr.SaveToDB(trans);
    _SaveEquipmentSets(trans);
    GetSession()->SaveTutorialsData(trans);                 // changed only while character in game
    _SaveGlyphs(trans);
    _SaveInstanceTimeRestrictions(trans);
    _SaveCurrency(trans);
    m_archaeologyMgr.SaveArchaeology(trans);
    _SaveCharacterWorldStates(trans);

#ifndef CROSS
    _SaveCharacterGarrisonDailyTavernDatas(trans);
    _SaveCharacterGarrisonWeeklyTavernDatas(trans);
#endif

    // check if stats should only be saved on logout
    // save stats can be out of transaction
    if (m_session->isLogingOut() || !sWorld->getBoolConfig(CONFIG_STATS_SAVE_ONLY_ON_LOGOUT))
        _SaveStats(trans);

    for (std::vector<BattlePet::Ptr>::iterator l_It = m_BattlePets.begin(); l_It != m_BattlePets.end(); ++l_It)
    {
        BattlePet::Ptr l_Pet = (*l_It);
        l_Pet->Save(accountTrans);
    }

    CommitTransaction(RealmDatabase, trans, p_Callback);
    LoginDatabase.CommitTransaction(accountTrans);

    // we save the data here to prevent spamming
    sAnticheatMgr->SavePlayerData(this);

    // save pet (hunter pet level and experience and all type pets health/mana).
    if (Pet* pet = GetPet())
        pet->SavePetToDB(PET_SLOT_ACTUAL_PET_SLOT, pet->m_Stampeded);
}

// fast save function for item/money cheating preventing - save only inventory and money state
void Player::SaveInventoryAndGoldToDB(SQLTransaction& trans)
{
    _SaveInventory(trans);
    _SaveCurrency(trans);
    _SaveVoidStorage(trans);
    SaveGoldToDB(trans);
}

void Player::SaveGoldToDB(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
    stmt->setUInt64(0, GetMoney());
    stmt->setUInt32(1, GetRealGUIDLow());
    trans->Append(stmt);
}

void Player::_SaveActions(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
    {
        switch (itr->second.uState)
        {
            case ACTIONBUTTON_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt8(1, GetActiveSpec());
                stmt->setUInt8(2, itr->first);
                stmt->setUInt32(3, itr->second.GetAction());
                stmt->setUInt8(4, uint8(itr->second.GetType()));
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
                stmt->setUInt32(0, itr->second.GetAction());
                stmt->setUInt8(1, uint8(itr->second.GetType()));
                stmt->setUInt32(2,  GetRealGUIDLow());
                stmt->setUInt8(3, itr->first);
                stmt->setUInt8(4, GetActiveSpec());
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_DELETED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt8(1, itr->first);
                stmt->setUInt8(2, GetActiveSpec());
                trans->Append(stmt);

                m_actionButtons.erase(itr++);
                break;
            default:
                ++itr;
                break;
        }
    }
}

void Player::_SaveAuras(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);
    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
    {
        if (!itr->second->CanBeSaved())
            continue;

        Aura* aura = itr->second;
        AuraApplication * foundAura = GetAuraApplication(aura->GetId(), aura->GetCasterGUID(), aura->GetCastItemGUID());

        if (!foundAura)
            continue;


        uint8 index = 0;
        int32 damage[SpellEffIndex::MAX_EFFECTS];
        int32 baseDamage[SpellEffIndex::MAX_EFFECTS];
        uint32 effMask = 0;
        uint32 recalculateMask = 0;
        for (uint8 i = 0; i < aura->GetEffectCount(); ++i)
        {
            if (AuraEffect const* effect = aura->GetEffect(i))
            {
                index = 0;
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_AURA_EFFECT);
                stmt->setUInt32(index++, GetRealGUIDLow());
                stmt->setUInt8(index++, foundAura->GetSlot());
                stmt->setUInt8(index++, i);
                stmt->setInt32(index++, effect->GetBaseAmount());
                stmt->setInt32(index++, effect->GetAmount());

                trans->Append(stmt);

                baseDamage[i] = effect->GetBaseAmount();
                damage[i] = effect->GetAmount();
                effMask |= 1 << i;
                if (effect->CanBeRecalculated())
                    recalculateMask |= 1 << i;
            }
            else
            {
                baseDamage[i] = 0;
                damage[i] = 0;
            }
        }

        index = 0;
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_AURA);
        stmt->setUInt32(index++, GetRealGUIDLow());
        stmt->setUInt8(index++, foundAura->GetSlot());
        stmt->setUInt64(index++, itr->second->GetCasterGUID());
        stmt->setUInt64(index++, itr->second->GetCastItemGUID());
        stmt->setUInt32(index++, itr->second->GetId());
        stmt->setUInt32(index++, effMask);
        stmt->setUInt32(index++, recalculateMask);
        stmt->setUInt8(index++, itr->second->GetStackAmount());
        stmt->setInt32(index++, itr->second->GetMaxDuration());
        stmt->setInt32(index++, itr->second->GetDuration());
        stmt->setUInt8(index++, itr->second->GetCharges());
        stmt->setInt32(index++, aura->GetCastItemLevel());
        trans->Append(stmt);
    }
}

void Player::_SaveInventory(SQLTransaction& trans)
{
    // force items in buyback slots to new state
    // and remove those that aren't already
    for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
    {
        Item* item = m_items[i];
        if (!item || item->GetState() == ITEM_NEW)
            continue;

        trans->PAppend("DELETE FROM character_inventory WHERE item = %u", item->GetRealGUIDLow());
        trans->PAppend("DELETE FROM item_instance WHERE guid = %u", item->GetRealGUIDLow());

        m_items[i]->FSetState(ITEM_NEW);
    }

    // Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
    // the client auto counts down in real time after having received the initial played time on the first
    // SMSG_SET_ITEM_PURCHASE_DATA packet.
    // Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
    std::set<uint32>::iterator i_next;
    for (std::set<uint32>::iterator itr = m_refundableItems.begin(); itr!= m_refundableItems.end(); itr = i_next)
    {
        // use copy iterator because itr may be invalid after operations in this loop
        i_next = itr;
        ++i_next;

        Item* iPtr = GetItemByGuid(MAKE_NEW_GUID(*itr, 0, HIGHGUID_ITEM));
        if (iPtr)
        {
            iPtr->UpdatePlayedTime(this);
            continue;
        }
        else
        {
            sLog->outError(LOG_FILTER_PLAYER, "Can't find item guid %u but is in refundable storage for player %u ! Removing.", *itr, GetGUIDLow());
            m_refundableItems.erase(itr);
        }
    }

    // update enchantment durations
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);

    // if no changes
    if (m_itemUpdateQueue.empty())
        return;

    uint32 lowGuid = GetRealGUIDLow();
    for (size_t i = 0; i < m_itemUpdateQueue.size(); ++i)
    {
        Item* item = m_itemUpdateQueue[i];
        if (!item)
            continue;

        Bag* container = item->GetContainer();
        uint32 bag_guid = container ? container->GetRealGUIDLow() : 0;

        if (item->GetState() != ITEM_REMOVED)
        {
            Item* test = GetItemByPos(item->GetBagSlot(), item->GetSlot());
            if (test == NULL)
            {
                uint32 bagTestGUID = 0;
                if (Item* test2 = GetItemByPos(INVENTORY_SLOT_BAG_0, item->GetBagSlot()))
                    bagTestGUID = test2->GetRealGUIDLow();
                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
                // according to the test that was just performed nothing should be in this slot, delete

                trans->PAppend("DELETE FROM character_inventory WHERE bag=%u AND slot=%u AND guid=%u", bagTestGUID, item->GetSlot(), lowGuid);

                // also THIS item should be somewhere else, cheat attempt
                item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
                DeleteRefundReference(item->GetGUIDLow());
                // don't skip, let the switch delete it
                //continue;
            }
            else if (test != item)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u are incorrect, the item with guid %u is there instead!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), test->GetGUIDLow());
                // save all changes to the item...
                if (item->GetState() != ITEM_NEW) // only for existing items, no dupes
                    item->SaveToDB(trans);
                // ...but do not save position in inventory
                continue;
            }
        }

        switch (item->GetState())
        {
            case ITEM_NEW:
            case ITEM_CHANGED:
                trans->PAppend("REPLACE INTO character_inventory (guid, bag, slot, item) VALUES ('%u', '%u', '%u', '%u')", lowGuid, bag_guid, item->GetSlot(), item->GetRealGUIDLow());
                break;
            case ITEM_REMOVED:
                trans->PAppend("DELETE FROM character_inventory WHERE item = '%u'", item->GetRealGUIDLow());
                break;
            case ITEM_UNCHANGED:
                break;
        }

        item->SaveToDB(trans);                                   // item have unchanged inventory record and can be save standalone
    }
    m_itemUpdateQueue.clear();
}

void Player::_SaveVoidStorage(SQLTransaction& trans)
{
    if (!m_VoidStorageLoaded)
        return;

    PreparedStatement* stmt = NULL;
    uint32 lowGuid = GetRealGUIDLow();

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (!_voidStorageItems[i]) // unused item
        {
            // DELETE FROM void_storage WHERE slot = ? AND playerGuid = ?
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM_BY_SLOT);
            stmt->setUInt8(0, i);
            stmt->setUInt32(1, lowGuid);
        }
        else
        {
            // REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
            stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_VOID_STORAGE_ITEM);
            stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
            stmt->setUInt32(1, lowGuid);
            stmt->setUInt32(2, _voidStorageItems[i]->ItemEntry);
            stmt->setUInt8(3, i);
            stmt->setUInt32(4, _voidStorageItems[i]->CreatorGuid);
            stmt->setUInt32(5, _voidStorageItems[i]->ItemRandomPropertyId);
            stmt->setUInt32(6, _voidStorageItems[i]->ItemSuffixFactor);

            std::ostringstream l_Bonuses;

            for (uint32 l_I = 0; l_I < _voidStorageItems[i]->Bonuses.size(); l_I++)
            {
                if (_voidStorageItems[i])
                    l_Bonuses << _voidStorageItems[i]->Bonuses[l_I] << ' ';
            }

            stmt->setString(7, l_Bonuses.str());

        }

        trans->Append(stmt);
    }
}

void Player::_SaveMail(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        Mail* m = (*itr);
        if (m->state == MAIL_STATE_CHANGED)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
            stmt->setUInt32(1, uint32(m->expire_time));
            stmt->setUInt32(2, uint32(m->deliver_time));
            stmt->setUInt64(3, m->money);
            stmt->setUInt64(4, m->COD);
            stmt->setUInt8(5, uint8(m->checked));
            stmt->setUInt32(6, m->messageID);

            trans->Append(stmt);

            if (!m->removedItems.empty())
            {
                for (std::vector<uint32>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
                    stmt->setUInt32(0, *itr2);
                    trans->Append(stmt);
                }
                m->removedItems.clear();
            }
            m->state = MAIL_STATE_UNCHANGED;
        }
        else if (m->state == MAIL_STATE_DELETED)
        {
            if (m->HasItems())
            {
                PreparedStatement* stmt = NULL;
                for (MailItemInfoVec::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                    stmt->setUInt32(0, itr2->item_guid);
                    trans->Append(stmt);
                }
            }
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);
        }
    }

    //deallocate deleted mails...
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end();)
    {
        if ((*itr)->state == MAIL_STATE_DELETED)
        {
            Mail* m = *itr;
            m_mail.erase(itr);
            delete m;
            itr = m_mail.begin();
        }
        else
            ++itr;
    }

    m_mailsUpdated = false;
}

void Player::_SaveQuestStatus(SQLTransaction& trans)
{
    bool isTransaction = trans.get() != nullptr;
    if (!isTransaction)
        trans = RealmDatabase.BeginTransaction();

    QuestStatusSaveMap::iterator saveItr;
    QuestStatusMap::iterator statusItr;
    PreparedStatement* stmt = NULL;

#ifndef CROSS
    bool keepAbandoned = !(sWorld->GetCleaningFlags() & CharacterDatabaseCleaner::CLEANING_FLAG_QUESTSTATUS);
#else /* CROSS */
    bool keepAbandoned = true;
#endif /* CROSS */

    for (saveItr = m_QuestStatusSave.begin(); saveItr != m_QuestStatusSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            statusItr = m_QuestStatus.find(saveItr->first);

            if (sObjectMgr->BonusQuestsRects.find(statusItr->first) != sObjectMgr->BonusQuestsRects.end())
                continue;

            if (statusItr != m_QuestStatus.end() && (keepAbandoned || statusItr->second.Status != QUEST_STATUS_NONE))
            {
                uint8 index = 0;
                stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);
                stmt->setUInt32(index++, GetRealGUIDLow());
                stmt->setUInt32(index++, statusItr->first);
                stmt->setUInt8(index++, uint8(statusItr->second.Status));
                stmt->setBool(index++, statusItr->second.Explored);
                stmt->setUInt32(index++, uint32(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()));

                trans->Append(stmt);
            }
        }
        else
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);

        }
        else if (!keepAbandoned)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    m_RewardedQuestsSave.clear();

    if (!isTransaction)
        CharacterDatabase.CommitTransaction(trans);
}

void Player::_SaveQuestObjectiveStatus(SQLTransaction& trans)
{
    for (QuestObjectiveStatusMap::const_iterator citr = m_questObjectiveStatus.begin(); citr != m_questObjectiveStatus.end(); citr++)
    {
        uint32 questId = sObjectMgr->GetQuestObjectiveQuestId(citr->first);
        if (!questId)
            continue;

        QuestStatusSaveMap::const_iterator citrSave = m_QuestStatusSave.find(questId);
        if (citrSave == m_QuestStatusSave.end())
            continue;

        if (citrSave->second)
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, citr->first);
            stmt->setUInt32(2, citr->second);
            trans->Append(stmt);
        }
        else
        {
            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, citr->first);
            trans->Append(stmt);
        }
    }

    m_QuestStatusSave.clear();
}

void Player::_SaveDailyQuestStatus(SQLTransaction& trans)
{
    if (!m_DailyQuestChanged)
        return;

    m_DailyQuestChanged = false;

    // save last daily quest time for all quests: we need only mostly reset time for reset check anyway

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (auto id : m_dailyQuestStorage)
    {
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, id);
        stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
        trans->Append(stmt);
    }

    if (!m_DFQuests.empty())
    {
        for (DFQuestsDoneList::iterator itr = m_DFQuests.begin(); itr != m_DFQuests.end(); ++itr)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, (*itr));
            stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
            trans->Append(stmt);
        }
    }
}

void Player::_SaveWeeklyQuestStatus(SQLTransaction& trans)
{
    if (!m_WeeklyQuestChanged || m_weeklyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_weeklyquests.begin(); iter != m_weeklyquests.end(); ++iter)
    {
        uint32 quest_id  = *iter;

        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WEEKLYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_WeeklyQuestChanged = false;
}

void Player::_SaveSeasonalQuestStatus(SQLTransaction& trans)
{
    if (!m_SeasonalQuestChanged || m_seasonalquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (SeasonalEventQuestMap::const_iterator iter = m_seasonalquests.begin(); iter != m_seasonalquests.end(); ++iter)
    {
        uint16 event_id = iter->first;
        for (SeasonalQuestSet::const_iterator itr = iter->second.begin(); itr != iter->second.end(); ++itr)
        {
            uint32 quest_id = (*itr);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, quest_id);
            stmt->setUInt32(2, event_id);
            trans->Append(stmt);
        }
    }

    m_SeasonalQuestChanged = false;
}

void Player::_SaveMonthlyQuestStatus(SQLTransaction& trans)
{
    if (!m_MonthlyQuestChanged || m_monthlyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_MONTHLY_CHAR);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_monthlyquests.begin(); iter != m_monthlyquests.end(); ++iter)
    {
        uint32 quest_id = *iter;
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_MONTHLYQUESTSTATUS);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_MonthlyQuestChanged = false;
}

void Player::_SaveSkills(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // we don't need transactions here.
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
    {
        if (itr->second.uState == SKILL_UNCHANGED)
        {
            ++itr;
            continue;
        }

        if (itr->second.uState == SKILL_DELETED)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt32(1, itr->first);
            trans->Append(stmt);

            mSkillStatus.erase(itr++);
            continue;
        }

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1;

        uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset);
        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset);

        switch (itr->second.uState)
        {
            case SKILL_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, uint16(itr->first));
                stmt->setUInt16(2, value);
                stmt->setUInt16(3, max);
                trans->Append(stmt);
                break;
            case SKILL_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
                stmt->setUInt16(0, value);
                stmt->setUInt16(1, max);
                stmt->setUInt32(2, GetRealGUIDLow());
                stmt->setUInt16(3, uint16(itr->first));
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.uState = SKILL_UNCHANGED;
        ++itr;
    }
}

#define SKILL_MOUNT     777
#define SKILL_MINIPET   778

void Player::_SaveSpells(SQLTransaction& charTrans, SQLTransaction& accountTrans)
{
#ifndef CROSS
    uint32 l_GroupRealmMask     = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_GROUP_MASK);
#else
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());
    uint32 l_GroupRealmMask     = l_Config->groupRealmMask;
#endif

    uint32 l_ShopGroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_SHOP_GROUP_MASK);
    PreparedStatement* stmt = NULL;

    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end();)
    {
        if (!itr->second)
            continue;

        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
        {
            if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if (GetSession() && ((spell->IsAbilityOfSkillType(SKILL_MOUNT) && !(spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE))
                    || spell->IsAbilityOfSkillType(SKILL_MINIPET))
                    && sWorld->CanBeSaveInLoginDatabase())
                {
                    /*stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_CHAR_SPELL_BY_SPELL);
                    stmt->setUInt32(0, itr->first);
                    stmt->setUInt32(1, GetSession()->GetAccountId());
                    accountTrans->Append(stmt);*/
                }
                else
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
                    stmt->setUInt32(0, itr->first);
                    stmt->setUInt32(1, GetRealGUIDLow());
                    charTrans->Append(stmt);
                }
            }
        }

        /// add only changed/new not dependent spells
        if (!itr->second->dependent && (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED))
        {
            if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if (GetSession() && ((spell->IsAbilityOfSkillType(SKILL_MOUNT) && ((spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE) == 0))
                    || spell->IsAbilityOfSkillType(SKILL_MINIPET))
                    && sWorld->CanBeSaveInLoginDatabase())
                {
                    stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_CHAR_SPELL);
                    stmt->setUInt32(0, GetSession()->GetAccountId());
                    stmt->setUInt32(1, itr->first);
                    stmt->setBool(2, itr->second->active);
                    stmt->setBool(3, itr->second->disabled);
                    stmt->setBool(4, itr->second->IsMountFavorite);
                    stmt->setUInt32(5, itr->second->FromShopItem ? l_ShopGroupRealmMask : l_GroupRealmMask);
                    stmt->setUInt32(6, itr->second->FromShopItem ? l_ShopGroupRealmMask : l_GroupRealmMask);

                    accountTrans->Append(stmt);
                }
                else
                {
                    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
                    stmt->setUInt32(0, GetRealGUIDLow());
                    stmt->setUInt32(1, itr->first);
                    stmt->setBool(2, itr->second->active);
                    stmt->setBool(3, itr->second->disabled);
                    stmt->setBool(4, itr->second->IsMountFavorite);
                    charTrans->Append(stmt);
                }
            }
        }

        if (itr->second->state == PLAYERSPELL_REMOVED)
        {
            delete itr->second;
            m_spells.erase(itr++);
        }
        else
        {
            itr->second->state = PLAYERSPELL_UNCHANGED;
            ++itr;
        }
    }
}

// save player stats -- only for external usage
// real stats will be recalculated on player login
void Player::_SaveStats(SQLTransaction& trans)
{
    // check if stat saving is enabled and if char level is high enough
    if (!sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE))
        return;

    PreparedStatement* stmt = NULL;

    stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_STATS);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    uint8 index = 0;

    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_STATS);
    stmt->setUInt32(index++, GetRealGUIDLow());
    stmt->setUInt32(index++, GetMaxHealth());

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        stmt->setUInt32(index++, GetMaxPower(Powers(i)));

    for (uint8 i = 0; i < MAX_STATS; ++i)
        stmt->setUInt32(index++, GetStat(Stats(i)));

    for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
        stmt->setUInt32(index++, GetResistance(SpellSchools(i)));

    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_ATTACK_POWER));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER));
    stmt->setUInt32(index++, GetBaseSpellPowerBonus());
    stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + CR_RESILIENCE_PLAYER_DAMAGE_TAKEN));

    trans->Append(stmt);
}

#ifndef CROSS
void Player::_SaveCharacterGarrisonDailyTavernDatas(SQLTransaction& p_Transaction)
{
    MS::Garrison::Manager* l_GarrisonMgr = GetGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GARRISON_DAILY_TAVERN_DATA_CHAR);
    l_Stmt->setUInt32(0, GetGUIDLow());
    p_Transaction->Append(l_Stmt);

    for (uint32 l_TavernData : l_GarrisonMgr->GetGarrisonDailyTavernDatas())
    {
        l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_ADD_GARRISON_DAILY_TAVERN_DATA_CHAR);
        l_Stmt->setUInt32(0, GetGUIDLow());
        l_Stmt->setUInt32(1, l_TavernData);
        p_Transaction->Append(l_Stmt);
    }
}

void Player::_SaveCharacterGarrisonWeeklyTavernDatas(SQLTransaction& p_Transaction)
{
    MS::Garrison::Manager* l_GarrisonMgr = GetGarrison();

    if (l_GarrisonMgr == nullptr)
        return;

    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GARRISON_WEEKLY_TAVERN_DATA_CHAR);
    l_Stmt->setUInt32(0, GetGUIDLow());
    p_Transaction->Append(l_Stmt);

    for (MS::Garrison::WeeklyTavernData l_TavernData : l_GarrisonMgr->GetGarrisonWeeklyTavernDatas())
    {
        l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_ADD_GARRISON_WEEKLY_TAVERN_DATA_CHAR);
        l_Stmt->setUInt32(0, GetGUIDLow());
        l_Stmt->setUInt32(1, l_TavernData.FollowerID);

        std::ostringstream l_Abilities;

        for (uint32 l_Ability : l_TavernData.Abilities)
        {
            if (l_Ability != l_TavernData.Abilities.back())
                l_Abilities << l_Ability << ' ';
            else
                l_Abilities << l_Ability;
        }

        l_Stmt->setString(2, l_Abilities.str());
        p_Transaction->Append(l_Stmt);
    }
}

#endif /* not CROSS */
void Player::outDebugValues() const
{
    if (!sLog->ShouldLog(LOG_FILTER_UNITS, LOG_LEVEL_DEBUG))
        return;

    sLog->outDebug(LOG_FILTER_UNITS, "HP is: \t\t\t%u\t\tMP is: \t\t\t%u", GetMaxHealth(), GetMaxPower(POWER_MANA));
    sLog->outDebug(LOG_FILTER_UNITS, "AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
    sLog->outDebug(LOG_FILTER_UNITS, "INTELLECT is: \t\t%f\t\tSPIRIT is: \t\t%f", GetStat(STAT_INTELLECT), GetStat(STAT_SPIRIT));
    sLog->outDebug(LOG_FILTER_UNITS, "STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
    sLog->outDebug(LOG_FILTER_UNITS, "Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
    sLog->outDebug(LOG_FILTER_UNITS, "NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
    sLog->outDebug(LOG_FILTER_UNITS, "ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MIN_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE));
    sLog->outDebug(LOG_FILTER_UNITS, "ATTACK_TIME is: \t%u\t\tRANGE_ATTACK_TIME is: \t%u", GetAttackTime(WeaponAttackType::BaseAttack), GetAttackTime(WeaponAttackType::RangedAttack));
}

/*********************************************************/
/***               FLOOD FILTER SYSTEM                 ***/
/*********************************************************/
void Player::UpdateSpeakTime()
{
    // ignore chat spam protection for GMs in any mode
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        return;

    time_t current = time (NULL);
    if (m_speakTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_COUNT);
        if (!max_count)
            return;

        ++m_speakCount;
        if (m_speakCount >= max_count)
        {
            // prevent overwrite mute time, if message send just before mutes set, for example.
            time_t new_mute = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MUTE_TIME);
            if (GetSession()->m_muteTime < new_mute)
                GetSession()->m_muteTime = new_mute;

            m_speakCount = 0;
        }
    }
    else
        m_speakCount = 0;

    m_speakTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_DELAY);
}

bool Player::UpdatePmChatTime()
{
    // ignore chat spam protection for GMs in any mode
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        return true;

    time_t current = time (NULL);
    if (m_pmChatTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_PRIVATE_MESSAGE_COUNT);
        if (!max_count)
            return true;

        ++m_pmChatCount;
        if (m_pmChatCount >= max_count)
            return false;
    }
    else
        m_pmChatCount = 0;

    m_pmChatTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_PRIVATE_MESSAGE_DELAY);
    return true;
}

bool Player::CanSpeak() const
{
    return  GetSession()->m_muteTime <= time (NULL);
}

/*********************************************************/
/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
/*********************************************************/
void Player::SavePositionInDB(uint32 mapid, float x, float y, float z, float o, uint32 zone, uint64 guid)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);

    stmt->setFloat(0, x);
    stmt->setFloat(1, y);
    stmt->setFloat(2, z);
    stmt->setFloat(3, o);
    stmt->setUInt16(4, uint16(mapid));
    stmt->setUInt16(5, uint16(zone));
    stmt->setUInt32(6, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
#endif
}

void Player::SetUInt32ValueInArray(Tokenizer& tokens, uint16 index, uint32 /*value*/)
{
    char buf[11];

    if (index >= tokens.size())
        return;

    tokens[index] = buf;
}

void Player::Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair)
{
#ifndef CROSS
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PLAYERBYTES2);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return;

    Field* fields = result->Fetch();

    uint32 playerBytes2 = fields[0].GetUInt32();
    playerBytes2 &= ~0xFF;
    playerBytes2 |= facialHair;

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);

    stmt->setUInt8(0, gender);
    stmt->setUInt32(1, skin | (face << 8) | (hairStyle << 16) | (hairColor << 24));
    stmt->setUInt32(2, playerBytes2);
    stmt->setUInt32(3, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
#endif
}

void Player::SendAttackSwingError(AttackSwingError p_Error)
{
    WorldPacket l_Data(SMSG_ATTACK_SWING_ERROR, 1);
    l_Data.WriteBits(p_Error, 2);
    l_Data.FlushBits();

    GetSession()->SendPacket(&l_Data);
}

void Player::SendAttackSwingCancelAttack()
{
    WorldPacket data(SMSG_CANCEL_COMBAT, 0);
    GetSession()->SendPacket(&data);
}

void Player::SendAutoRepeatCancel(Unit* p_Target)
{
    WorldPacket l_Data(SMSG_CANCEL_AUTO_REPEAT);
    l_Data.appendPackGUID(p_Target->GetGUID());
    GetSession()->SendPacket(&l_Data);
}

void Player::SendExplorationExperience(uint32 Area, uint32 Experience)
{
    WorldPacket data(SMSG_EXPLORATION_EXPERIENCE, 8);
    data << uint32(Area);
    data << uint32(Experience);
    GetSession()->SendPacket(&data);
}

void Player::SendDungeonDifficulty(int32 p_ForcedDifficulty /*= -1*/)
{
    WorldPacket data(SMSG_SET_DUNGEON_DIFFICULTY, 4);
    data << uint32(p_ForcedDifficulty == -1 ? GetDungeonDifficultyID() : p_ForcedDifficulty);
    GetSession()->SendPacket(&data);
}

void Player::SendRaidDifficulty(bool p_Legacy, int32 forcedDifficulty)
{
    WorldPacket data(SMSG_SET_RAID_DIFFICULTY, 4 + 1);
    data << uint32(forcedDifficulty == -1 ? (p_Legacy ? GetLegacyRaidDifficultyID () : GetRaidDifficultyID()) : forcedDifficulty);
    data << uint8(p_Legacy);
    GetSession()->SendPacket(&data);
}

void Player::SendResetFailedNotify()
{
    WorldPacket data(SMSG_RESET_FAILED_NOTIFY);
    GetSession()->SendPacket(&data);
}

/// Reset all solo instances and optionally send a message on success for each
void Player::ResetInstances(uint8 method, bool isRaid, bool isLegacy)
{
    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN

    // we assume that when the difficulty changes, all instances that can be reset will be
    Difficulty diff = GetDungeonDifficultyID();
    if (isRaid)
    {
        if (!isLegacy)
            diff = GetRaidDifficultyID();
        else
            diff = GetLegacyRaidDifficultyID();
    }

    for (BoundInstancesMap::iterator itr = m_boundInstances[diff].begin(); itr != m_boundInstances[diff].end();)
    {
        InstanceSave* p = itr->second.save;
        const MapEntry* entry = sMapStore.LookupEntry(itr->first);
        if (!entry || entry->IsRaid() != isRaid || !p->CanReset())
        {
            ++itr;
            continue;
        }

        if (method == INSTANCE_RESET_ALL)
        {
            // the "reset all instances" method can only reset normal maps
            if (entry->instanceType == MAP_RAID || diff == DifficultyRaidHeroic)
            {
                ++itr;
                continue;
            }
        }

        // if the map is loaded, reset it
        Map* map = sMapMgr->FindMap(p->GetMapId(), p->GetInstanceId());
        if (map && map->IsDungeon())
            if (!((InstanceMap*)map)->Reset(method))
            {
                ++itr;
                continue;
            }

        // since this is a solo instance there should not be any players inside
        if (method == INSTANCE_RESET_ALL || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
            SendResetInstanceSuccess(p->GetMapId());

        p->DeleteFromDB();
        m_boundInstances[diff].erase(itr++);

        // the following should remove the instance save from the manager and delete it as well
        p->RemovePlayer(this);
    }
}

void Player::SendResetInstanceSuccess(uint32 p_MapID)
{
    WorldPacket data(SMSG_INSTANCE_RESET, 4);
    data << uint32(p_MapID);
    GetSession()->SendPacket(&data);
}

void Player::SendResetInstanceFailed(ResetFailedReason p_Reason, uint32 p_MapID)
{
    /*reasons for instance reset failure:
    // 0: There are players inside the instance.
    // 1: There are players offline in your party.
    // 2>: There are players in your party attempting to zone into an instance.
    */
    WorldPacket data(SMSG_INSTANCE_RESET_FAILED);
    data << uint32(p_MapID);
    data.WriteBits(p_Reason, 2);
    GetSession()->SendPacket(&data);
}

/*********************************************************/
/***              Update timers                        ***/
/*********************************************************/
///checks the 15 afk reports per 5 minutes limit
void Player::UpdateAfkReport(time_t currTime)
{
    if (m_bgData.bgAfkReportedTimer <= currTime)
    {
        m_bgData.bgAfkReportedCount = 0;
        m_bgData.bgAfkReportedTimer = currTime+5*MINUTE;
    }
}

void Player::UpdateContestedPvP(uint32 diff)
{
    if (!m_contestedPvPTimer||isInCombat())
        return;
    if (m_contestedPvPTimer <= diff)
    {
        ResetContestedPvP();
    }
    else
        m_contestedPvPTimer -= diff;
}

void Player::UpdatePvPFlag(time_t currTime)
{
    if (!IsPvP() || InBattleground() || InArena())
        return;
    if (pvpInfo.endTimer == 0 || currTime < (pvpInfo.endTimer + 300) || pvpInfo.inHostileArea)
        return;

    UpdatePvP(false);
}

void Player::UpdateDuelFlag(time_t currTime)
{
    if (!m_Duel || m_Duel->startTimer == 0 ||currTime < m_Duel->startTimer + 3)
        return;

    sScriptMgr->OnPlayerDuelStart(this, m_Duel->opponent);

    if (sWorld->getBoolConfig(CONFIG_FUN_ENABLE))
    {
        RemoveAllSpellCooldown();
        if (m_Duel->opponent != nullptr)
            m_Duel->opponent->RemoveAllSpellCooldown();
    }

    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 1);
    m_Duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 2);

    // cleanup combo points
    ClearComboPoints();
    m_Duel->opponent->ClearComboPoints();

    m_Duel->startTimer = 0;
    m_Duel->startTime  = currTime;
    m_Duel->started    = true;
    m_Duel->opponent->m_Duel->startTimer = 0;
    m_Duel->opponent->m_Duel->startTime  = currTime;
    m_Duel->opponent->m_Duel->started    = true;
}

Pet* Player::GetPet() const
{
    if (uint64 pet_guid = GetPetGUID())
    {
        if (!IS_PET_GUID(pet_guid))
            return NULL;

        Pet* pet = ObjectAccessor::GetPet(*this, pet_guid);

        if (!pet)
            return NULL;

        if (IsInWorld() && pet)
            return pet;

        //there may be a guardian in slot
        //sLog->outError(LOG_FILTER_PLAYER, "Player::GetPet: Pet %u not exist.", GUID_LOPART(pet_guid));
        //const_cast<Player*>(this)->SetPetGUID(0);
    }

    return NULL;
}

void Player::RemovePet(Pet* pet, PetSlot mode, bool returnreagent, bool stampeded)
{
    if (!pet)
        pet = GetPet();

    if (pet)
    {
        sLog->outDebug(LOG_FILTER_PETS, "RemovePet %u, %u, %u", pet->GetEntry(), mode, returnreagent);

        if (pet->m_removed)
            return;
    }

    if (!pet || pet->GetOwnerGUID() != GetGUID())
        return;

    if (mode == PET_SLOT_ACTUAL_PET_SLOT)
        mode = PetSlot(pet->GetSlot());

    pet->CombatStop();
    // only if current pet in slot
    pet->SavePetToDB(mode, stampeded);

    if (pet->getPetType() != HUNTER_PET)
        SetMinion(pet, false, PET_SLOT_UNK_SLOT, stampeded);
    else
        SetMinion(pet, false, PET_SLOT_ACTUAL_PET_SLOT, stampeded);

    pet->AddObjectToRemoveList();
    pet->m_removed = true;

    if (pet->isControlled() && !stampeded)
    {
        SendRemoveControlBar();
        if (GetGroup())
            SetGroupUpdateFlag(GROUP_UPDATE_PET);
    }

    // Spirit Bond
    if (HasSpell(109212) && HasAura(118694))
        RemoveAura(118694);

    // Kindred Spirits
    if (HasAura(56315))
        pet->RemoveAura(56315);

    // Soul Link
    if (Unit* owner = pet->GetOwner())
    {
        if (owner->IsPlayer() && owner->ToPlayer()->HasSpell(108415))
        {
            owner->RemoveAura(108446);
            pet->RemoveAura(108446);
        }
    }
}

void Player::StopCastingCharm()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    if (charm->GetTypeId() == TYPEID_UNIT)
    {
        if (charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET))
            ((Puppet*)charm)->UnSummon();
#ifndef CROSS
        else if (charm->IsVehicle())
            ExitVehicle();
#endif
    }

#ifdef CROSS
    if (charm->IsVehicle())
    {
        /// Prevent exit vehicle at map switch
        if (GetMapSwitchDestination() != -1 && charm->GetTypeId() == TYPEID_UNIT)
        {
            Map* l_NewMap = sMapMgr->CreateMap(GetMapSwitchDestination(), this);

            if (l_NewMap && l_NewMap->CanEnter(this))
            {
                charm->SetMapSwitchDestination(GetMapSwitchDestination());
                charm->ToCreature()->SetLockAI(true);
                charm->ToCreature()->FarTeleportTo(l_NewMap, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                charm->ToCreature()->SetLockAI(false);
                charm->SetMapSwitchDestination(-1);

                return;
            }
        }

        ExitVehicle();
    }
#endif

    if (GetCharmGUID())
        charm->RemoveCharmAuras();

    if (GetCharmGUID())
    {
        sLog->outFatal(LOG_FILTER_PLAYER, "Player %s (GUID: " UI64FMTD " is not able to uncharm unit (GUID: " UI64FMTD " Entry: %u, Type: %u)", GetName(), GetGUID(), GetCharmGUID(), charm->GetEntry(), charm->GetTypeId());
        if (charm->GetCharmerGUID())
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Charmed unit has charmer guid " UI64FMTD, charm->GetCharmerGUID());
            ASSERT(false);
        }
        else
            SetCharm(charm, false);
    }
}

void Player::BuildPlayerChat(WorldPacket* p_Data, uint64 p_TargetGuid, uint8 p_MsgType, std::string const& p_Text, uint32 p_LangID, char const* p_AddonPrefix /*= nullptr*/, std::string const& p_Channel /*= ""*/) const
{
    uint32 l_SenderNameLen = strlen(GetName());
    uint64 l_GuildGuid = const_cast<Player*>(this)->GetGuild() ? const_cast<Player*>(this)->GetGuild()->GetGUID() : 0;

    p_Data->Initialize(SMSG_CHAT, 800);
    *p_Data << uint8(p_MsgType);
    *p_Data << uint8(p_LangID);
    p_Data->appendPackGUID(GetGUID());
    p_Data->appendPackGUID(l_GuildGuid);
    p_Data->appendPackGUID(0);
    p_Data->appendPackGUID(p_TargetGuid);
    *p_Data << uint32(g_RealmID);
    *p_Data << uint32(g_RealmID);
    p_Data->appendPackGUID(GetGroup() ? GetGroup()->GetGUID() : 0);
    *p_Data << uint32(0);     ///< AchievementID
    *p_Data << float(0);      ///< DisplayTime

    p_Data->WriteBits(l_SenderNameLen, 11);
    p_Data->WriteBits(0, 11); ///< TargetNameLen
    p_Data->WriteBits(p_AddonPrefix ? strlen(p_AddonPrefix) : 0, 5);
    p_Data->WriteBits(p_Channel.length(), 7);
    p_Data->WriteBits(p_Text.length(), 12);
    p_Data->WriteBits(GetChatTag(), 11);
    p_Data->WriteBit(false);  ///< hide chat log
    p_Data->WriteBit(false);  ///< Faker sender name
    p_Data->FlushBits();

    p_Data->WriteString(GetName());
    p_Data->WriteString(p_AddonPrefix ? p_AddonPrefix : "");
    p_Data->WriteString(p_Channel);
    p_Data->WriteString(p_Text);
}

void Player::Say(std::string const& p_Text, uint32 const p_LangID)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, p_LangID, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (PlayerSocial* l_Social = l_Target->GetSocial())
        {
            if (l_Social->HasIgnore(GUID_LOPART(GetGUID())))
                continue;
        }

        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_SAY, l_Text, p_LangID);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::Yell(std::string const& p_Text, uint32 const p_LangID)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_YELL, p_LangID, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_YELL, l_Text, p_LangID);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::TextEmote(std::string const& p_Text)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_EMOTE, LANG_UNIVERSAL, l_Text);

    std::list<Player*> l_PlayerList;
    GetPlayerListInGrid(l_PlayerList, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE), true);

    for (Player* l_Target : l_PlayerList)
    {
        if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT) && l_Target->GetTeamId() != GetTeamId() && !l_Target->isGameMaster())
            continue;

        if (WorldSession* l_Session = l_Target->GetSession())
        {
            WorldPacket l_Data;
            /// No specific target needed
            BuildPlayerChat(&l_Data, 0, CHAT_MSG_EMOTE, l_Text, LANG_UNIVERSAL);
            l_Session->SendPacket(&l_Data);
        }
    }
}

void Player::WhisperAddon(std::string const& p_Text, std::string const& p_Prefix, Player* p_Receiver)
{
    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, LANG_UNIVERSAL, l_Text, p_Receiver);

    if (!p_Receiver->GetSession()->IsAddonRegistered(p_Prefix))
        return;

    WorldPacket l_Data;
    BuildPlayerChat(&l_Data, 0, CHAT_MSG_WHISPER, l_Text, LANG_ADDON, p_Prefix.c_str());
    p_Receiver->GetSession()->SendPacket(&l_Data);
}

void Player::Whisper(std::string const& p_Text, uint32 p_LangID, uint64 p_Receiver)
{
#ifndef CROSS
    Player* l_Target = ObjectAccessor::FindPlayerInOrOutOfWorld(p_Receiver);
#else /* CROSS */
    Player* l_Target = ObjectAccessor::FindPlayer(p_Receiver);
#endif /* CROSS */
    if (l_Target == nullptr)
        return;

    std::string l_Text(p_Text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, p_LangID, l_Text, l_Target);

#ifndef CROSS
    if (l_Target->GetSocial()->HasIgnore(GetGUIDLow()))
#else /* CROSS */
    if (l_Target->GetSocial() && l_Target->GetSocial()->HasIgnore(GetGUIDLow()))
#endif /* CROSS */
    {
        WorldPacket l_Data;
        ChatHandler::FillMessageData(&l_Data, GetSession(), CHAT_MSG_IGNORED, LANG_UNIVERSAL, NULL, GetGUID(), GetName(), NULL);
        GetSession()->SendPacket(&l_Data);
        return;
    }

    /// When player you are whispering to is dnd, he cannot receive your message, unless you are in gm mode
    if (!l_Target->isDND() || isGameMaster())
    {
        WorldPacket l_Data;
        BuildPlayerChat(&l_Data, l_Target->GetGUID(), CHAT_MSG_WHISPER, l_Text, p_LangID);
        l_Target->GetSession()->SendPacket(&l_Data);

        l_Target->BuildPlayerChat(&l_Data, GetGUID(), CHAT_MSG_WHISPER_INFORM, l_Text, p_LangID);
        GetSession()->SendPacket(&l_Data);
    }
    else ///< Announce to player that player he is whispering to is dnd and cannot receive his message
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_DND, l_Target->GetName(), l_Target->dndMsg.c_str());

    if (!IsAcceptWhispers() && !isGameMaster() && !l_Target->isGameMaster())
    {
        SetAcceptWhispers(true);
        ChatHandler(this).SendSysMessage(LANG_COMMAND_WHISPERON);
    }

    /// Announce to player that player he is whispering to is afk
    if (l_Target->isAFK())
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_AFK, l_Target->GetName(), l_Target->afkMsg.c_str());

    /// If player whisper someone, auto turn of dnd to be able to receive an answer
    if (isDND() && !l_Target->isGameMaster())
        ToggleDND();
}

void Player::PetSpellInitialize()
{
    Pet* l_Pet = GetPet();
    if (!l_Pet)
        return;

    CharmInfo* l_CharmInfo = l_Pet->GetCharmInfo();

    uint32 l_ActionCount = 0;
    if (l_Pet->IsPermanentPetFor(this))
    {
        for (PetSpellMap::iterator l_Itr = l_Pet->m_spells.begin(); l_Itr != l_Pet->m_spells.end(); ++l_Itr)
        {
            if (l_Itr->second.state != PETSPELL_REMOVED)
                ++l_ActionCount;
        }
    }

    uint32 l_CooldownCount        = l_Pet->m_CreatureSpellCooldowns.size();
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = l_Pet->GetDuration();
    uint32 l_PetModeAndOrders     = l_Pet->GetReactState() | l_CharmInfo->GetCommandState() << 8 | 0 << 16;     // PetModeAndOrders have : React state, Command State & flags
    uint16 l_CreatureFamily       = l_Pet->GetCreatureTemplate()->family;
    uint16 l_Specialization       = l_Pet->GetSpecializationId();
    ObjectGuid l_PetGUID          = l_Pet->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint32(l_PetModeAndOrders);       ///< PetModeAndOrders

    // action bar loop
    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    if (l_Pet->IsPermanentPetFor(this))
    {
        for (PetSpellMap::iterator itr = l_Pet->m_spells.begin(); itr != l_Pet->m_spells.end(); ++itr)
        {
            if (itr->second.state == PETSPELL_REMOVED)
                continue;

            l_Data << uint32(MAKE_UNIT_ACTION_BUTTON(itr->first, itr->second.active));  ///< Actions
        }
    }

    time_t l_Now = sWorld->GetGameTime();
    for (CreatureSpellCooldowns::const_iterator l_Itr = l_Pet->m_CreatureSpellCooldowns.begin(); l_Itr != l_Pet->m_CreatureSpellCooldowns.end(); ++l_Itr)
    {
        uint32 l_SpellID          = 0;
        uint32 l_Duration         = 0;
        uint32 l_CategoryDuration = 0;
        uint16 l_Category         = 0;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        if (l_SpellInfo != nullptr)
        {
            l_Duration = (l_Itr->second > l_Now) ? (l_Itr->second - l_Now) * IN_MILLISECONDS : 0;
            l_SpellID = l_Itr->second;

            CreatureSpellCooldowns::const_iterator l_CategoryItr = l_Pet->m_CreatureCategoryCooldowns.find(l_SpellInfo->GetCategory());
            if (l_CategoryItr != l_Pet->m_CreatureCategoryCooldowns.end())
            {
                l_Category         = l_SpellInfo->GetCategory();
                l_CategoryDuration = (l_CategoryItr->second > l_Now) ? (l_CategoryItr->second - l_Now) * IN_MILLISECONDS : 0;
            }
        }

        l_Data << uint32(l_SpellID);
        l_Data << uint32(l_Duration);
        l_Data << uint32(l_CategoryDuration);
        l_Data << uint16(l_Category);
    }

    //for (uint32 l_I = 0; l_I < l_PetSpellHistoryCount; ++l_I)
    //{
    //    l_Data << int32(l_PetSpellHistory[l_I].CategoryID);
    //    l_Data << int32(l_PetSpellHistory[l_I].RecoveryTime);
    //    l_Data << int32(l_PetSpellHistory[l_I].ConsumedCharges);
    //}

    GetSession()->SendPacket(&l_Data);
}

void Player::PossessSpellInitialize()
{
    Unit* l_Charm = GetCharm();
    if (!l_Charm)
        return;

    CharmInfo* l_CharmInfo = l_Charm->GetCharmInfo();
    if (!l_CharmInfo)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::PossessSpellInitialize(): charm (" UI64FMTD ") has no charminfo!", l_Charm->GetGUID());
        return;
    }

    uint32 l_CooldownCount        = 0;
    uint32 l_ActionCount          = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = 0;
    uint32 l_PetModeAndOrders     = 0;
    uint16 l_CreatureFamily       = 0;
    uint16 l_Specialization       = 0;
    ObjectGuid l_PetGUID          = l_Charm->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint32(l_PetModeAndOrders);       ///< PetModeAndOrders

    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    GetSession()->SendPacket(&l_Data);
}

void Player::VehicleSpellInitialize()
{
    Creature* l_Vehicle = GetVehicleCreatureBase();
    if (!l_Vehicle)
        return;

    uint32 l_CooldownCount        = l_Vehicle->m_CreatureSpellCooldowns.size();
    uint32 l_ActionCount          = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = l_Vehicle->isSummon() ? l_Vehicle->ToTempSummon()->GetTimer() : 0;
    uint32 l_PetModeAndOrders     = l_Vehicle->GetReactState() | 0 << 8 | 0x800 << 16;                  // PetModeAndOrders have : React state, Command State & DisableActions
    uint16 l_CreatureFamily       = l_Vehicle->GetCreatureTemplate()->family;
    uint16 l_Specialization       = 0;                                                                  // I think it's useless in case of vehicle action bar
    ObjectGuid l_PetGUID          = l_Vehicle->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint32(l_PetModeAndOrders);       ///< PetModeAndOrders

    for (uint32 l_I = 0; l_I < CREATURE_MAX_SPELLS; ++l_I)
    {
        uint32 l_SpellId = l_Vehicle->m_spells[l_I];
        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_SpellId);
        if (!l_SpellInfo)
        {
            l_Data << uint16(0) << uint8(0) << uint8(l_I + 8);
            continue;
        }

        if (!sConditionMgr->IsObjectMeetingVehicleSpellConditions(l_Vehicle->GetEntry(), l_SpellId, this, l_Vehicle))
        {
            sLog->outDebug(LOG_FILTER_CONDITIONSYS, "VehicleSpellInitialize: conditions not met for Vehicle entry %u spell %u", l_Vehicle->ToCreature()->GetEntry(), l_SpellId);
            l_Data << uint16(0) << uint8(0) << uint8(l_I + 8);
            continue;
        }

        if (l_SpellInfo->IsPassive())
            l_Vehicle->CastSpell(l_Vehicle, l_SpellId, true);

        l_Data << uint32(MAKE_UNIT_ACTION_BUTTON(l_SpellId, l_I + 8));
    }

    for (uint32 l_I = CREATURE_MAX_SPELLS; l_I < MAX_SPELL_CONTROL_BAR; ++l_I)
        l_Data << uint32(0);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    //for (uint32 l_I = 0; l_I < l_ActionCount; ++l_ActionCount)
    //    l_Data << (l_Action[l_I]);

    time_t l_Now = sWorld->GetGameTime();
    for (CreatureSpellCooldowns::const_iterator l_Itr = l_Vehicle->m_CreatureSpellCooldowns.begin(); l_Itr != l_Vehicle->m_CreatureSpellCooldowns.end(); ++l_Itr)
    {
        uint32 l_SpellID          = 0;
        uint32 l_Duration         = 0;
        uint32 l_CategoryDuration = 0;
        uint16 l_Category         = 0;

        SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Itr->first);
        if (l_SpellInfo != nullptr)
        {
            l_Duration = (l_Itr->second > l_Now) ? (l_Itr->second - l_Now) * IN_MILLISECONDS : 0;
            l_SpellID = l_Itr->second;

            CreatureSpellCooldowns::const_iterator l_CategoryItr = l_Vehicle->m_CreatureCategoryCooldowns.find(l_SpellInfo->GetCategory());
            if (l_CategoryItr != l_Vehicle->m_CreatureCategoryCooldowns.end())
            {
                l_Category         = l_SpellInfo->GetCategory();
                l_CategoryDuration = (l_CategoryItr->second > l_Now) ? (l_CategoryItr->second - l_Now) * IN_MILLISECONDS : 0;
            }
        }

        l_Data << uint32(l_SpellID);
        l_Data << uint32(l_Duration);
        l_Data << uint32(l_CategoryDuration);
        l_Data << uint16(l_Category);
    }

    //for (uint32 l_I = 0; l_I < l_PetSpellHistoryCount; ++l_I)
    //{
    //    l_Data << int32(l_PetSpellHistory[l_I].CategoryID);
    //    l_Data << int32(l_PetSpellHistory[l_I].RecoveryTime);
    //    l_Data << int32(l_PetSpellHistory[l_I].ConsumedCharges);
    //}

    GetSession()->SendPacket(&l_Data);
}

void Player::CharmSpellInitialize()
{
    Unit* l_Charm = GetFirstControlled();
    if (!l_Charm)
        return;

    CharmInfo* l_CharmInfo = l_Charm->GetCharmInfo();
    if (!l_CharmInfo)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::CharmSpellInitialize(): the player's charm (" UI64FMTD ") has no charminfo!", l_Charm->GetGUID());
        return;
    }

    uint32 l_ActionCount = 0;
    if (l_Charm->GetTypeId() != TYPEID_PLAYER)
    {
        for (uint32 l_I = 0; l_I < MAX_SPELL_CHARM; ++l_I)
        {
            if (l_CharmInfo->GetCharmSpell(l_I)->GetAction())
            {
                SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_CharmInfo->GetCharmSpell(l_I)->packedData & 0x00FFFFFF);
                if (l_SpellInfo && !l_SpellInfo->CannotBeAddedToCharm())
                    continue;

                ++l_ActionCount;
            }
        }
    }

    uint32 l_PetModeAndOrders = 0;
    if (l_Charm->GetTypeId() != TYPEID_PLAYER)
        l_PetModeAndOrders = uint8(l_Charm->ToCreature()->GetReactState()) | uint8(l_CharmInfo->GetCommandState()) << 8 | 0 << 16;  // PetModeAndOrders have : React state, Command State & flags

    uint32 l_CooldownCount        = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit            = 0;
    uint16 l_CreatureFamily       = 0;
    uint16 l_Specialization       = 0;
    ObjectGuid l_PetGUID          = l_Charm->GetGUID();

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint32(l_PetModeAndOrders);       ///< PetModeAndOrders

    // action bar loop
    l_CharmInfo->BuildActionBar(&l_Data);

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    if (l_ActionCount)
    {
        for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
        {
            CharmSpellInfo* l_CSpell = l_CharmInfo->GetCharmSpell(i);
            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_CSpell->packedData & 0x00FFFFFF);
            if (l_SpellInfo && !l_SpellInfo->CannotBeAddedToCharm())
                continue;

            if (l_CSpell->GetAction())
                l_Data << uint32(l_CSpell->packedData);
        }
    }

    //for (uint32 l_I = 0; l_I < l_CooldownCount; l_I++)
    //{
    //    l_Data << uint32(l_PetSpellCooldown[l_I].SpellID);
    //    l_Data << uint32(l_PetSpellCooldown[l_I].Duration);
    //    l_Data << uint32(l_PetSpellCooldown[l_I].CategoryDuration);
    //    l_Data << uint16(l_PetSpellCooldown[l_I].Category);
    //}

    //for (uint32 l_I = 0; l_I < l_PetSpellHistoryCount; ++l_I)
    //{
    //    l_Data << int32(l_PetSpellHistory[l_I].CategoryID);
    //    l_Data << int32(l_PetSpellHistory[l_I].RecoveryTime);
    //    l_Data << int32(l_PetSpellHistory[l_I].ConsumedCharges);
    //}

    GetSession()->SendPacket(&l_Data);
}

void Player::SendRemoveControlBar()
{
    uint32 l_CooldownCount = 0;
    uint32 l_ActionCount = 0;
    uint32 l_PetSpellHistoryCount = 0;
    uint32 l_TimeLimit = 0;
    uint32 l_PetModeAndOrders = 0;
    uint16 l_CreatureFamily = CREATURE_FAMILY_NONE;
    uint16 l_Specialization = 0;
    ObjectGuid l_PetGUID = 0;

    WorldPacket l_Data(SMSG_PET_SPELLS_MESSAGE, 500);
    l_Data.appendPackGUID(l_PetGUID);           ///< PetGUID
    l_Data << uint16(l_CreatureFamily);         ///< CreatureFamily
    l_Data << uint16(l_Specialization);         ///< Specialization
    l_Data << uint32(l_TimeLimit);              ///< TimeLimit
    l_Data << uint32(l_PetModeAndOrders);       ///< PetModeAndOrders

    for (int l_I = 0; l_I < 10; l_I++)
        l_Data << uint32(0);                    ///< ActionButtons[l_I]

    l_Data << uint32(l_ActionCount);
    l_Data << uint32(l_CooldownCount);
    l_Data << uint32(l_PetSpellHistoryCount);

    GetSession()->SendPacket(&l_Data);
}

bool Player::IsAffectedBySpellmod(SpellInfo const* spellInfo, SpellModifier* mod, Spell* spell)
{
    if (!mod || !spellInfo)
        return false;

    // Mod out of charges
    if (spell && mod->charges == -1 && spell->m_appliedMods.find((Aura*)mod->ownerAura) == spell->m_appliedMods.end())
        return false;

    // +duration to infinite duration spells making them limited
    if (mod->op == SPELLMOD_DURATION && spellInfo->GetDuration() == -1)
        return false;

    return spellInfo->IsAffectedBySpellMod(mod);
}

void Player::AddSpellMod(SpellModifier* p_Modifier, bool p_Apply)
{
    Opcodes l_Opcode = Opcodes((p_Modifier->type == SPELLMOD_FLAT) ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);

    flag128 l_Mask = 0;
    uint32 l_ModifierTypeCount = 0; // count of mods per one mod->op
    uint32 l_MaskIndex = 0;

    WorldPacket l_Packet(l_Opcode);
    ByteBuffer l_Buffer;

    for (int l_EffectIndex = 0; l_EffectIndex < 128; ++l_EffectIndex)
    {
        if (l_EffectIndex != 0 && (l_EffectIndex % 32) == 0)
            l_Mask[l_MaskIndex++] = 0;

        l_Mask[l_MaskIndex] = uint32(1) << (l_EffectIndex - (32 * l_MaskIndex));

        if (p_Modifier->mask & l_Mask)
        {
            float l_Value = p_Modifier->type == SPELLMOD_FLAT ? 0.0f : 1.0f;

            if (p_Modifier->type == SPELLMOD_FLAT)
            {
                for (SpellModList::iterator l_It = m_spellMods[p_Modifier->op].begin(); l_It != m_spellMods[p_Modifier->op].end(); ++l_It)
                    if ((*l_It)->type == p_Modifier->type && (*l_It)->mask & l_Mask)
                        l_Value += float((*l_It)->value);

                l_Value += p_Apply ? float(p_Modifier->value) : float(-p_Modifier->value);
            }
            else
            {
                for (SpellModList::iterator l_It = m_spellMods[p_Modifier->op].begin(); l_It != m_spellMods[p_Modifier->op].end(); ++l_It)
                    if ((*l_It)->type == p_Modifier->type && (*l_It)->mask & l_Mask && (p_Apply || (!p_Apply && p_Modifier != *l_It)))
                        AddPct(l_Value, (*l_It)->value);

                if (p_Apply)
                    AddPct(l_Value, p_Modifier->value);
            }

            l_Buffer << float(l_Value);
            l_Buffer << uint8(l_EffectIndex);

            ++l_ModifierTypeCount;
        }
    }

    l_Packet << uint32(1);
    l_Packet << uint8(p_Modifier->op);
    l_Packet << uint32(l_ModifierTypeCount);
    l_Packet.append(l_Buffer);

    SendDirectMessage(&l_Packet);

    if (p_Apply)
        m_spellMods[p_Modifier->op].push_back(p_Modifier);
    else
    {
        m_spellMods[p_Modifier->op].remove(p_Modifier);

        // mods bound to aura will be removed in AuraEffect::~AuraEffect
        if (!p_Modifier->ownerAura)
            delete p_Modifier;
    }
}

// Restore spellmods in case of failed cast
void Player::RestoreSpellMods(Spell* spell, uint32 ownerAuraId, Aura* aura)
{
    if (!spell || spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end(); ++itr)
        {
            SpellModifier* mod = *itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges())
                continue;

            // Restore only specific owner aura mods
            if (ownerAuraId && (ownerAuraId != mod->ownerAura->GetSpellInfo()->Id))
                continue;

            if (aura && mod->ownerAura != aura)
                continue;

            // check if mod affected this spell
            // first, check if the mod aura applied at least one spellmod to this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find((Aura*)mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;
            // secondly, check if the current mod is one of the spellmods applied by the mod aura
            if (!(mod->mask & spell->m_spellInfo->SpellFamilyFlags))
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            // add mod charges back to mod
            if (mod->charges == -1)
                mod->charges = 1;
            else
                mod->charges++;

            // Do not set more spellmods than avalible
            if (mod->ownerAura->GetCharges() < mod->charges)
                mod->charges = mod->ownerAura->GetCharges();

            // Skip this check for now - aura charges may change due to various reason
            // TODO: trac these changes correctly
            //ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
        }
    }
}

void Player::RestoreAllSpellMods(uint32 ownerAuraId, Aura* aura)
{
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (m_currentSpells[i])
            RestoreSpellMods(m_currentSpells[i], ownerAuraId, aura);
}

void Player::RemoveSpellMods(Spell* spell)
{
    if (!spell)
        return;

    // Hack fix for Blizzard with Ice Floes
    if (spell->GetSpellInfo()->Id == 10 && spell->GetCaster())
    {
        if (Aura* l_IceFLoes = spell->GetCaster()->GetAura(108839))
            l_IceFLoes->DropCharge();
    }

    if (spell->m_appliedMods.empty())
        return;

    // Hack fix for "double proc" for pyroblast! + Presence of Mind
    bool magePyroblast = false;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::const_iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end();)
        {
            SpellModifier* mod = *itr;
            ++itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges())
                continue;

            // check if mod affected this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find((Aura*)mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            if (mod->ownerAura->GetId() == 48108)
                magePyroblast = true;
            else if (mod->ownerAura->GetId() == 12043 && magePyroblast)
                continue;

            /// Camouflage and Camouflage (Subterfuge) have spellModifier with value 0, add specific case
            if (!(mod->ownerAura->GetId() == 117828 && spell->GetSpellInfo()->Id == 116858) && mod->ownerAura->GetId() != 1784 && mod->ownerAura->GetId() != 115191)
                if (((Aura*)mod->ownerAura)->DropCharge(AURA_REMOVE_BY_EXPIRE))
                    itr = m_spellMods[i].begin();
        }
    }
}

void Player::DropModCharge(SpellModifier* mod, Spell* spell)
{
    // don't handle spells with proc_event entry defined
    // this is a temporary workaround, because all spellmods should be handled like that
    if (sSpellMgr->GetSpellProcEvent(mod->spellId))
        return;

    if (spell && mod->ownerAura && mod->charges > 0)
    {
        if (--mod->charges == 0)
            mod->charges = -1;

        spell->m_appliedMods.insert((Aura*)mod->ownerAura);
    }
}

void Player::SetSpellModTakingSpell(Spell* spell, bool apply)
{
    if (!spell || (m_spellModTakingSpell && m_spellModTakingSpell != spell))
        return;

    if (apply && spell->getState() == SPELL_STATE_FINISHED)
        return;

    m_spellModTakingSpell = apply ? spell : NULL;
}

// send Proficiency
void Player::SendProficiency(ItemClass itemClass, uint32 itemSubclassMask)
{
    WorldPacket data(SMSG_SET_PROFICIENCY, 1 + 4);
    data << uint32(itemSubclassMask) << uint8(itemClass);
    GetSession()->SendPacket(&data);
}

void Player::RemovePetitionsAndSigns(uint64 guid, uint32 type)
{
#ifndef CROSS
    PreparedStatement* stmt;

    if (type == 10)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE);
        stmt->setUInt8(1, uint8(type));
    }

    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
        do                                                  // this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
        {                                                   // and SendPetitionQueryOpcode reads data from the DB
            Field* fields = result->Fetch();
            uint64 ownerguid   = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
            uint64 petitionguid = MAKE_NEW_GUID(fields[1].GetUInt32(), 0, HIGHGUID_ITEM);

            // send update if charter owner in game
            Player* owner = ObjectAccessor::FindPlayer(ownerguid);
            if (owner)
                owner->GetSession()->SendPetitionQueryOpcode(petitionguid);
        }
        while (result->NextRow());

        if (type == 10)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_PETITION_SIGNATURES);

            stmt->setUInt32(0, GUID_LOPART(guid));

            CharacterDatabase.Execute(stmt);
        }
        else
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE);

            stmt->setUInt32(0, GUID_LOPART(guid));
            stmt->setUInt8(1, uint8(type));

            CharacterDatabase.Execute(stmt);
        }
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    if (type == 10)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);
    }
    CharacterDatabase.CommitTransaction(trans);
#endif
}

void Player::SetRestBonus (float rest_bonus_new)
{
    // Prevent resting on max level
    if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        rest_bonus_new = 0;

    if (rest_bonus_new < 0)
        rest_bonus_new = 0;

    float rest_bonus_max = (float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)*1.5f/2;

    if (rest_bonus_new > rest_bonus_max)
        m_rest_bonus = rest_bonus_max;
    else
        m_rest_bonus = rest_bonus_new;

    // Inner Peace
    if (HasAura(107074))
        m_rest_bonus *= 2;

    float modifier = 1.0f;
    AuraEffectList const& mIncreaseRest = GetAuraEffectsByType(SPELL_AURA_INCREASE_REST_BONUS_PERCENT);
    for (AuraEffectList::const_iterator i = mIncreaseRest.begin(); i != mIncreaseRest.end(); ++i)
        modifier += float((*i)->GetAmount() / 100);

    m_rest_bonus *= modifier;

    // update data for client
    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_REST_STATE, REST_STATE_RAF_LINKED);
    else if (m_rest_bonus > 10)
        SetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_REST_STATE, REST_STATE_RESTED);              // Set Reststate = Rested
    else if (m_rest_bonus <= 1)
        SetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_REST_STATE, REST_STATE_NOT_RAF_LINKED);              // Set Reststate = Normal

    //RestTickUpdate
    SetUInt32Value(PLAYER_FIELD_REST_STATE_BONUS_POOL, uint32(m_rest_bonus));
}

bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc /*= NULL*/, uint32 spellid /*= 0*/)
{
    if (nodes.size() < 2)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
        return false;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE))
        return false;

    // taximaster case
    if (npc)
    {
        // not let cheating with start flight mounted
        if (IsMounted())
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERALREADYMOUNTED);
            return false;
        }

        if (IsInDisallowedMountForm())
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERSHAPESHIFTED);
            return false;
        }

        // not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
        if (IsNonMeleeSpellCasted(false))
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
            return false;
        }
    }
    // cast case or scripted call case
    else
    {
        RemoveAurasByType(SPELL_AURA_MOUNTED);

        if (IsInDisallowedMountForm())
            RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);

        if (Spell* spell = GetCurrentSpell(CURRENT_GENERIC_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_GENERIC_SPELL, false);

        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);

        if (Spell* spell = GetCurrentSpell(CURRENT_CHANNELED_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_CHANNELED_SPELL, true);
    }

    uint32 sourcenode = nodes[0];

    // starting node too far away (cheat?)
    TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(sourcenode);
    if (!node)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    uint32 l_MapID = GetMapId();

#ifndef CROSS
    /// Special case for taxi in garrison phased map
    for (uint32 l_I = 0; l_I < sGarrSiteLevelStore.GetNumRows(); ++l_I)
    {
        const GarrSiteLevelEntry * l_Entry = sGarrSiteLevelStore.LookupEntry(l_I);

        if (l_Entry && l_Entry->MapID == l_MapID)
        {
            l_MapID = MS::Garrison::Globals::BaseMap;
            break;
        }
    }
#endif

    // check node starting pos data set case if provided
    if (node->x != 0.0f || node->y != 0.0f || node->z != 0.0f)
    {
        if (node->MapID != l_MapID ||
            (node->x - GetPositionX())*(node->x - GetPositionX())+
            (node->y - GetPositionY())*(node->y - GetPositionY())+
            (node->z - GetPositionZ())*(node->z - GetPositionZ()) >
            (2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE))
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXITOOFARAWAY);
            return false;
        }
    }
    // node must have pos if taxi master case (npc != NULL)
    else if (npc)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        return false;
    }
    // Prepare to flight start now

    // stop combat at start taxi flight if any
    CombatStop();

    StopCastingCharm();
    StopCastingBindSight();
    ExitVehicle();

    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
    TradeCancel(true);

    // clean not finished taxi path if any
    m_taxi.ClearTaxiDestinations();

    // 0 element current node
    m_taxi.AddTaxiDestination(sourcenode);

    // fill destinations path tail
    uint32 sourcepath = 0;
    uint32 totalcost = 0;
    uint32 firstcost = 0;

    uint32 prevnode = sourcenode;
    uint32 lastnode;

    for (uint32 i = 1; i < nodes.size(); ++i)
    {
        uint32 path, cost;

        lastnode = nodes[i];
        sObjectMgr->GetTaxiPath(prevnode, lastnode, path, cost);

        if (!path)
        {
            m_taxi.ClearTaxiDestinations();
            return false;
        }

        totalcost += cost;
        if (i == 1)
            firstcost = cost;

        if (prevnode == sourcenode)
            sourcepath = path;

        m_taxi.AddTaxiDestination(lastnode);

        prevnode = lastnode;
    }

    // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
    //
    // Hack-Fix for Alliance not being able to use Acherus taxi. There is
    // only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
    // change but I couldn't find a suitable alternative. OK to use class because only DK
    // can use this taxi.
    uint32 mount_display_id = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetTeam(), npc == nullptr || (sourcenode == 315 && getClass() == CLASS_DEATH_KNIGHT));

    // in spell case allow 0 model
    if ((mount_display_id == 0 && spellid == 0) || sourcepath == 0)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    uint64 money = GetMoney();

    if (npc)
        totalcost = (uint32)ceil(totalcost*GetReputationPriceDiscount(npc));

    if (money < totalcost)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOTENOUGHMONEY);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    //Checks and preparations done, DO FLIGHT
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);

    // prevent stealth flight
    //RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);

    if (sWorld->getBoolConfig(CONFIG_INSTANT_TAXI))
    {
        TaxiNodesEntry const* lastPathNode = sTaxiNodesStore.LookupEntry(nodes[nodes.size()-1]);
        ASSERT(lastPathNode);
        m_taxi.ClearTaxiDestinations();
        ModifyMoney(-int64(totalcost));
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, totalcost);
        TeleportTo(lastPathNode->MapID, lastPathNode->x, lastPathNode->y, lastPathNode->z, GetOrientation());
        return false;
    }
    else
    {
        ModifyMoney(-int64(firstcost));
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, firstcost);
        GetSession()->SendActivateTaxiReply(ERR_TAXIOK);
        GetSession()->SendDoFlight(mount_display_id, sourcepath);
    }
    return true;
}

bool Player::ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid /*= 0*/)
{
    TaxiPathEntry const* entry = sTaxiPathStore.LookupEntry(taxi_path_id);
    if (!entry)
        return false;

    std::vector<uint32> nodes;

    nodes.resize(2);
    nodes[0] = entry->From;
    nodes[1] = entry->To;

    return ActivateTaxiPathTo(nodes, nullptr, spellid);
}

void Player::CleanupAfterTaxiFlight()
{
    m_taxi.ClearTaxiDestinations();        // not destinations, clear source node
    Dismount();
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_TAXI_FLIGHT);
    getHostileRefManager().setOnlineOfflineState(true);
}

void Player::ContinueTaxiFlight() const
{
    uint32 sourceNode = m_taxi.GetTaxiSource();
    if (!sourceNode)
        return;

    sLog->outDebug(LOG_FILTER_UNITS, "WORLD: Restart character %u taxi flight", GetGUIDLow());

    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourceNode, GetTeam(), true);
    if (!mountDisplayId)
        return;

    uint32 path = m_taxi.GetCurrentTaxiPath();

    // search appropriate start path node
    uint32 startNode = 0;

    TaxiPathNodeList const& nodeList = sTaxiPathNodesByPath[path];

    float distPrev;
    float distNext =
        (nodeList[0]->x - GetPositionX())*(nodeList[0]->x - GetPositionX()) +
        (nodeList[0]->y - GetPositionY())*(nodeList[0]->y - GetPositionY()) +
        (nodeList[0]->z - GetPositionZ())*(nodeList[0]->z - GetPositionZ());

    for (uint32 i = 1; i < nodeList.size(); ++i)
    {
        TaxiPathNodeEntry const* node = nodeList[i];
        TaxiPathNodeEntry const* prevNode = nodeList[i - 1];

        // skip nodes at another map
        if (node->MapID != GetMapId())
            continue;

        distPrev = distNext;

        distNext =
            (node->x - GetPositionX()) * (node->x - GetPositionX()) +
            (node->y - GetPositionY()) * (node->y - GetPositionY()) +
            (node->z - GetPositionZ()) * (node->z - GetPositionZ());

        float distNodes =
            (node->x - prevNode->x) * (node->x - prevNode->x) +
            (node->y - prevNode->y) * (node->y - prevNode->y) +
            (node->z - prevNode->z) * (node->z - prevNode->z);

        if (distNext + distPrev < distNodes)
        {
            startNode = i;
            break;
        }
    }

    GetSession()->SendDoFlight(mountDisplayId, path, startNode);
}

void Player::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs)
{
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
        if (idSchoolMask & (1 << i))
            prohibited[i] = prohibited_struct(unTimeMs);

    WorldPacket data(SMSG_SPELL_COOLDOWN, 1 * 1024);
    ByteBuffer dataBuffer(1 * 1024);
    ObjectGuid playerGuid = GetGUID();

    uint32 counter = 0;
    uint32 curMsTime = getMSTime();

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
    {
        if (itr->second->state == PLAYERSPELL_REMOVED)
            continue;

        uint32 unSpellId = itr->first;
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(unSpellId);
        if (!spellInfo)
        {
            ASSERT(spellInfo);
            continue;
        }
        // Not send cooldown for this spells
        if (spellInfo->IsCooldownStartedOnEvent())
            continue;

        if ((spellInfo->PreventionType & (SpellPreventionMask::Silence)) == 0)
            continue;

        for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
        {
            if (idSchoolMask & (1 << i))
            {
                if (((1 << i) & spellInfo->GetSchoolMask()) && GetSpellCooldownDelay(unSpellId) < unTimeMs)
                {
                    SpellSchools school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
                    if ((1 << school) != spellInfo->GetSchoolMask())
                    {
                        SpellSchoolMask d_mask = SpellSchoolMask((1 << i) ^ spellInfo->GetSchoolMask());
                        bool do_break = false;
                        for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
                        {
                            if (d_mask & (1 << i))
                            {
                                if (prohibited[i].m_time_prohibited_until < curMsTime)
                                {
                                    do_break = true;
                                    break;
                                }
                                else
                                {
                                    unTimeMs = std::max(unTimeMs, prohibited[i].m_time_prohibited_until - curMsTime);
                                }
                            }
                        }

                        if (do_break)
                            continue;
                    }
                    ++counter;
                    dataBuffer << uint32(unSpellId);
                    dataBuffer << uint32(unTimeMs);                       // in m.secs
                    AddSpellCooldown(unSpellId, 0, unTimeMs);
                }
            }
        }
    }

    data.appendPackGUID(playerGuid);
    data << uint8(0);
    data << uint32(counter);
    data.append(dataBuffer);

    GetSession()->SendPacket(&data);
}

void Player::InitDataForForm(bool reapplyMods)
{
    ShapeshiftForm form = GetShapeshiftForm();

    SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
    if (ssEntry && ssEntry->attackSpeed)
    {
        SetAttackTime(WeaponAttackType::BaseAttack, ssEntry->attackSpeed);
        SetAttackTime(WeaponAttackType::OffAttack, ssEntry->attackSpeed);
        SetAttackTime(WeaponAttackType::RangedAttack, BASE_ATTACK_TIME);
    }
    else
        SetRegularAttackTime();

    switch (form)
    {
        case FORM_FIERCE_TIGER:
        case FORM_STURDY_OX:
        case FORM_GHOUL:
        case FORM_CAT:
        {
            if (getPowerType() != POWER_ENERGY)
                setPowerType(POWER_ENERGY);
            break;
        }
        case FORM_BEAR:
        {
            if (getPowerType() != POWER_RAGE)
                setPowerType(POWER_RAGE);
            break;
        }
        case FORM_SPIRITED_CRANE:
        case FORM_WISE_SERPENT:
        {
            if (getPowerType() != POWER_MANA)
                setPowerType(POWER_MANA);
            break;
        }
        default:                                            // 0, for example
        {
            ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(getClass());
            if (cEntry && cEntry->DisplayPower < MAX_POWERS && uint32(getPowerType()) != cEntry->DisplayPower)
                setPowerType(Powers(cEntry->DisplayPower));
            break;
        }
    }

    // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
    if (!reapplyMods)
        UpdateEquipSpellsAtFormChange();

    UpdateAttackPowerAndDamage();
    UpdateAttackPowerAndDamage(true);
}

void Player::InitDisplayIds()
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player %u has incorrect race/class pair. Can't init display ids.", GetGUIDLow());
        return;
    }

    uint8 gender = getGender();
    switch (gender)
    {
        case GENDER_FEMALE:
            SetDisplayId(info->displayId_f);
            SetNativeDisplayId(info->displayId_f);
            break;
        case GENDER_MALE:
            SetDisplayId(info->displayId_m);
            SetNativeDisplayId(info->displayId_m);
            break;
        default:
            sLog->outError(LOG_FILTER_PLAYER, "Invalid gender %u for player", gender);
            return;
    }
}

inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int64 price, ItemTemplate const* pProto, Creature* pVendor, VendorItem const* crItem, bool bStore)
{
    ItemPosCountVec vDest;
    uint16 uiDest = 0;
    InventoryResult msg = bStore ?
        CanStoreNewItem(bag, slot, vDest, item, count) :
        CanEquipNewItem(slot, uiDest, item, false);
    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, NULL, NULL, item);
        return false;
    }


    if (crItem->ExtendedCost) // case for new honor system
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredItem[i])
                DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count, true);
        }

        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredCurrency[i])
                if (i != 1 || iece->ID == 2999) // 1 are season count request, we must not substract it
                    ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i] * count), true, true);
        }

        if (uint32 l_OverridePrice = iece->OverrideBuyPrice)
        {
            price = l_OverridePrice * count * GetReputationPriceDiscount(pVendor);

            if (int64 priceMod = int64(GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES)))
                price -= CalculatePct(price, priceMod);
        }
    }

    ModifyMoney(-price);

    Item* it = bStore ?
        StoreNewItem(vDest, item, true) :
        EquipNewItem(uiDest, item, true);
    if (it)
    {
        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, count);

        WorldPacket data(SMSG_BUY_ITEM, 16 + 2 + 4 + 4 + 4);

        ObjectGuid vendorGuid = pVendor->GetGUID();

        data.appendPackGUID(vendorGuid);
        data << uint32(vendorslot + 1);                   // numbered from 1 at client
        data << int32(crItem->maxcount > 0 ? new_count : 0xFFFFFFFF);
        data << uint32(count);

        GetSession()->SendPacket(&data);
        SendNewItem(it, count, true, false, false);

        if (!bStore)
            AutoUnequipOffhandIfNeed();

        if (pProto->Flags & ITEM_FLAG_REFUNDABLE && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1)
        {
            it->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE);
            it->SetUInt32Value(ITEM_FIELD_CONTEXT, 14);
            it->SetRefundRecipient(GetGUIDLow());
            it->SetPaidMoney(price);
            it->SetPaidExtendedCost(crItem->ExtendedCost);
            it->SaveRefundDataToDB();
            AddRefundReference(it->GetGUIDLow());
        }
    }
    return true;
}

bool Player::BuyCurrencyFromVendorSlot(uint64 vendorGuid, uint32 vendorSlot, uint32 currency, uint32 count)
{
    //vendorSlot += 1; Already handled in HandleBuyItemOpcode ?

    // cheating attempt
    if (count < 1) count = 1;

    if (!isAlive())
        return false;

    CurrencyTypesEntry const* proto = sCurrencyTypesStore.LookupEntry(currency);
    if (!proto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyCurrencyFromVendorSlot - Unit (GUID: %u) not found or you can't interact with him.", GUID_LOPART(vendorGuid));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, currency, 0);
        return false;
    }

    VendorItemData const* vItems = creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (vendorSlot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorSlot);
    // store diff item (cheating)
    if (!crItem || crItem->item != currency || crItem->Type != ITEM_VENDOR_TYPE_CURRENCY)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (crItem->PlayerConditionID != 0 && EvalPlayerCondition(crItem->PlayerConditionID).first == false)
    {
        /// @TODO find the right error
        return false;
    }

    int32 precision = (proto->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    if (crItem->ExtendedCost)
    {
        // Can only buy full stacks for extended cost
        if ((crItem->maxcount * precision) != count)
        {
            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
            return false;
        }

        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Currency %u have wrong ExtendedCost field value %u", currency, crItem->ExtendedCost);
            return false;
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0); // Find correct error
                return false;
            }

            if (!HasCurrency(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i] * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }
    }
    else // currencies have no price defined, can only be bought with ExtendedCost
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    ModifyCurrency(currency, crItem->maxcount * precision, true, true);

    if (crItem->ExtendedCost)
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredItem[i])
                DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count, true);
        }

        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredCurrency[i])
                if (i != 1 || iece->ID == 2999) // 1 are season count request, we must not substract it
                    ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i] * count), true, true);
        }
    }

    return true;
}

// Return true is the bought item has a max count to force refresh of window by caller
bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot)
{
    // cheating attempt
    if (count < 1)
        count = 1;

    // cheating attempt
    if (slot > MAX_BAG_SIZE && slot != NULL_SLOT)
        return false;

    if (!isAlive())
        return false;

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (!pProto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
        return false;
    }

    VendorItemData const* vItems = creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    if (vendorslot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorslot);
    // store diff item (cheating)
    if (!crItem || crItem->item != item)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
        return false;
    }

    // check current item amount if it limited
    if (crItem->maxcount != 0)
    {
        if (creature->GetVendorItemCurrentCount(crItem) < pProto->BuyCount * count)
        {
            SendBuyError(BUY_ERR_ITEM_ALREADY_SOLD, creature, item, 0);
            return false;
        }
    }

    if (pProto->RequiredReputationFaction && (uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank))
    {
        SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, item, 0);
        return false;
    }

    if (crItem->PlayerConditionID != 0 && crItem->PlayerConditionID < 0xFFFFFF && EvalPlayerCondition(crItem->PlayerConditionID).first == false)
    {
        /// @TODO find the right error
        return false;
    }

    uint64 price = 0;

    if (crItem->ExtendedCost)
    {
        // Can only buy full stacks for extended cost
        /*if (pProto->BuyCount != count)
        {
            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
            return false;
        }*/

        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Item %u have wrong ExtendedCost field value %u", pProto->ItemId, crItem->ExtendedCost);
            return false;
        }

        if (uint32 l_OverridePrice = iece->OverrideBuyPrice)
            price = l_OverridePrice;

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }

            uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

            // Second field in dbc is season count except two strange rows
            if (i == 1 && iece->ID != 2999)
            {
                if ((iece->RequiredCurrencyCount[i] * count / precision) > GetCurrencyOnSeason(iece->RequiredCurrency[i], false))
                {
                    SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                    return false;
                }
            }
            else if (!HasCurrency(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i]  * count))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }
    }

#ifndef CROSS
    std::vector<GuildReward> const& rewards = sGuildMgr->GetGuildRewards();

    for (auto reward: rewards)
    {
        if (pProto->ItemId != reward.Entry)
            continue;

        Guild* guild = sGuildMgr->GetGuildById(this->GetGuildId());

        if (!guild)
        {
            SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
            return false;
        }

        if (reward.Standing)
            if (this->GetReputationRank(REP_GUILD) < reward.Standing)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }

        if (reward.AchievementId)
            if (!guild->GetAchievementMgr().HasAchieved(reward.AchievementId))
            {
                if (!(reward.AchievementId == 5492 && guild->GetAchievementMgr().HasAchieved(4912)) && !(reward.AchievementId == 4912 && guild->GetAchievementMgr().HasAchieved(5492)))
                {
                    SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                    return false;
                }
            }

        if (reward.Racemask)
            if (!(this->getRaceMask() & reward.Racemask))
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
                return false;
            }
    }
#endif

    if (!price && crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
    {
        uint32 maxCount = MAX_MONEY_AMOUNT / pProto->BuyPrice;
        if ((uint32)count > maxCount)
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to buy %u item id %u, causing overflow", GetName(), (uint32)count, pProto->ItemId);
            count = (uint8)maxCount;
        }

        price = uint64(pProto->BuyPrice);
    }

    if (price)
    {
        price *= count; //it should not exceed MAX_MONEY_AMOUNT

        // reputation discount
        price = uint64(floor(price * GetReputationPriceDiscount(creature)));

        if (int64 priceMod = int64(GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES)))
            price -= CalculatePct(price, priceMod);

        if (!HasEnoughMoney(price))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, item, 0);
            return false;
        }
    }

    if ((bag == NULL_BAG && slot == NULL_SLOT) || IsInventoryPos(bag, slot))
    {
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, true))
            return false;
    }
    else if (IsEquipmentPos(bag, slot))
    {
        if (count != 1)
        {
            SendEquipError(EQUIP_ERR_NOT_EQUIPPABLE, NULL, NULL);
            return false;
        }
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, false))
            return false;
    }
    else
    {
        SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return false;
    }

    if (crItem->maxcount != 0) // bought
    {
        /*if (pProto->Quality > ITEM_QUALITY_EPIC || (pProto->Quality == ITEM_QUALITY_EPIC && pProto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
            if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                guild->GetNewsLog().AddNewEvent(GUILD_NEWS_ITEM_PURCHASED, time(NULL), GetGUID(), 0, item);*/
        return true;
    }
    return false;
}

uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
{
    // returns the maximal personal arena rating that can be used to purchase items requiring this condition
    // the personal rating of the arena team must match the required limit as well
    // so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
    uint32 max_personal_rating = 0;
    for (uint8 i = minarenaslot; i < MAX_ARENA_SLOT; ++i)
    {
        if (max_personal_rating < GetArenaPersonalRating(i))
            max_personal_rating = GetArenaPersonalRating(i);
    }
    return max_personal_rating;
}

void Player::UpdateHomebindTime(uint32 time)
{
    // GMs never get homebind timer online
#ifndef CROSS
    if (m_InstanceValid || isGameMaster() || IsInGarrison())
#else /* CROSS */
    if (m_InstanceValid || isGameMaster())
#endif /* CROSS */
    {
        if (m_HomebindTimer)                                 // instance valid, but timer not reset
        {
            // hide reminder
            WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
            data << uint32(0);
            data << uint32(0);
            GetSession()->SendPacket(&data);
        }
        // instance is valid, reset homebind timer
        m_HomebindTimer = 0;
    }
    else if (m_HomebindTimer > 0)
    {
        if (time >= m_HomebindTimer)
        {
            // teleport to nearest graveyard
            RepopAtGraveyard(true);
        }
        else
            m_HomebindTimer -= time;
    }
    else
    {
        // instance is invalid, start homebind timer
        m_HomebindTimer = 60000;
        // send message to player
        WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
        data << uint32(m_HomebindTimer);
        data << uint32(1);
        GetSession()->SendPacket(&data);
        sLog->outDebug(LOG_FILTER_MAPS, "PLAYER: Player '%s' (GUID: %u) will be teleported to homebind in 60 seconds", GetName(), GetGUIDLow());
    }
}

void Player::UpdatePvPState(bool onlyFFA)
{
    // TODO: should we always synchronize UNIT_FIELD_BYTES_2, 1 of controller and controlled?
    // no, we shouldn't, those are checked for affecting player by client
    if (!pvpInfo.inNoPvPArea && !isGameMaster()
        && (pvpInfo.inFFAPvPArea || sWorld->IsFFAPvPRealm()))
    {
        if (!HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
        {
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
            for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
                (*itr)->SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        }
    }
    else if (HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
    {
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
            (*itr)->RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
    }

    if (onlyFFA)
        return;

    if (pvpInfo.inHostileArea)                               // in hostile area
    {
        if (!IsPvP() || pvpInfo.endTimer != 0)
            UpdatePvP(true, true);
    }
    else                                                    // in friendly area
    {
        if (IsPvP() && !HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) && pvpInfo.endTimer == 0)
            pvpInfo.endTimer = time(0);                     // start toggle-off
    }
}

void Player::UpdatePvP(bool state, bool override)
{
    if (!state || override)
    {
        SetPvP(state);
        pvpInfo.endTimer = 0;
    }
    else
    {
        pvpInfo.endTimer = time(NULL);
        SetPvP(state);
    }
}

void Player::AddSpellAndCategoryCooldowns(SpellInfo const* p_SpellInfo, uint32 p_ItemId, Spell* p_Spell, bool p_InfinityCooldown)
{
    /// No need to set cooldown for Battle resurrection spells during a raid encounter
    /// Now we have a system using Battle resurrection charges
    if (p_SpellInfo->IsBattleResurrection())
    {
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->IsEncounterInProgress() && l_InstanceScript->instance->IsRaid())
                return;
        }
    }

    // init cooldown values
    uint32 l_CategoryId       = 0; // cat
    int64  l_Cooldown         = -1; //rec
    int64  l_CategoryCooldown = -1; //catrec

    // some special item spells without correct cooldown in SpellInfo
    // cooldown information stored in item prototype
    // This used in same way in WorldSession::HandleItemQuerySingleOpcode data sending to client.
    if (p_ItemId)
    {
        if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(p_ItemId))
        {
            for (uint8 l_Idx = 0; l_Idx < MAX_ITEM_SPELLS; ++l_Idx)
            {
                if (uint32(l_Proto->Spells[l_Idx].SpellId) == p_SpellInfo->Id)
                {
                    l_CategoryId       = l_Proto->Spells[l_Idx].SpellCategory;
                    l_Cooldown         = l_Proto->Spells[l_Idx].SpellCooldown;
                    l_CategoryCooldown = l_Proto->Spells[l_Idx].SpellCategoryCooldown;
                    break;
                }
            }
        }
    }

    // if no cooldown found above then base at DBC data
    if (l_Cooldown < 0 && l_CategoryCooldown < 0)
    {
        l_CategoryId       = p_SpellInfo->GetCategory();
        l_Cooldown         = p_SpellInfo->RecoveryTime;
        l_CategoryCooldown = p_SpellInfo->CategoryRecoveryTime;
    }

    uint64 l_CurTime = 0;
    ACE_OS::gettimeofday().msec(l_CurTime);

    uint64 l_CooldownTime;
    uint64 l_CategoryCooldownTime;

    bool l_NeedsCooldownPacket = false;

    // overwrite time for selected category
    if (p_InfinityCooldown)
    {
        // use +MONTH as infinity mark for spell cooldown (will checked as MONTH/2 at save ans skipped)
        // but not allow ignore until reset or re-login
        l_CategoryCooldownTime = l_CategoryCooldown > 0 ? infinityCooldownDelay : 0;
        l_CooldownTime         = l_Cooldown         > 0 ? infinityCooldownDelay : l_CategoryCooldownTime;
    }
    else
    {
        // shoot spells used equipped item cooldown values already assigned in GetAttackTime(RANGED_ATTACK)
        // prevent 0 cooldowns set by another way
        if (l_Cooldown <= 0 && l_CategoryCooldown <= 0 && (l_CategoryId == 7611 || (p_SpellInfo->IsAutoRepeatRangedSpell() && p_SpellInfo->Id != 75 && p_SpellInfo->Id != 5019 && p_SpellInfo->Id != 121733)))
            l_Cooldown = GetAttackTime(WeaponAttackType::RangedAttack);

        // Now we have cooldown data (if found any), time to apply mods
        if (l_Cooldown > 0)
            ApplySpellMod(p_SpellInfo->Id, SPELLMOD_COOLDOWN, l_Cooldown, p_Spell);

        if (l_CategoryCooldown > 0 && !(p_SpellInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
            ApplySpellMod(p_SpellInfo->Id, SPELLMOD_COOLDOWN, l_CategoryCooldown, p_Spell);

        if (int32 l_CooldownMod = GetTotalAuraModifier(SPELL_AURA_MOD_COOLDOWN))
        {
            // Apply SPELL_AURA_MOD_COOLDOWN only to own spells
            if (HasSpell(p_SpellInfo->Id))
            {
                l_NeedsCooldownPacket = true;
                l_Cooldown += l_CooldownMod * IN_MILLISECONDS;   // SPELL_AURA_MOD_COOLDOWN does not affect category cooldows, verified with shaman shocks
            }
        }

        if (int32 l_CooldownMod = GetTotalAuraModifier(SPELL_AURA_MOD_COOLDOWN_BY_HASTE))
        {
            float l_Haste = 1.0f - GetFloatValue(UNIT_FIELD_MOD_HASTE);

            if (l_Cooldown > 0)
                l_Cooldown -= CalculatePct(CalculatePct(l_Cooldown, (l_Haste * 100)), l_CooldownMod);

            if (l_CategoryCooldown > 0)
                l_CategoryCooldown -= CalculatePct(CalculatePct(l_CategoryCooldown, (l_Haste * 100)), l_CooldownMod);

            l_NeedsCooldownPacket = true;
        }

        AuraEffectList const& l_ListAuraCooldownByHaste = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_COOLDOWN_BY_HASTE);
        if (!l_ListAuraCooldownByHaste.empty())
        {
            float l_Haste = 1.0f - GetFloatValue(UNIT_FIELD_MOD_HASTE);

            for (AuraEffect* l_AuraEffect : l_ListAuraCooldownByHaste)
            {
                if (l_AuraEffect->IsAffectingSpell(p_SpellInfo))
                {
                    if (l_Cooldown > 0)
                        l_Cooldown -= CalculatePct(CalculatePct(l_Cooldown, (l_Haste * 100)), l_AuraEffect->GetAmount());

                    if (l_CategoryCooldown > 0)
                        l_CategoryCooldown -= CalculatePct(CalculatePct(l_CategoryCooldown, (l_Haste * 100)), l_AuraEffect->GetAmount());

                    l_NeedsCooldownPacket = true;
                }
            }
        }

        if (l_CategoryId)
        {
            if (int32 l_CategoryModifier = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN, l_CategoryId))
            {
                if (l_Cooldown > 0)
                    l_Cooldown += l_CategoryModifier;

                if (l_CategoryCooldown > 0)
                    l_CategoryCooldown += l_CategoryModifier;
            }

            SpellCategoryEntry const* l_CategoryEntry = sSpellCategoryStore.LookupEntry(l_CategoryId);
            if (l_CategoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET)
                l_CategoryCooldown = (sWorld->GetNextDailyQuestsResetTime() * IN_MILLISECONDS) - l_CurTime;
        }

        // replace negative cooldowns by 0
        if (l_Cooldown < 0)
            l_Cooldown = 0;

        if (l_CategoryCooldown < 0)
            l_CategoryCooldown = 0;

        // no cooldown after applying spell mods
        if (l_Cooldown == 0 && l_CategoryCooldown == 0)
            return;

        l_CategoryCooldownTime = l_CategoryCooldown ? l_CategoryCooldown : 0;
        l_CooldownTime = l_Cooldown ? l_Cooldown : l_CategoryCooldownTime;
    }

    // self spell cooldown
    if (l_CooldownTime > 0)
        AddSpellCooldown(p_SpellInfo->Id, p_ItemId, l_CooldownTime, l_NeedsCooldownPacket);
}

void Player::AddSpellCooldown(uint32 spellid, uint32 itemid, uint64 end_time, bool p_send /* = false */)
{
    uint64 curTime = 0;
    ACE_OS::gettimeofday().msec(curTime);

    SpellCooldown sc;
    sc.end = curTime + end_time;
    sc.itemid = itemid;
    m_spellCooldowns[spellid] = sc;

    if (p_send)
    {
        WorldPacket data(SMSG_SPELL_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
        data.appendPackGUID(GetGUID());
        data << uint8(CooldownFlags::CooldownFlagNone);
        data << uint32(1);
        data << uint32(spellid);
        data << uint32(end_time);

        GetSession()->SendPacket(&data);
    }
}

void Player::SendCategoryCooldown(uint32 p_CategoryID, int32 p_CoolDown)
{
    WorldPacket l_Packet(SMSG_CATEGORY_COOLDOWN, 16 + 2 + 1 + 4 + 4 + 4);
    l_Packet << uint32(1);
    l_Packet << uint32(p_CategoryID);
    l_Packet << uint32(p_CoolDown);
    SendDirectMessage(&l_Packet);
}

void Player::SendCooldownEvent(const SpellInfo * p_SpellInfo, uint32 p_ItemID, Spell * p_Spell, bool p_SetCooldown)
{
    /// start cooldowns at server side, if any
    if (p_SetCooldown)
        AddSpellAndCategoryCooldowns(p_SpellInfo, p_ItemID, p_Spell);

    /// Send activate cooldown timer (possible 0) at client side
    WorldPacket l_Data(SMSG_COOLDOWN_EVENT, 4 + 8);
    l_Data << uint32(p_SpellInfo->Id);
    l_Data.WriteBit(false);             ///< IsPet

    SendDirectMessage(&l_Data);
}

void Player::UpdatePotionCooldown(Spell* p_Spell)
{
    // no potion used in combat or still in combat
    if (!m_LastPotion.m_LastPotionItemID || isInCombat())
        return;

    // Call not from spell cast, send cooldown event for item spells if no in combat
    if (!p_Spell)
    {
        bool l_Success = false;
        // spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
        if (ItemTemplate const* l_Proto = sObjectMgr->GetItemTemplate(m_LastPotion.m_LastPotionItemID))
        {
            for (uint8 idx = 0; idx < MAX_ITEM_PROTO_SPELLS; ++idx)
            {
                if (l_Proto->Spells[idx].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE)
                {
                    if (SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(l_Proto->Spells[idx].SpellId))
                    {
                        l_Success = true;
                        SendCooldownEvent(l_SpellInfo, m_LastPotion.m_LastPotionItemID);
                    }
                }
            }
        }
        if (!l_Success && m_LastPotion.m_LastPotionSpellID)
        {
            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo(m_LastPotion.m_LastPotionSpellID);
            SendCooldownEvent(l_SpellInfo, m_LastPotion.m_LastPotionItemID);
        }
    }
    // from spell cases (m_lastPotionId set in Spell::SendSpellCooldown)
    else
        SendCooldownEvent(p_Spell->m_spellInfo, m_LastPotion.m_LastPotionItemID, p_Spell);

    m_LastPotion.m_LastPotionItemID = 0;
    m_LastPotion.m_LastPotionSpellID = 0;
}
                                                           //slot to be excluded while counting
bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
{
    if (!enchantmentcondition)
        return true;

    SpellItemEnchantmentConditionEntry const* Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);

    if (!Condition)
        return true;

    uint8 curcount[4] = {0, 0, 0, 0};

    //counting current equipped gem colors
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == slot)
            continue;
        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->CantBeUse() && pItem2->GetTemplate()->Socket[0].Color)
        {
            for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
            {
                uint32 enchant_id = pItem2->GetEnchantmentId(EnchantmentSlot(enchant_slot));
                if (!enchant_id)
                    continue;

                SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
                if (!enchantEntry)
                    continue;

                uint32 gemid = enchantEntry->GemID;
                if (!gemid)
                    continue;

                ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemid);
                if (!gemProto)
                    continue;

                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GemProperties);
                if (!gemProperty)
                    continue;

                uint8 GemColor = gemProperty->color;

                for (uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
                {
                    if (tmpcolormask & GemColor)
                        ++curcount[b];
                }
            }
        }
    }

    bool activate = true;

    for (uint8 i = 0; i < 5; i++)
    {
        if (!Condition->Color[i])
            continue;

        uint32 _cur_gem = curcount[Condition->Color[i] - 1];

        if ((Condition->CompareColor[i] - 1) > 3)
            continue;

        // if have <CompareColor> use them as count, else use <value> from Condition
        uint32 _cmp_gem = Condition->CompareColor[i] ? curcount[Condition->CompareColor[i] - 1]: Condition->Value[i];

        switch (Condition->Comparator[i])
        {
            case 2:                                         // requires less <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem < _cmp_gem) ? true : false;
                break;
            case 3:                                         // requires more <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem > _cmp_gem) ? true : false;
                break;
            case 5:                                         // requires at least <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem >= _cmp_gem) ? true : false;
                break;
        }
    }

    sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "Checking Condition %u, there are %u Meta Gems, %u Red Gems, %u Yellow Gems and %u Blue Gems, Activate:%s", enchantmentcondition, curcount[0], curcount[1], curcount[2], curcount[3], activate ? "yes" : "no");

    return activate;
}

void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
{
                                                            //cycle all equipped items
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        //enchants for the slot being socketed are handled by Player::ApplyItemMods
        if (slot == exceptslot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)
            continue;

        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            uint32 condition = enchantEntry->EnchantmentCondition;
            if (condition)
            {
                                                            //was enchant active with/without item?
                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
                                                            //should it now be?
                if (wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
                {
                    // ignore item gem conditions
                    //if state changed, (dis)apply enchant
                    ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), !wasactive, true, true);
                }
            }
        }
    }
}

void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
{
    //cycle all equipped items
    for (int slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        //enchants for the slot being socketed are handled by WorldSession::HandleSocketOpcode(WorldPacket& recvData)
        if (slot == exceptslot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)   //if item has no sockets or no item is equipped go to next item
            continue;

        //cycle all (gem)enchants
        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)                                 //if no enchant go to next enchant(slot)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            //only metagems to be (de)activated, so only enchants with condition
            uint32 condition = enchantEntry->EnchantmentCondition;
            if (condition)
                ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), apply);
        }
    }
}

void Player::SetBattlegroundEntryPoint()
{
    // Taxi path store
    if (!m_taxi.IsPathEmpty())
    {
        m_bgData.mountSpell  = 0;
        m_bgData.taxiPath[0] = m_taxi.GetTaxiSource();
        m_bgData.taxiPath[1] = m_taxi.GetTaxiDestination();

        // On taxi we don't need check for dungeon
        m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }
    else
    {
        m_bgData.ClearTaxiPath();

        // Mount spell id storing
        if (IsMounted())
        {
            AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOUNTED);
            if (!auras.empty())
                m_bgData.mountSpell = (*auras.begin())->GetId();
        }
        else
            m_bgData.mountSpell = 0;

        if (Aura* aur = GetAura(33943))
            m_bgData.mountSpell = 33943;

        // If map is dungeon find linked graveyard
#ifndef CROSS
        if (GetMap()->IsDungeon() && !IsInGarrison())
#else /* CROSS */
        if (GetMap()->IsDungeon())
#endif /* CROSS */
        {
            if (const WorldSafeLocsEntry* entry = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam()))
                m_bgData.joinPos = WorldLocation(entry->map_id, entry->x, entry->y, entry->z, 0.0f);
            else
                sLog->outError(LOG_FILTER_PLAYER, "SetBattlegroundEntryPoint: Dungeon map %u has no linked graveyard, setting home location as entry point.", GetMapId());
        }
        // If new entry point is not BG or arena set it
        else if (!GetMap()->IsBattlegroundOrArena())
            m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }

    if (m_bgData.joinPos.m_mapId == MAPID_INVALID) // In error cases use homebind position
        m_bgData.joinPos = WorldLocation(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0.0f);
}

#ifndef CROSS
void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    if (Battleground* bg = GetBattleground())
    {
        bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);

        // call after remove to be sure that player resurrected for correct cast
        if (bg->isBattleground() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                //lets check if player was teleported from BG and schedule delayed Deserter spell cast
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                CastSpell(this, 26013, true); ///< Deserter
            }
        }
        sScriptMgr->OnLeaveBG(this, bg->GetMapId());
    }
}

#endif /* not CROSS */
bool Player::CanJoinToBattleground() const
{
    /// Check Deserter debuff.
    if (HasAura(MS::Battlegrounds::Spells::DeserterBuff))
        return false;

    return true;
}

bool Player::CanReportAfkDueToLimit()
{
    // a player can complain about 15 people per 5 minutes
    if (m_bgData.bgAfkReportedCount++ >= 15)
        return false;

    return true;
}

///This player has been blamed to be inactive in a battleground
void Player::ReportedAfkBy(Player* reporter)
{
    Battleground* bg = GetBattleground();
    // Battleground also must be in progress!
    if (!bg || bg != reporter->GetBattleground() || GetTeam() != reporter->GetTeam() || bg->GetStatus() != STATUS_IN_PROGRESS)
        return;

    // check if player has 'Idle' or 'Inactive' debuff
    if (m_bgData.bgAfkReporter.find(reporter->GetGUIDLow()) == m_bgData.bgAfkReporter.end() && !HasAura(43680) && !HasAura(43681) && reporter->CanReportAfkDueToLimit())
    {
        m_bgData.bgAfkReporter.insert(reporter->GetGUIDLow());
        // 5 players have to complain to apply debuff
        if (m_bgData.bgAfkReporter.size() >= 5)
        {
            // cast 'Idle' spell
            //CastSpell(this, 43680, true);
            m_bgData.bgAfkReporter.clear();
#ifndef CROSS
            LeaveBattleground();
#else /* CROSS */

            // afk player not allowed in battleground
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
            bg->RemoveFromInterRealm(GetGUID());
#endif /* CROSS */
        }
    }
}

WorldLocation Player::GetStartPosition() const
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    uint32 mapId = info->mapId;
    if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
        mapId = 0;
    return WorldLocation(mapId, info->positionX, info->positionY, info->positionZ, 0);
}

WorldLocation Player::GetPreviousLocation() const
{
    return WorldLocation(m_PreviousLocationMapId, m_PreviousLocationX, m_PreviousLocationY, m_PreviousLocationZ, m_PreviousLocationO);
}

bool Player::IsNeverVisible() const
{
    if (Unit::IsNeverVisible())
        return true;

    if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
        return true;

    return false;
}

bool Player::CanAlwaysSee(WorldObject const* obj) const
{
    // Always can see self
    if (m_mover == obj)
        return true;

    if (uint64 guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT))
        if (obj->GetGUID() == guid)
            return true;

    return false;
}

bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
{
    if (Unit::IsAlwaysDetectableFor(seer))
        return true;

    if (const Player* seerPlayer = seer->ToPlayer())
        if (IsGroupVisibleFor(seerPlayer))
            return !(seerPlayer->m_Duel && seerPlayer->m_Duel->startTime != 0 && seerPlayer->m_Duel->opponent == this);

     return false;
 }

bool Player::IsVisibleGloballyFor(Player* u) const
{
    if (!u)
        return false;

    // Always can see self
    if (u == this)
        return true;

    // Visible units, always are visible for all players
    if (IsVisible())
        return true;

    // GMs are visible for higher gms (or players are visible for gms)
    if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
        return GetSession()->GetSecurity() <= u->GetSession()->GetSecurity();

    // non faction visibility non-breakable for non-GMs
    if (!IsVisible())
        return false;

    // non-gm stealth/invisibility not hide from global player lists
    return true;
}

template<class T>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, T* target, std::set<Unit*>& /*v*/)
{
    s64.insert(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, GameObject* target, std::set<Unit*>& /*v*/)
{
    // But exclude stoppable elevators from this hack - they would be teleporting from one end to another
    // if affected transports move so far horizontally that it causes them to run out of visibility range then you are out of luck
    // fix visibility instead of adding hacks here
    if (!target->IsTransport())
        s64.insert(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, Creature* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<>
inline void UpdateVisibilityOf_helper(GuidUnorderedSet& s64, Player* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<class T>
inline void BeforeVisibilityDestroy(T* /*t*/, Player* /*p*/)
{
}

template<>
inline void BeforeVisibilityDestroy<Creature>(Creature* t, Player* p)
{
    if (p->GetPetGUID() == t->GetGUID() && t->ToCreature()->isPet())
        t->ToPet()->Remove(PET_SLOT_OTHER_PET, true, t->ToPet()->m_Stampeded);
}

void Player::UpdateVisibilityOf(WorldObject* target)
{
    if (HaveAtClient(target))
    {
        if (!canSeeOrDetect(target, false, true))
        {
            if (target->GetTypeId() == TYPEID_UNIT)
                BeforeVisibilityDestroy<Creature>(target->ToCreature(), this);

            target->DestroyForPlayer(this);
            m_clientGUIDs.erase(target->GetGUID());
            m_VignetteMgr.OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else
    {
        if (canSeeOrDetect(target, false, true))
        {
            target->SendUpdateToPlayer(this);
            m_clientGUIDs.insert(target->GetGUID());
            m_VignetteMgr.OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif

            // target aura duration for caster show only if target exist at caster client
            // send data at target visibility change (adding to client)
            if (target->isType(TYPEMASK_UNIT))
                SendInitialVisiblePackets((Unit*)target);
        }
    }
}

void Player::UpdateTriggerVisibility()
{
    if (m_clientGUIDs.empty())
        return;

    if (!IsInWorld())
        return;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (auto itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_CREATURE_GUID(*itr))
        {
            Creature* obj = GetMap()->GetCreature(*itr);
            if (!obj || (!obj->isTrigger() && !obj->HasAuraType(SPELL_AURA_TRANSFORM) && !obj->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE)))
                continue;

            obj->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            obj->BuildValuesUpdateBlockForPlayer(&udata, this);
            obj->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
        else if (IS_GAMEOBJECT_GUID((*itr)))
        {
            GameObject* go = GetMap()->GetGameObject(*itr);
            if (!go)
                continue;

            go->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            go->BuildValuesUpdateBlockForPlayer(&udata, this);
            go->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
    }
    if (!udata.HasData())
        return;

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::SendInitialVisiblePackets(Unit* p_Target)
{
    SendAurasForTarget(p_Target);

    if (p_Target->isAlive())
    {
        if (p_Target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && p_Target->getVictim())
            p_Target->SendMeleeAttackStart(p_Target->getVictim());
    }
}

template<class T>
void Player::UpdateVisibilityOf(T* p_Target, UpdateData& p_UpdData, std::set<Unit*>& p_VisibleNow)
{
    if (HaveAtClient(p_Target))
    {
        if (!canSeeOrDetect(p_Target, false, true))
        {
            BeforeVisibilityDestroy<T>(p_Target, this);

            p_Target->BuildOutOfRangeUpdateBlock(&p_UpdData);
            m_clientGUIDs.erase(p_Target->GetGUID());
            m_VignetteMgr.OnWorldObjectDisappear(p_Target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is out of range for player %u. Distance = %f", p_Target->GetGUIDLow(), p_Target->GetTypeId(), p_Target->GetEntry(), GetGUIDLow(), GetDistance(p_Target));
            #endif
        }
    }
    else
    {
        if (canSeeOrDetect(p_Target, false, true))
        {
            p_Target->BuildCreateUpdateBlockForPlayer(&p_UpdData, this);
            UpdateVisibilityOf_helper(m_clientGUIDs, p_Target, p_VisibleNow);
            m_VignetteMgr.OnWorldObjectAppear(p_Target);

            #ifdef TRINITY_DEBUG
                sLog->outDebug(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is visible now for player %u. Distance = %f", p_Target->GetGUIDLow(), p_Target->GetTypeId(), p_Target->GetEntry(), GetGUIDLow(), GetDistance(p_Target));
            #endif
        }
    }
}

template void Player::UpdateVisibilityOf(Player*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Creature*      target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Corpse*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(GameObject*    target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(DynamicObject* target, UpdateData& data, std::set<Unit*>& visibleNow);

void Player::UpdateVisibilityForPlayer()
{
    // updates visibility of all objects around point of view for current player
    JadeCore::VisibleNotifier notifier(*this);
    m_seer->VisitNearbyObject(GetSightRange(), notifier, true);
    notifier.SendToSelf();   // send gathered data
}

void Player::InitPrimaryProfessions()
{
    SetFreePrimaryProfessions(sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL));
}

void Player::ModifyMoney(int64 d)
{
    sScriptMgr->OnPlayerMoneyChanged(this, d);

    if (d < 0)
        SetMoney (GetMoney() > uint64(-d) ? GetMoney() + d : 0);
    else
    {
        uint64 newAmount = 0;
        if (GetMoney() < uint64(MAX_MONEY_AMOUNT - d))
            newAmount = GetMoney() + d;
        else
        {
            // "At Gold Limit"
            newAmount = MAX_MONEY_AMOUNT;
            if (d)
                SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD, NULL, NULL);
        }
        SetMoney(newAmount);
    }
}

Unit* Player::GetSelectedUnit() const
{
    if (m_curSelection)
        return ObjectAccessor::GetUnit(*this, m_curSelection);
    return NULL;
}

Player* Player::GetSelectedPlayer() const
{
    if (m_curSelection)
        return ObjectAccessor::GetPlayer(*this, m_curSelection);
    return NULL;
}

void Player::SetGroup(Group* group, int8 subgroup)
{
    if (group == NULL)
        m_group.unlink();
    else
    {
        // never use SetGroup without a subgroup unless you specify NULL for group
        ASSERT(subgroup >= 0);
        m_group.link(group, this);
        m_group.setSubGroup((uint8)subgroup);
    }

    UpdateObjectVisibility(false);
}

void Player::SendInitialPacketsBeforeAddToMap()
{
#ifndef CROSS
    /// Pass 'this' as argument because we're not stored in ObjectAccessor yet
    GetSocial()->SendSocialList(this);
#endif

    // Guild bank list wtf?

    // Homebind
    WorldPacket l_Data(SMSG_BIND_POINT_UPDATE, 5 * 4);
    l_Data << m_homebindX << m_homebindY << m_homebindZ;
    l_Data << uint32(m_homebindMapId);
    l_Data << uint32(m_homebindAreaId);
    GetSession()->SendPacket(&l_Data);

    // SMSG_SET_PROFICIENCY
    // SMSG_SET_PCT_SPELL_MODIFIER
    // SMSG_SET_FLAT_SPELL_MODIFIER
    // SMSG_UPDATE_AURA_DURATION

    SendTalentsInfoData(false);

    SendKnownSpells();

    //4374 - summon pet spell in packet - 111896, 111895, 111859, 111897, 111898
    //5376

    SendInitialActionButtons();
    m_reputationMgr.SendInitialReputations();
    m_achievementMgr.SendAllAchievementData(this);

    SendEquipmentSetList();

    l_Data.Initialize(SMSG_LOGIN_SET_TIME_SPEED, 4 * 5);
    l_Data << uint32(MS::Utilities::WowTime::Encode(sWorld->GetGameTime())); // server hour    ServerTime
    l_Data << uint32(MS::Utilities::WowTime::Encode(sWorld->GetGameTime())); // local hour     GameTime
    l_Data << float(0.01666667f);                                 // game speed     NewSpeed
    l_Data << uint32(1);                                          // added in 5.4.0 GameTimeHolidayOffset or ServerTimeHolidayOffset
    l_Data << uint32(1);                                          // added in 3.1.2 GameTimeHolidayOffset or ServerTimeHolidayOffset
    GetSession()->SendPacket(&l_Data);

    bool l_IsInInstance = GetMap()->GetMapDifficulty() ? GetMap()->GetMapDifficulty()->MaxPlayers : false;

    l_Data.Initialize(SMSG_WORLD_SERVER_INFO, 4 * 5);
    l_Data << uint32(GetMap()->GetDifficultyID());                            ///< DifficultyID
    l_Data << uint8(0);                                                       ///< Is Tournament Realm
    l_Data << uint32(sWorld->GetNextWeeklyQuestsResetTime() - (2 * WEEK));    ///< Last Weekly Reset
    l_Data.WriteBit(false);                                                   ///< Has Restricted Account Max Level
    l_Data.WriteBit(false);                                                   ///< Has Restricted Account Max Money
    l_Data.WriteBit(false);                                                   ///< Has Ineligible For Loot Mask
    l_Data.WriteBit(l_IsInInstance);                                          ///< Has Instance Group Size

    if (l_IsInInstance)
        l_Data << uint32(GetMap()->GetPlayers().getSize());

    GetSession()->SendPacket(&l_Data);

    l_Data.Initialize(SMSG_INITIAL_SETUP, 2062);
    l_Data << uint8(sWorld->getIntConfig(CONFIG_EXPANSION));      ///< Server Expansion Level
    l_Data << uint8(0);                                           ///< Server Expansion Tier
    l_Data << uint32(sWorld->GetServerRegionID());                ///< Server Region ID
    l_Data << uint32(sWorld->GetServerRaidOrigin());              ///< Raid origin
    GetSession()->SendPacket(&l_Data);

    if (Pet* l_Pet = GetPet())
    {
        l_Data.Initialize(SMSG_PET_GUIDS);
        l_Data << uint32(1);
        l_Data.appendPackGUID(l_Pet->GetGUID());
        GetSession()->SendPacket(&l_Data);
    }

    // SMSG_TALENTS_INFO x 2 for pet (unspent points and talents in separate packets...)
    // SMSG_UPDATE_WORLD_STATE
    // SMSG_POWER_UPDATE

    SendCurrencies();
    SetMover(this);

    /// Unlock WoD heroic dungeons
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37213))   ///< FLAG - Proving Grounds - Damage Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33090))   ///< FLAG - Proving Grounds - Damage Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33096))   ///< FLAG - Proving Grounds - Healer Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37219))   ///< FLAG - Proving Grounds - Healer Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(37216))   ///< FLAG - Proving Grounds - Tank Silver
        SetQuestBit(l_QuestBit, true);
    if (uint32 l_QuestBit = GetQuestUniqueBitFlag(33093))   ///< FLAG - Proving Grounds - Tank Silver
        SetQuestBit(l_QuestBit, true);
}

void Player::SendSpellHistory()
{
    uint64 l_CurTime = 0;
    ACE_OS::gettimeofday().msec(l_CurTime);

    WorldPacket l_HistoryData(SMSG_SEND_SPELL_HISTORY, 2 * 1024);
    l_HistoryData << uint32(GetSpellCooldownMap().size());

    for (SpellCooldowns::const_iterator l_Itr = GetSpellCooldownMap().begin(); l_Itr != GetSpellCooldownMap().end(); ++l_Itr)
    {
        l_HistoryData << uint32(l_Itr->first);
        l_HistoryData << uint32(l_Itr->second.itemid);

        bool l_HasCooldown = l_Itr->second.end > l_CurTime;

        uint32 l_Category             = 0;
        uint32 l_CategoryRecoveryTime = 0;
        uint32 l_RecoveryTime         = l_Itr->second.end - l_CurTime;

        if (ItemTemplate const* l_ItemProto = sObjectMgr->GetItemTemplate(l_Itr->second.itemid))
        {
            for (uint8 l_I = 0; l_I < MAX_ITEM_SPELLS; ++l_I)
            {
                if (uint32(l_ItemProto->Spells[l_I].SpellId) == l_Itr->first)
                {
                    l_Category             = l_ItemProto->Spells[l_I].SpellCategory;
                    l_CategoryRecoveryTime = l_ItemProto->Spells[l_I].SpellCategoryCooldown;
                    break;
                }
            }
        }

        l_HistoryData << uint32(l_Category);
        l_HistoryData << uint32(l_HasCooldown ? l_RecoveryTime : 0);
        l_HistoryData << uint32(l_CategoryRecoveryTime);

        l_HistoryData.FlushBits();

        l_HistoryData.WriteBit(false);  ///< OnHold
    }

    GetSession()->SendPacket(&l_HistoryData);
}

void Player::SendInitialPacketsAfterAddToMap()
{
    UpdateVisibilityForPlayer();

    // update zone
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea, true);
    UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();

    ResetTimeSync();
    SendTimeSync();

    CastSpell(this, 836, true);                             // LOGINEFFECT

    // set some aura effects that send packet to player client after add player to map
    // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
    // same auras state lost at far teleport, send it one more time in this case also
    static const AuraType auratypes[] =
    {
        SPELL_AURA_MOD_FEAR,     SPELL_AURA_TRANSFORM,                 SPELL_AURA_WATER_WALK,
        SPELL_AURA_FEATHER_FALL, SPELL_AURA_HOVER,                     SPELL_AURA_SAFE_FALL,
        SPELL_AURA_FLY,          SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED, SPELL_AURA_NONE
    };
    for (AuraType const* itr = &auratypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        Unit::AuraEffectList const& auraList = GetAuraEffectsByType(*itr);
        if (!auraList.empty())
            auraList.front()->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
    }

    SendRefreshSpellMods();

    RemoveAllMovementForces();

    if (HasAuraType(SPELL_AURA_MOD_STUN))
        SetRooted(true);

    // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
    if (HasAuraType(SPELL_AURA_MOD_ROOT) || HasAuraType(SPELL_AURA_MOD_ROOT_2))
        SendMoveRoot(0);

    SendSpellHistory();
    SendSpellCharges();
    SendAurasForTarget(this);
    SendEnchantmentDurations();                             // must be after add to map
    SendItemDurations();                                    // must be after add to map

    CutOffItemLevel(false);
    RescaleAllItemsIfNeeded(true);

    ApplyWargameItemModifications();

    AuraEffectList const& l_ModSpeedAuras = GetAuraEffectsByType(SPELL_AURA_MOD_SPEED_ALWAYS);
    for (AuraEffectList::const_iterator iter = l_ModSpeedAuras.begin(); iter != l_ModSpeedAuras.end(); iter++)
        (*iter)->RecalculateAmount((*iter)->GetCaster(), true);

    if (GetMap()->IsRaid())
    {
        m_PrevMapDifficulty = GetMap()->GetDifficultyID();
        if (DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(m_PrevMapDifficulty))
            SendRaidDifficulty((l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0, m_PrevMapDifficulty);
    }
    else if (GetMap()->IsNonRaidDungeon())
    {
        m_PrevMapDifficulty = GetMap()->GetDifficultyID();
        SendDungeonDifficulty(m_PrevMapDifficulty);
    }
    else if (!GetMap()->Instanceable())
    {
        if (DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(m_PrevMapDifficulty))
            SendRaidDifficulty((l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0);
    }

    GetSession()->SendBattlePetJournal();

    if (GetSkillValue(SKILL_ARCHAEOLOGY))
    {
        m_archaeologyMgr.PropagateResearchSites();
        m_archaeologyMgr.PropagateResearchProjects();
    }

    SendDeathRuneUpdate();

    if (getClass() == CLASS_HUNTER)
        GetSession()->SendStablePet(0);

    // Hack fix for remove flags auras after crash
    if (!GetMap()->IsBattlegroundOrArena())
        RemoveFlagsAuras();

    // Hack fix for AURA_STATE_PVP_PREPARATION.
    if (GetBattleground() && GetBattleground()->GetStatus() == BattlegroundStatus::STATUS_WAIT_JOIN)
        ModifyAuraState(AURA_STATE_PVP_RAID_PREPARE, true);

    /// Fix ghost group leader flag
    if (!GetGroup() || !GetGroup()->IsLeader(GetGUID()))
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);

    WorldPacket l_NullPacket;
    GetSession()->HandleLfgGetStatus(l_NullPacket);

#ifndef CROSS
    /// Force map shift update
    if ((GetMapId() == MS::Garrison::Globals::BaseMap && m_Garrison) || IsInGarrison())
    {
        phaseMgr.Update();
        phaseMgr.ForceMapShiftUpdate();
    }

    if (IsInGarrison())
        m_Garrison->OnPlayerEnter();
#endif

    std::map<uint32, bool> l_MountSpells;
    for (PlayerSpellMap::iterator l_It = m_spells.begin(); l_It != m_spells.end(); l_It++)
    {
        if (!l_It->second)
            continue;

        if (const SpellInfo * spell = sSpellMgr->GetSpellInfo(l_It->first))
        {
            if (spell->IsAbilityOfSkillType(SKILL_MOUNT) || spell->AttributesEx10 & SPELL_ATTR10_MOUNT_IS_NOT_ACCOUNT_WIDE)
            {
                l_MountSpells[l_It->first] = l_It->second->IsMountFavorite;
            }
        }
    }

    WorldPacket l_Data(SMSG_ACCOUNT_MOUNT_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);                      ///< Is full update
    l_Data.FlushBits();
    l_Data << uint32(l_MountSpells.size());
    l_Data << uint32(l_MountSpells.size());

    for (auto l_Pair : l_MountSpells)
        l_Data << uint32(l_Pair.first);

    for (auto l_Pair : l_MountSpells)
        l_Data.WriteBit(l_Pair.second);

    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
    GetSession()->SendTwitterStatus(true);

     if (Group* l_Group = GetGroup())
         l_Group->SendUpdate();

     sLFGListMgr->OnPlayerLogin(this);
}

void Player::SendUpdateToOutOfRangeGroupMembers()
{
    if (m_groupUpdateMask == GROUP_UPDATE_FLAG_NONE)
        return;
    if (Group* group = GetGroup())
        group->UpdatePlayerOutOfRange(this);

    m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;
    m_auraRaidUpdateMask = 0;
    if (Pet* pet = GetPet())
        pet->ResetAuraUpdateMaskForRaid();
}

void Player::SendTransferAborted(uint32 mapid, TransferAbortReason reason, uint8 arg)
{
    WorldPacket data(SMSG_TRANSFER_ABORTED, 4 + 2);
    data << uint32(mapid);
    data << uint8(arg);
    data.WriteBits(reason, 5);
    data.FlushBits();

    GetSession()->SendPacket(&data);
}

void Player::SendRaidInstanceMessage(uint32 p_MapID, Difficulty p_Difficulty, uint32 p_Time)
{
    // Type of warning, based on the time remaining until reset
    uint32 l_Type;
    if (p_Time > 3600)
        l_Type = RAID_INSTANCE_WELCOME;
    else if (p_Time > 900 && p_Time <= 3600)
        l_Type = RAID_INSTANCE_WARNING_HOURS;
    else if (p_Time > 300 && p_Time <= 900)
        l_Type = RAID_INSTANCE_WARNING_MIN;
    else
        l_Type = RAID_INSTANCE_WARNING_MIN_SOON;

    WorldPacket l_Data(SMSG_RAID_INSTANCE_MESSAGE, 1 + 4 * 3 + 1);
    l_Data << uint8(l_Type);
    l_Data << uint32(p_MapID);
    l_Data << uint32(p_Difficulty);
    l_Data << int32(p_Time);

    l_Data.WriteBit(0);                                   // is locked
    l_Data.WriteBit(0);                                   // is extended, ignored if prev field is 0
    l_Data.FlushBits();
    GetSession()->SendPacket(&l_Data);
}

void Player::SendInstanceGroupSizeChanged(uint32 p_Size)
{
    WorldPacket l_Data(Opcodes::SMSG_INSTANCE_GROUP_SIZE_CHANGED, 4);
    l_Data << uint32(p_Size);
    GetSession()->SendPacket(&l_Data);
}

void Player::HandleItemSetBonuses(bool p_Apply)
{
    for (uint8 l_I = 0; l_I < InventorySlots::INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (m_items[l_I])
        {
            ItemTemplate const* l_Proto = m_items[l_I]->GetTemplate();
            if (!l_Proto)
                continue;

            if (l_Proto->ItemSet)
            {
                if (p_Apply)
                    AddItemsSetItem(this, m_items[l_I]);
                else
                    RemoveItemsSetItem(this, l_Proto);
            }
        }
    }
}

void Player::HandleGemBonuses(bool p_Apply)
{
    for (uint8 l_I = 0; l_I < InventorySlots::INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            if (!l_Item->IsEquipped())
                continue;

            for (uint32 l_EnchantSlot = EnchantmentSlot::SOCK_ENCHANTMENT_SLOT; l_EnchantSlot < EnchantmentSlot::SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++l_EnchantSlot)
                ApplyEnchantment(l_Item, EnchantmentSlot(l_EnchantSlot), p_Apply);
        }
    }
}

void Player::ApplyEquipCooldown(Item* p_Item)
{
    if (p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_NO_EQUIP_COOLDOWN))
        return;

    for (uint8 l_I = 0; l_I < MAX_ITEM_PROTO_SPELLS; ++l_I)
    {
        _Spell const& l_SpellData = p_Item->GetTemplate()->Spells[l_I];

        // no spell
        if (!l_SpellData.SpellId)
            continue;

        // wrong triggering type (note: ITEM_SPELLTRIGGER_ON_NO_DELAY_USE not have cooldown)
        if (l_SpellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        //! Don't replace longer cooldowns by equi cooldown if we have any.
        SpellCooldowns::iterator l_It = m_spellCooldowns.find(l_SpellData.SpellId);

        if (l_It != m_spellCooldowns.end() && l_It->second.itemid == p_Item->GetEntry() && l_It->second.end > uint64((time(NULL) + 30) * IN_MILLISECONDS))
            continue;

        AddSpellCooldown(l_SpellData.SpellId, p_Item->GetEntry(), 30 * IN_MILLISECONDS);

        WorldPacket l_Data(SMSG_ITEM_COOLDOWN, 12);
        l_Data.appendPackGUID(p_Item->GetGUID());
        l_Data << uint32(l_SpellData.SpellId);
        GetSession()->SendPacket(&l_Data);
    }
}

void Player::resetSpells(bool myClassOnly)
{
    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_SPELLS, true);

    // make full copy of map (spells removed and marked as deleted at another spell remove
    // and we can't use original map for safe iterative with visit each spell at loop end
    PlayerSpellMap smap = GetSpellMap();

    uint32 family;

    if (myClassOnly)
    {
        ChrClassesEntry const* clsEntry = sChrClassesStore.LookupEntry(getClass());
        if (!clsEntry)
            return;
        family = clsEntry->SpellClassSet;

        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(iter->first);
            if (!spellInfo)
                continue;

            // skip server-side/triggered spells
            if (spellInfo->SpellLevel == 0)
                continue;

            // skip wrong class/race skills
            if (!IsSpellFitByClassAndRace(spellInfo->Id))
                continue;

            // skip other spell families
            if (spellInfo->SpellFamilyName != family)
                continue;

            // skip broken spells
            if (!SpellMgr::IsSpellValid(spellInfo, this, false))
                continue;
        }
    }
    else
        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
            removeSpell(iter->first, false, false);           // only iter->first can be accessed, object by iter->second can be deleted already

    learnDefaultSpells();
    learnQuestRewardedSpells();
}

void Player::learnDefaultSpells()
{
    // learn default race/class spells
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    for (PlayerCreateInfoSpells::const_iterator itr = info->customSpells.begin(); itr != info->customSpells.end(); ++itr)
    {
        uint32 tspell = *itr;
        sLog->outDebug(LOG_FILTER_PLAYER_LOADING, "PLAYER (Class: %u Race: %u): Adding initial spell, id = %u", uint32(getClass()), uint32(getRace()), tspell);
        if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
            addSpell(tspell, true, true, true, false);
        else                                                // but send in normal spell in game learn case
            learnSpell(tspell, true);
    }

    if (getRace() == RACE_PANDAREN_HORDE)
    {
        uint32 spellLangHorde[2] = {669, 108127};
        for (int i = 0; i < 2; i++)
        {
            if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
                addSpell(spellLangHorde[i], true, true, true, false);
            else                                                // but send in normal spell in game learn case
                learnSpell(spellLangHorde[i], true);
        }
    }

    if (getRace() == RACE_PANDAREN_ALLI)
    {
        uint32 spellLangAlliance[2] = {668,108127};
        for (int i = 0; i < 2; i++)
        {
            if (!IsInWorld())                                    // will send in INITIAL_SPELLS in list anyway at map add
                addSpell(spellLangAlliance[i], true, true, true, false);
            else                                                // but send in normal spell in game learn case
                learnSpell(spellLangAlliance[i], true);
        }
    }
}

void Player::learnQuestRewardedSpells(Quest const* quest)
{
    int32 spell_id = quest->GetRewSpellCast();
    uint32 src_spell_id = quest->GetSrcSpell();

    // skip quests without rewarded spell
    if (!spell_id)
        return;

    // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
    if (spell_id == -1 && src_spell_id)
    {
        RemoveAurasDueToSpell(src_spell_id);
        return;
    }

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return;

    // check learned spells state
    bool found = false;
    for (uint8 i = 0; i < spellInfo->EffectCount; ++i)
    {
        if (spellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL && !HasSpell(spellInfo->Effects[i].TriggerSpell))
        {
            found = true;
            break;
        }
    }

    // skip quests with not teaching spell or already known spell
    if (!found)
        return;

    uint32 learned_0 = spellInfo->Effects[0].TriggerSpell;
    if (!HasSpell(learned_0))
    {
        SpellInfo const* learnedInfo = sSpellMgr->GetSpellInfo(learned_0);
        if (!learnedInfo)
            return;

        // profession specialization can be re-learned from npc
        if (learnedInfo->Effects[0].Effect == SPELL_EFFECT_TRADE_SKILL && learnedInfo->Effects[1].Effect == 0 && !learnedInfo->SpellLevel)
            return;
    }

    CastSpell(this, spell_id, true);
}

void Player::learnQuestRewardedSpells()
{
    // learn spells received from quest completing
    for (RewardedQuestSet::const_iterator itr = m_RewardedQuests.begin(); itr != m_RewardedQuests.end(); ++itr)
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(*itr);
        if (!quest)
            continue;

        learnQuestRewardedSpells(quest);
    }
}

void Player::learnSkillRewardedSpells(uint32 skill_id, uint32 skill_value)
{
    uint32 raceMask  = getRaceMask();
    uint32 classMask = getClassMask();
    for (uint32 j=0; j<sSkillLineAbilityStore.GetNumRows(); ++j)
    {
        SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j);
        if (!pAbility || pAbility->skillId != skill_id || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
            continue;
        // Check race if set
        if (pAbility->racemask && !(pAbility->racemask & raceMask))
            continue;
        // Check class if set
        if (pAbility->classmask && !(pAbility->classmask & classMask))
            continue;

        if (sSpellMgr->GetSpellInfo(pAbility->spellId))
        {
            // need unlearn spell
            if (skill_value < pAbility->req_skill_value)
                removeSpell(pAbility->spellId);
            // need learn
            else if (!IsInWorld())
                addSpell(pAbility->spellId, true, true, true, false);
            else
                learnSpell(pAbility->spellId, true);
        }
    }
}

void Player::SendAurasForTarget(Unit* p_Target)
{
    if (!p_Target || p_Target->GetVisibleAuras()->empty())                  // speedup things
        return;

    /// Blizz sends certain movement packets sometimes even before CreateObject
    if (p_Target->HasAuraType(SPELL_AURA_FEATHER_FALL))
        p_Target->SetFeatherFall(true, true);

    if (p_Target->HasAuraType(SPELL_AURA_WATER_WALK))
        p_Target->SetWaterWalking(true, true);

    if (p_Target->HasAuraType(SPELL_AURA_HOVER))
        p_Target->SetHover(true, true);

    Unit::VisibleAuraMap const* l_VisibleAuras = p_Target->GetVisibleAuras();

    uint32 l_AuraCount = 0;
    for (Unit::VisibleAuraMap::const_iterator itr = l_VisibleAuras->begin(); itr != l_VisibleAuras->end(); ++itr)
    {
        AuraApplication * l_AuraApplication = itr->second;

        if (!l_AuraApplication || !l_AuraApplication->GetBase())
            continue;

        ++l_AuraCount;
    }

    WorldPacket l_Data(SMSG_AURA_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);                          ///< Update All
    l_Data.FlushBits();
    l_Data.appendPackGUID(p_Target->GetGUID());     ///< Unit GUID
    l_Data << uint32(l_AuraCount);                  ///< Auras count

    if (l_AuraCount)
    {
        for (Unit::VisibleAuraMap::const_iterator l_It = l_VisibleAuras->begin(); l_It != l_VisibleAuras->end(); ++l_It)
        {
            AuraApplication * l_AuraApplication = l_It->second;

            if (!l_AuraApplication || !l_AuraApplication->GetBase())
                continue;

            l_AuraApplication->BuildUpdatePacket(l_Data, false);
        }
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::SetDailyQuestStatus(uint32 quest_id)
{
    if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(quest_id))
    {
        if (!qQuest->IsDFQuest())
        {
            m_dailyQuestStorage.insert(quest_id);
            m_lastDailyQuestTime = time(NULL);              // last daily quest time
            m_DailyQuestChanged = true;

            if (m_dailyQuestStorage.size() - 1 < DynamicFields::Count)
                SetDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED, m_dailyQuestStorage.size() - 1, quest_id);
        }
        else
        {
            m_DFQuests.insert(quest_id);
            m_lastDailyQuestTime = time(NULL);
            m_DailyQuestChanged = true;
        }
    }
}

void Player::SetWeeklyQuestStatus(uint32 quest_id)
{
    m_weeklyquests.insert(quest_id);
    m_WeeklyQuestChanged = true;
}

void Player::SetSeasonalQuestStatus(uint32 quest_id)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
    if (!quest)
        return;

    m_seasonalquests[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
    m_SeasonalQuestChanged = true;
}

void Player::SetMonthlyQuestStatus(uint32 quest_id)
{
    m_monthlyquests.insert(quest_id);
    m_MonthlyQuestChanged = true;
}

void Player::ResetDailyQuestStatus()
{
    m_dailyQuestStorage.clear();

    std::vector<uint32> l_Dailies = GetDynamicValues(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED);
    if (!l_Dailies.empty())
    {
        std::vector<uint32> l_QuestBits;
        for (uint32 questId : l_Dailies)
        {
            if (uint32 questBit = GetQuestUniqueBitFlag(questId))
                l_QuestBits.push_back(questBit);
        }

        if (!l_QuestBits.empty())
            ClearQuestBits(l_QuestBits);
    }

    ClearDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED);
    m_DFQuests.clear(); // Dungeon Finder Quests.

    // DB data deleted in caller
    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    WorldPacket data(SMSG_DAILY_QUESTS_RESET);
    data << uint32(l_Dailies.size());
    GetSession()->SendPacket(&data);
}

#ifndef CROSS
void Player::ResetDailyGarrisonDatas()
{
    using namespace MS::Garrison;

    if (Manager* l_Garrison = GetGarrison())
    {
        if (l_Garrison->HasBuildingType(Building::Type::Inn))
        {
            /// Weekly Tavern Reset is done in World::ResetWeeklyGarrisonDatas

            l_Garrison->ResetGarrisonDailyTavernData();
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(Building::Type::Inn);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(Building::Type::Stable))
        {
            if (uint64 l_Value = GetCharacterWorldStateValue(CharacterWorldStates::GarrisonStablesFirstQuest))
                SetCharacterWorldState(CharacterWorldStates::GarrisonStablesFirstQuest, l_Value &= ~StablesData::g_PendingQuestFlag);

            if (uint64 l_Value = GetCharacterWorldStateValue(CharacterWorldStates::GarrisonStablesSecondQuest))
                SetCharacterWorldState(CharacterWorldStates::GarrisonStablesSecondQuest, l_Value &= ~StablesData::g_PendingQuestFlag);
        }

        if (l_Garrison->HasBuildingType(Building::Type::Workshop))
        {
            l_Garrison->ResetGarrisonWorkshopData(this);
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(Building::Type::Workshop);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(Building::Type::TradingPost))
        {
            l_Garrison->ResetGarrisonTradingPostData(this);
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(Building::Type::TradingPost);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(Building::Type::Mine))
        {
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(Building::Type::Mine);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        if (l_Garrison->HasBuildingType(Building::Type::Farm, true))
        {
            std::vector<uint64> l_CreatureGuids = l_Garrison->GetBuildingCreaturesByBuildingType(Building::Type::Farm, true);

            for (std::vector<uint64>::iterator l_Itr = l_CreatureGuids.begin(); l_Itr != l_CreatureGuids.end(); l_Itr++)
            {
                if (Creature* l_Creature = sObjectAccessor->GetCreature(*this, *l_Itr))
                {
                    if (l_Creature->AI())
                        l_Creature->AI()->SetData(CreatureAIDataIDs::DailyReset, 0);
                }
            }
        }

        l_Garrison->UpdatePlot(GetPlotInstanceID());
    }

    SaveToDB();
}

void Player::ResetWeeklyGarrisonDatas()
{
    using namespace MS::Garrison;

    if (Manager* l_Garrison = GetGarrison())
    {
        ///< Armory token handling
        if (l_Garrison->GetBuildingWithType(Building::Type::Armory).DatabaseID)
        {
            if (GetCharacterWorldStateValue(CharacterWorldStates::GarrisonArmoryWeeklyCurrencyGain) == 1)
                SetCharacterWorldState(CharacterWorldStates::GarrisonArmoryWeeklyCurrencyGain, 0);
        }

        l_Garrison->ResetGarrisonWeeklyTavernData();
    }
}

#endif /* not CROSS */
void Player::ResetWeeklyQuestStatus()
{
    if (m_weeklyquests.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : m_weeklyquests)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_weeklyquests.clear();
    // DB data deleted in caller
    m_WeeklyQuestChanged = false;
}

void Player::ResetSeasonalQuestStatus(uint16 event_id)
{
    auto eventItr = m_seasonalquests.find(event_id);
    if (eventItr == m_seasonalquests.end())
        return;

    if (eventItr->second.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : eventItr->second)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_seasonalquests.erase(eventItr);
    // DB data deleted in caller
    m_SeasonalQuestChanged = false;
}

void Player::ResetMonthlyQuestStatus()
{
    if (m_monthlyquests.empty())
        return;

    std::vector<uint32> l_QuestBits;
    for (uint32 questId : m_monthlyquests)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
            l_QuestBits.push_back(questBit);
    }

    if (!l_QuestBits.empty())
        ClearQuestBits(l_QuestBits);

    m_monthlyquests.clear();
    // DB data deleted in caller
    m_MonthlyQuestChanged = false;
}

Battleground* Player::GetBattleground() const
{
    if (GetBattlegroundId() == 0)
        return NULL;

    return sBattlegroundMgr->GetBattleground(GetBattlegroundId(), MS::Battlegrounds::GetSchedulerType(m_bgData.bgTypeID));
}

bool Player::InArena() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->isArena())
        return false;

    return true;
}

bool Player::InRatedBattleGround() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->IsRatedBG())
        return false;

    return true;
}

bool Player::GetBGAccessByLevel(BattlegroundTypeId bgTypeId) const
{
    // get a template bg instead of running one
    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(MS::Battlegrounds::GetSchedulerType(bgTypeId));
    if (!bg)
        return false;

    // limit check leel to dbc compatible level range
    uint32 level = getLevel();
    if (level > DEFAULT_MAX_LEVEL)
        level = DEFAULT_MAX_LEVEL;

    if (level < bg->GetMinLevel() || level > bg->GetMaxLevel())
        return false;

    return true;
}

float Player::GetReputationPriceDiscount(Creature const* creature) const
{
    FactionTemplateEntry const* vendor_faction = creature->getFactionTemplateEntry();
    if (!vendor_faction || !vendor_faction->Faction)
        return 1.0f;

    ReputationRank rank = GetReputationRank(vendor_faction->Faction);
    if (rank <= REP_NEUTRAL)
        return 1.0f;

    return 1.0f - 0.05f* (rank - REP_NEUTRAL);
}

bool Player::IsSpellFitByClassAndRace(uint32 p_SpellId) const
{
    uint32 l_RaceMask  = getRaceMask();
    uint32 l_ClassMask = getClassMask();
    auto l_Spellinfo   = sSpellMgr->GetSpellInfo(p_SpellId);

    if (l_Spellinfo == nullptr)
        return false;

    SkillLineAbilityMapBounds l_Bounds = sSpellMgr->GetSkillLineAbilityMapBounds(p_SpellId);
    if (l_Bounds.first == l_Bounds.second)
        return true;

    for (SkillLineAbilityMap::const_iterator l_SpellIdx = l_Bounds.first; l_SpellIdx != l_Bounds.second; ++l_SpellIdx)
    {
        // Hackfix, Gift of the Naaru for Monks (121093) doesn't have a racemask for only Draenei
        if (p_SpellId == 121093 && l_RaceMask != 1024)
            continue;

        /// Skip horde or alliance only spells
        if ((l_Spellinfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && (l_RaceMask & RACEMASK_HORDE) == 0)
            || (l_Spellinfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && (l_RaceMask & RACEMASK_ALLIANCE) == 0))
            continue;

        // skip wrong race skills
        if (l_SpellIdx->second->racemask && (l_SpellIdx->second->racemask & l_RaceMask) == 0)
            continue;

        // skip wrong class skills
        if (l_SpellIdx->second->classmask && (l_SpellIdx->second->classmask & l_ClassMask) == 0)
            continue;

        return true;
    }

    return false;
}

bool Player::HasQuestForGO(uint32 GOId) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questid);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& qs = qs_itr->second;

        if (qs.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qinfo = sObjectMgr->GetQuestTemplate(questid);
            if (!qinfo)
                continue;

            if (GetGroup() && GetGroup()->isRaidGroup() && !qinfo->IsAllowedInRaid())
                continue;

            for (QuestObjective l_Objective : qinfo->QuestObjectives)
            {
                if (l_Objective.Type == QUEST_OBJECTIVE_TYPE_GO)
                {
                    if (GOId == (uint32)l_Objective.ObjectID && GetQuestObjectiveCounter(l_Objective.ID) < uint32(l_Objective.Amount))
                        return true;
                }
            }
        }
    }
    return false;
}
uint32 Player::GetQuestObjectiveCounter(uint32 objectiveId) const
{
    QuestObjectiveStatusMap::const_iterator citr = m_questObjectiveStatus.find(objectiveId);
        if (citr != m_questObjectiveStatus.end())
            return citr->second;

    return 0;
}

void Player::UpdateForQuestWorldObjects()
{
    if (m_clientGUIDs.empty())
        return;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (auto itr=m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_GAMEOBJECT_GUID(*itr))
        {
            if (GameObject* obj = HashMapHolder<GameObject>::Find(*itr))
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
        else if (IS_CRE_OR_VEH_GUID(*itr))
        {
            Creature* obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *itr);
            if (!obj)
                continue;

            // check if this unit requires quest specific flags
            if (!obj->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
                continue;

            SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(obj->GetEntry());
            for (SpellClickInfoContainer::const_iterator _itr = clickPair.first; _itr != clickPair.second; ++_itr)
            {
                //! This code doesn't look right, but it was logically converted to condition system to do the exact
                //! same thing it did before. It definitely needs to be overlooked for intended functionality.
                if (ConditionContainer const* conds = sConditionMgr->GetConditionsForSpellClickEvent(obj->GetEntry(), _itr->second.spellId))
                {
                    bool buildUpdateBlock = false;
                    for (ConditionContainer::const_iterator jtr = conds->begin(); jtr != conds->end() && !buildUpdateBlock; ++jtr)
                        if ((*jtr)->ConditionType == CONDITION_QUESTREWARDED || (*jtr)->ConditionType == CONDITION_QUESTTAKEN)
                            buildUpdateBlock = true;

                    if (buildUpdateBlock)
                    {
                        obj->BuildValuesUpdateBlockForPlayer(&udata, this);
                        break;
                    }
                }
            }
        }
    }

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::SummonIfPossible(bool agree)
{
    if (!agree)
    {
        m_summon_expire = 0;
        return;
    }

    // expire and auto declined
    if (m_summon_expire < time(NULL))
        return;

    // stop taxi flight at summon
    if (isInFlight())
    {
        GetMotionMaster()->MovementExpired();
        CleanupAfterTaxiFlight();
    }

    // drop flag at summon
    // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
    if (Battleground* bg = GetBattleground())
        bg->EventPlayerDroppedFlag(this);

    m_summon_expire = 0;

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ACCEPTED_SUMMONINGS, 1);

    TeleportTo(m_summon_mapid, m_summon_x, m_summon_y, m_summon_z, GetOrientation());
}

void Player::RemoveItemDurations(Item* item)
{
    for (ItemDurationList::iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
    {
        if (*itr == item)
        {
            m_itemDuration.erase(itr);
            break;
        }
    }
}

void Player::AddItemDurations(Item* item)
{
    if (item->GetUInt32Value(ITEM_FIELD_EXPIRATION))
    {
        m_itemDuration.push_back(item);
        item->SendTimeUpdate(this);
    }
}

void Player::AutoUnequipOffhandIfNeed(bool force /*= false*/)
{
    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!offItem)
        return;

     // unequip offhand weapon if player doesn't have dual wield anymore
     if (!CanDualWield() && (offItem->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND || offItem->GetTemplate()->InventoryType == INVTYPE_WEAPON))
          force = true;

    // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
    if (!force && (CanTitanGrip() || (offItem->GetTemplate()->InventoryType != INVTYPE_2HWEAPON && !IsTwoHandUsed())))
        return;

    ItemPosCountVec off_dest;
    uint8 off_msg = CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false);
    if (off_msg == EQUIP_ERR_OK)
    {
        RemoveItem(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        StoreItem(off_dest, offItem, true);
    }
    else
    {
        MoveItemFromInventory(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        SQLTransaction trans = RealmDatabase.BeginTransaction();
        offItem->DeleteFromInventoryDB(trans);                   // deletes item from character's inventory
        offItem->SaveToDB(trans);                                // recursive and not have transaction guard into self, item not in inventory and can be save standalone

        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
        MailDraft(subject, "There were problems with equipping one or several items").AddItem(offItem).SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);

        RealmDatabase.CommitTransaction(trans);
    }
}

OutdoorPvP* Player::GetOutdoorPvP() const
{
    return sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId());
}

bool Player::HasItemFitToSpellRequirements(SpellInfo const* spellInfo, Item const* ignoreItem) const
{
    if (spellInfo->EquippedItemClass < 0)
        return true;

    // scan other equipped items for same requirements (mostly 2 daggers/etc)
    // for optimize check 2 used cases only
    switch (spellInfo->EquippedItemClass)
    {
        case ITEM_CLASS_WEAPON:
        {
            for (uint8 i= EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;
            break;
        }
        case ITEM_CLASS_ARMOR:
        {
            // tabard not have dependent spells
            for (uint8 i= EQUIPMENT_SLOT_START; i< EQUIPMENT_SLOT_MAINHAND; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;

            // shields can be equipped to offhand slot
            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;

            // ranged slot can have some armor subclasses
            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;

            break;
        }
        default:
            sLog->outError(LOG_FILTER_PLAYER, "HasItemFitToSpellRequirements: Not handled spell requirement for item class %u", spellInfo->EquippedItemClass);
            break;
    }

    return false;
}

bool Player::CanNoReagentCast(SpellInfo const* spellInfo) const
{
    // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
    if (spellInfo->AttributesEx5 & SPELL_ATTR5_NO_REAGENT_WHILE_PREP &&
        HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION))
        return true;

    // Check no reagent use mask
    flag128 noReagentMask;
    noReagentMask[0] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK);
    noReagentMask[1] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+1);
    noReagentMask[2] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+2);
    noReagentMask[3] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+3);
    if (spellInfo->SpellFamilyFlags & noReagentMask)
        return true;

    return false;
}

void Player::RemoveItemDependentAurasAndCasts(Item* pItem)
{
    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* aura = itr->second;

        // skip passive (passive item dependent spells work in another way) and not self applied auras
        SpellInfo const* spellInfo = aura->GetSpellInfo();
        if (aura->IsPassive() ||  aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        // skip if not item dependent or have alternative item
        if (HasItemFitToSpellRequirements(spellInfo, pItem))
        {
            ++itr;
            continue;
        }

        // no alt item, remove aura, restart check
        RemoveOwnedAura(itr);
    }

    // currently casted spells can be dependent from item
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
            if (spell->getState() != SPELL_STATE_DELAYED && !HasItemFitToSpellRequirements(spell->m_spellInfo, pItem))
                InterruptSpell(CurrentSpellTypes(i));
}

void Player::RemoveAuraDependentItem(Item* p_Item)
{
    if (p_Item == nullptr)
        return;

    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* l_Aura = itr->second;

        SpellInfo const* spellInfo = l_Aura->GetSpellInfo();
        if (l_Aura->IsPassive() || l_Aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        if (l_Aura->GetCastItemGUID() == p_Item->GetGUID())
            RemoveOwnedAura(itr);
        else
            ++itr;
    }
}

uint32 Player::GetResurrectionSpellId()
{
    // search priceless resurrection possibilities
    uint32 l_Priority = 0;
    uint32 l_ResurrectSpellID = 0;

    AuraEffectList const& l_DummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
    for (AuraEffectList::const_iterator l_AuraItr = l_DummyAuras.begin(); l_AuraItr != l_DummyAuras.end(); ++l_AuraItr)
    {
        // Soulstone Resurrection                           // prio: 3 (max, non death persistent)
        if (l_Priority < 2 && (*l_AuraItr)->GetId() == 20707)
        {
            l_Priority = 3;
            l_ResurrectSpellID = 3026;
        }
        // Twisting Nether                                  // prio: 2 (max)
        else if ((*l_AuraItr)->GetId() == 23701 && roll_chance_i(10))
        {
            l_Priority = 2;
            l_ResurrectSpellID = 23700;
        }
    }

    // Reincarnation (passive spell)  // prio: 1
    if (l_Priority < 1 && HasSpell(20608) && !HasSpellCooldown(21169))
        l_ResurrectSpellID = 21169;

    return l_ResurrectSpellID;
}

// Used in triggers for check "Only to targets that grant experience or honor" req
bool Player::isHonorOrXPTarget(Unit* victim)
{
    uint8 v_level = victim->getLevel();
    uint8 k_grey  = JadeCore::XP::GetGrayLevel(getLevel());

    // Victim level less gray level
    if (v_level <= k_grey)
        return false;

    if (victim->GetTypeId() == TYPEID_UNIT)
    {
        if (victim->ToCreature()->isTotem() ||
            victim->ToCreature()->isStatue() ||
            victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL)
                return false;
    }
    return true;
}

bool Player::GetsRecruitAFriendBonus(bool forXP)
{
    bool recruitAFriend = false;
    if (getLevel() <= sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL) || !forXP)
    {
        if (Group* group = this->GetGroup())
        {
            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
            {
                Player* player = itr->getSource();
                if (!player)
                    continue;

                if (!player->IsAtRecruitAFriendDistance(this))
                    continue;                               // member (alive or dead) or his corpse at req. distance

                if (forXP)
                {
                    // level must be allowed to get RaF bonus
                    if (player->getLevel() > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
                        continue;

                    // level difference must be small enough to get RaF bonus, UNLESS we are lower level
                    if (player->getLevel() < getLevel())
                        if (uint8(getLevel() - player->getLevel()) > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE))
                            continue;
                }

                bool ARecruitedB = (player->GetSession()->GetRecruiterId() == GetSession()->GetAccountId());
                bool BRecruitedA = (GetSession()->GetRecruiterId() == player->GetSession()->GetAccountId());
                if (ARecruitedB || BRecruitedA)
                {
                    recruitAFriend = true;
                    break;
                }
            }
        }
    }
    return recruitAFriend;
}

void Player::RewardPersonnalCurrencies(Unit* p_Victim)
{
    if (!p_Victim || p_Victim->IsPlayer())
        return;

    if (!p_Victim->ToCreature())
        return;

    if (!p_Victim->ToCreature()->GetEntry())
        return;

    if (uint32 l_TrackingQuestId = Vignette::GetTrackingQuestIdFromWorldObject(p_Victim))
    {
        uint32 l_QuestBit = GetQuestUniqueBitFlag(l_TrackingQuestId);
        if (IsQuestBitFlaged(l_QuestBit))
            return;
    }

    CurrencyOnKillEntry const* l_Curr = sObjectMgr->GetPersonnalCurrencyOnKillEntry(p_Victim->ToCreature()->GetEntry());
    if (!l_Curr)
        return;

    bool l_Result = true;
    if (p_Victim->ToCreature()->AI())
        p_Victim->ToCreature()->AI()->CurrenciesRewarder(l_Result);

    if (!l_Result)
        return;

    for (CurrencyOnKillEntry::const_iterator l_Iter = l_Curr->begin(); l_Iter != l_Curr->end(); ++l_Iter)
    {
        int32 l_Pct = 100;
        Unit::AuraEffectList const& l_Auras = GetAuraEffectsByType(SPELL_AURA_MOD_CURRENCY_GAIN_PCT);
        for (Unit::AuraEffectList::const_iterator l_I = l_Auras.begin(); l_I != l_Auras.end(); ++l_I)
        {
            if (l_Iter->first == (*l_I)->GetMiscValue()) ///< Comparison of integers of different signs: 'const unsigned int' and 'int32' (aka 'int')
                l_Pct += (*l_I)->GetAmount();
        }

        ModifyCurrency(l_Iter->first, CalculatePct(l_Iter->second, l_Pct));
    }
}

void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
{
    if (Group *pGroup = GetGroup())
    {
        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* pGroupGuy = itr->getSource();
            if (IsInMap(pGroupGuy))
                pGroupGuy->RewardCurrencyAtKill(victim);
        }
    }
    else
        RewardCurrencyAtKill(victim);

    KillRewarder(this, victim, isBattleGround).Reward();
}

void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
{
    if (!pRewardSource)
        return;
    uint64 creature_guid = (pRewardSource->GetTypeId() == TYPEID_UNIT) ? pRewardSource->GetGUID() : uint64(0);

    // prepare data for near group iteration
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* player = itr->getSource();
            if (!player)
                continue;

            if (!player->IsAtGroupRewardDistance(pRewardSource))
                continue;                               // member (alive or dead) or his corpse at req. distance

            // quest objectives updated only for alive group member or dead but with not released body
            if (player->isAlive()|| !player->GetCorpse())
                player->KilledMonsterCredit(creature_id, creature_guid);
        }
    }
    else                                                    // if (!group)
        KilledMonsterCredit(creature_id, creature_guid);
}

bool Player::IsAtGroupRewardDistance(WorldObject const* pRewardSource) const
{
    if (!pRewardSource)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || isAlive())
        player = this;

    if (player->GetMapId() != pRewardSource->GetMapId() || player->GetInstanceId() != pRewardSource->GetInstanceId())
        return false;

    if (Map* l_Map = pRewardSource->GetMap())
    {
        if (l_Map->IsDungeon() || l_Map->IsRaid())
            return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_INSTANCE_GROUP_XP_DISTANCE);
    }

    return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE);
}

bool Player::IsAtRecruitAFriendDistance(WorldObject const* pOther) const
{
    if (!pOther)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || isAlive())
        player = this;

    if (player->GetMapId() != pOther->GetMapId() || player->GetInstanceId() != pOther->GetInstanceId())
        return false;

    return pOther->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE);
}

void Player::ResurectUsingRequestData()
{
    if (_resurrectionData->ResSpell != nullptr && _resurrectionData->ResSpell->IsBattleResurrection())
    {
        if (InstanceScript* l_InstanceScript = GetInstanceScript())
        {
            if (l_InstanceScript->CanUseCombatResurrection())
                l_InstanceScript->ConsumeCombatResurrectionCharge();
            else
            {
                /// Resurrecting - 60s aura preventing client from new res spells
                RemoveAura(160029);
                ClearResurrectRequestData();
                SendGameError(GameError::ERR_SPELL_FAILED_S, 236);
                SendForcedDeathUpdate();
                return;
            }
        }
    }

    /// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
    float x, y, z, o;
    _resurrectionData->Location.GetPosition(x, y, z, o);
    TeleportTo(_resurrectionData->Location.GetMapId(), x, y, z, o);

    if (IsBeingTeleported())
    {
        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
        return;
    }

    ResurrectPlayer(0.0f, false);

    if (GetMaxHealth() > _resurrectionData->Health)
        SetHealth(_resurrectionData->Health);
    else
        SetFullHealth();

    if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
        SetPower(POWER_MANA, _resurrectionData->Mana);
    else
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

    SetPower(POWER_RAGE, 0);
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
    SetPower(POWER_ECLIPSE, 0);
    SetPower(POWER_BURNING_EMBERS, 10);
    SetPower(POWER_SOUL_SHARDS, 100);
    SetPower(POWER_DEMONIC_FURY, 200);
    SetPower(POWER_SHADOW_ORB, 0);
    SetPower(POWER_CHI, 0);

    if (uint32 aura = _resurrectionData->Aura)
        CastSpell(this, aura, true, NULL, nullptr, _resurrectionData->GUID);

    SpawnCorpseBones();

    /// Resurrecting - 60s aura preventing client from new res spells
    RemoveAura(160029);
}

void Player::SendForcedDeathUpdate()
{
    WorldPacket l_Data(Opcodes::SMSG_FORCED_DEATH_UPDATE, 0);
    GetSession()->SendPacket(&l_Data);
}

void Player::SendGameError(GameError::Type p_Error, uint32 p_Data1 /*= 0xF0F0F0F0*/, uint32 p_Data2 /*= 0xF0F0F0F0*/)
{
    GetSession()->SendGameError(p_Error, p_Data1, p_Data2);
}

void Player::SetClientControl(Unit* p_Target, uint8 p_AllowMove)
{
    WorldPacket l_Data(SMSG_CLIENT_CONTROL_UPDATE);
    l_Data.appendPackGUID(p_Target->GetGUID());
    l_Data.WriteBit(p_AllowMove);
    GetSession()->SendPacket(&l_Data);

    if (p_Target == this && p_AllowMove)
        SetMover(this);
}

void Player::UpdateZoneDependentAuras(uint32 newZone)
{
    // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newZone);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);
}

void Player::UpdateAreaDependentAuras(uint32 newArea)
{
    // remove auras from spells with area limitations
    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
    {
        // use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
        if (iter->second->GetSpellInfo()->CheckLocation(GetMapId(), m_zoneUpdateId, newArea, this) != SPELL_CAST_OK)
            RemoveOwnedAura(iter);
        else
            ++iter;
    }

    // some auras applied at subzone enter
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newArea);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, m_zoneUpdateId, newArea))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);

    if (newArea == 4273 && GetVehicle() && GetPositionX() > 400) // Ulduar
    {
        switch (GetVehicleBase()->GetEntry())
        {
            case 33062:
            case 33109:
            case 33060:
                GetVehicle()->Dismiss();
                break;
        }
    }
}

uint32 Player::GetCorpseReclaimDelay(bool pvp) const
{
    if (pvp)
    {
        if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP))
            return gCopseReclaimDelay[0];
    }
    else if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE))
        return 0;

    time_t now = time(NULL);
    // 0..2 full period
    // should be ceil(x)-1 but not floor(x)
    uint64 count = (now < m_deathExpireTime - 1) ? (m_deathExpireTime - 1 - now)/DEATH_EXPIRE_STEP : 0;
    return gCopseReclaimDelay[count];
}

void Player::UpdateCorpseReclaimDelay()
{
    bool pvp = m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH;

    if ((pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
        (!pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        return;

    time_t now = time(NULL);
    if (now < m_deathExpireTime)
    {
        // full and partly periods 1..3
        uint64 count = (m_deathExpireTime - now)/DEATH_EXPIRE_STEP +1;
        if (count < MAX_DEATH_COUNT)
            m_deathExpireTime = now+(count+1)*DEATH_EXPIRE_STEP;
        else
            m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP;
    }
    else
        m_deathExpireTime = now+DEATH_EXPIRE_STEP;
}

void Player::SendCorpseReclaimDelay(bool p_Load)
{
    Corpse * l_Corpse = GetCorpse();

    if (p_Load && !l_Corpse)
        return;

    bool l_IsPVP;

    if (l_Corpse)
        l_IsPVP = (l_Corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
    else
        l_IsPVP = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH);

    time_t l_Delay;

    if (p_Load)
    {
        if (l_Corpse->GetGhostTime() > m_deathExpireTime)
            return;

        uint64 l_Count;

        if ((l_IsPVP && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
           (!l_IsPVP && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        {
            l_Count = (m_deathExpireTime-l_Corpse->GetGhostTime())/DEATH_EXPIRE_STEP;

            if (l_Count >= MAX_DEATH_COUNT)
                l_Count = MAX_DEATH_COUNT-1;
        }
        else
            l_Count=0;

        time_t l_ExpectedTime = l_Corpse->GetGhostTime() + gCopseReclaimDelay[l_Count];
        time_t l_Now          = time(NULL);

        if (l_Now >= l_ExpectedTime)
            return;

        l_Delay = l_ExpectedTime-l_Now;
    }
    else
        l_Delay = GetCorpseReclaimDelay(l_IsPVP);

    if (!l_Delay)
        return;

    /// Corpse reclaim delay 30 * 1000ms or longer at often deaths
    WorldPacket l_Data(SMSG_CORPSE_RECLAIM_DELAY, 4);
    l_Data << uint32(l_Delay * IN_MILLISECONDS);

    GetSession()->SendPacket(&l_Data);
}

Player* Player::GetNextRandomRaidMember(float radius)
{
    Group* group = GetGroup();
    if (!group)
        return NULL;

    std::vector<Player*> nearMembers;
    nearMembers.reserve(group->GetMembersCount());

    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
    {
        Player* Target = itr->getSource();

        // IsHostileTo check duel and controlled by enemy
        if (Target && Target != this && IsWithinDistInMap(Target, radius) &&
            !Target->HasInvisibilityAura() && !IsHostileTo(Target))
            nearMembers.push_back(Target);
    }

    if (nearMembers.empty())
        return NULL;

    uint32 randTarget = urand(0, nearMembers.size()-1);
    return nearMembers[randTarget];
}

PartyResult Player::CanUninviteFromGroup() const
{
    Group const* grp = GetGroup();
    if (!grp)
        return ERR_NOT_IN_GROUP;

    if (grp->isLFGGroup())
    {
        uint64 gguid = grp->GetGUID();
        if (!sLFGMgr->GetKicksLeft(gguid))
            return ERR_PARTY_LFG_BOOT_LIMIT;

        LfgState state = sLFGMgr->GetState(gguid);
        if (state == LFG_STATE_BOOT)
            return ERR_PARTY_LFG_BOOT_IN_PROGRESS;

        if (grp->GetMembersCount() <= sLFGMgr->GetVotesNeeded(gguid))
            return ERR_PARTY_LFG_BOOT_TOO_FEW_PLAYERS;

        if (state == LFG_STATE_FINISHED_DUNGEON)
            return ERR_PARTY_LFG_BOOT_DUNGEON_COMPLETE;

        if (grp->isRollLootActive())
            return ERR_PARTY_LFG_BOOT_LOOT_ROLLS;

        // TODO: Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
        for (GroupReference const* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
            if (itr->getSource() && itr->getSource()->isInCombat())
                return ERR_PARTY_LFG_BOOT_IN_COMBAT;

        /* Missing support for these types
            return ERR_PARTY_LFG_BOOT_COOLDOWN_S;
            return ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S;
        */
    }
    else
    {
        if (!grp->IsLeader(GetGUID()) && !grp->IsAssistant(GetGUID()) && !(grp->GetPartyFlags() & PARTY_FLAG_EVERYONE_IS_ASSISTANT))
            return ERR_NOT_LEADER;

        if (InBattleground())
            return ERR_LFG_PENDING;
    }

    return ERR_PARTY_RESULT_OK;
}

bool Player::isUsingLfg()
{
    uint64 guid = GetGUID();
    return sLFGMgr->GetState(guid) != LFG_STATE_NONE;
}

void Player::SetBattlegroundOrBattlefieldRaid(Group* group, int8 subgroup)
{
    //we must move references from m_group to m_originalGroup
    SetOriginalGroup(GetGroup(), GetSubGroup());

    m_group.unlink();
    m_group.link(group, this);
    m_group.setSubGroup((uint8)subgroup);
}

void Player::RemoveFromBattlegroundOrBattlefieldRaid()
{
    //remove existing reference
    m_group.unlink();
    if (Group* group = GetOriginalGroup())
    {
        m_group.link(group, this);
        m_group.setSubGroup(GetOriginalSubGroup());
    }
    SetOriginalGroup(NULL);
}

void Player::SetOriginalGroup(Group* group, int8 subgroup)
{
    if (group == NULL)
        m_originalGroup.unlink();
    else
    {
        // never use SetOriginalGroup without a subgroup unless you specify NULL for group
        ASSERT(subgroup >= 0);
        m_originalGroup.link(group, this);
        m_originalGroup.setSubGroup((uint8)subgroup);
    }
}

void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
{
    // temporary hack
    // player can't be on the ship and in the water at the same time
    // If this is not submarine
    if (GetTransport())
        return;

    LiquidData liquid_status;
    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
    if (!res)
    {
        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWARER_INDARKWATER);
        if (_lastLiquid && _lastLiquid->SpellId)
            RemoveAurasDueToSpell(_lastLiquid->SpellId);

        _lastLiquid = NULL;
        return;
    }

    if (uint32 liqEntry = liquid_status.entry)
    {
        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
        if (_lastLiquid && _lastLiquid->SpellId && _lastLiquid->Id != liqEntry)
            RemoveAurasDueToSpell(_lastLiquid->SpellId);

        if (liquid && liquid->SpellId)
        {
            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
            {
                if (!HasAura(liquid->SpellId))
                    CastSpell(this, liquid->SpellId, true);
            }
            else
                RemoveAurasDueToSpell(liquid->SpellId);
        }

        _lastLiquid = liquid;
    }
    else if (_lastLiquid && _lastLiquid->SpellId)
    {
        RemoveAurasDueToSpell(_lastLiquid->SpellId);
        _lastLiquid = NULL;
    }


    // All liquids type - check under water position
    if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
    {
        if (res & LIQUID_MAP_UNDER_WATER)
            m_MirrorTimerFlags |= UNDERWATER_INWATER;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
    }

    // Allow travel in dark water on taxi or transport
    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !isInFlight() && !GetTransport())
        m_MirrorTimerFlags |= UNDERWARER_INDARKWATER;
    else
        m_MirrorTimerFlags &= ~UNDERWARER_INDARKWATER;

    // in lava check, anywhere in lava level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
    }
    // in slime check, anywhere in slime level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
    }
}

void Player::SetCanParry(bool value)
{
    if (m_canParry == value)
        return;

    m_canParry = value;
    UpdateParryPercentage();
}

void Player::SetCanBlock(bool value)
{
    if (m_canBlock == value)
        return;

    m_canBlock = value;
    UpdateBlockPercentage();
}

bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
{
    for (ItemPosCountVec::const_iterator itr = vec.begin(); itr != vec.end(); ++itr)
        if (itr->pos == pos)
            return true;
    return false;
}

void Player::StopCastingBindSight()
{
    if (WorldObject* target = GetViewpoint())
    {
        if (target->isType(TYPEMASK_UNIT))
        {
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_BIND_SIGHT, GetGUID());
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS, GetGUID());
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET, GetGUID());
        }
    }
}

void Player::SetViewpoint(WorldObject* target, bool apply)
{
    if (apply)
    {
        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName(), target->GetEntry(), target->GetTypeId());

        if (!AddGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName());
            return;
        }

        // farsight dynobj or puppet may be very far away
        UpdateVisibilityOf(target);

        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
            ((Unit*)target)->AddPlayerToVision(this);
    }
    else
    {
        sLog->outDebug(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s remove seer", GetName());

        if (!RemoveGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            sLog->outFatal(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot remove current viewpoint!", GetName());
            return;
        }

        if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
            ((Unit*)target)->RemovePlayerFromVision(this);

        // Must immediately set seer back otherwise may crash
        m_seer = this;
    }
}

WorldObject* Player::GetViewpoint() const
{
    if (uint64 guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT))
        return (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_SEER);
    return NULL;
}

bool Player::CanUseBattlegroundObject()
{
    // TODO : some spells gives player ForceReaction to one faction (ReputationMgr::ApplyForceReaction)
    // maybe gameobject code should handle that ForceReaction usage
    // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
    return (//InBattleground() &&                          // in battleground - not need, check in other cases
             //!IsMounted() && - not correct, player is dismounted when he clicks on flag
             //player cannot use object when he is invulnerable (immune)
             !isTotalImmune() &&                            // not totally immune
             //i'm not sure if these two are correct, because invisible players should get visible when they click on flag
             !HasStealthAura() &&                           // not stealthed
             !HasInvisibilityAura() &&                      // not invisible
             !HasAura(SPELL_RECENTLY_DROPPED_FLAG) &&    // can't pickup
             isAlive()                                      // live player
);
}

bool Player::CanCaptureTowerPoint()
{
    return (!HasStealthAura() &&                           // not stealthed
             !HasInvisibilityAura() &&                      // not invisible
             isAlive()                                      // live player
);
}

uint32 Player::GetBarberShopCost(uint8 newhairstyle, uint8 newhaircolor, uint8 newfacialhair, BarberShopStyleEntry const* newSkin, BarberShopStyleEntry const* p_NewFace /* = nullptr */)
{
    uint8 level = getLevel();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;                               // max level in this dbc
        
    uint8 skincolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_SKIN_ID);
    uint8 l_Face        = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_FACE_ID);
    uint8 hairstyle     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_HAIR_STYLE_ID);
    uint8 haircolor     = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, PLAYER_BYTES_OFFSET_HAIR_COLOR_ID);
    uint8 facialhair    = GetByteValue(PLAYER_FIELD_REST_STATE, PLAYER_BYTES_2_OFFSET_FACIAL_STYLE);

    if ((hairstyle == newhairstyle) && (haircolor == newhaircolor) && (facialhair == newfacialhair) && (!newSkin || (newSkin->Data == skincolor)) && (!p_NewFace || (p_NewFace->Data == l_Face)))
        return 0;

    GtBarberShopCostBaseEntry const* bsc = sGtBarberShopCostBaseStore.LookupEntry(level - 1);

    if (!bsc)                                                // shouldn't happen
        return 0xFFFFFFFF;

    float cost = 0;

    if (hairstyle != newhairstyle)
        cost += bsc->cost;                                  // full price

    if ((haircolor != newhaircolor) && (hairstyle == newhairstyle))
        cost += bsc->cost * 0.5f;                           // +1/2 of price

    if (facialhair != newfacialhair)
        cost += bsc->cost * 0.75f;                          // +3/4 of price

    if (newSkin && skincolor != newSkin->Data)
        cost += bsc->cost * 0.75f;                          // +5/6 of price

    if (p_NewFace && l_Face != p_NewFace->Data)
        cost += bsc->cost * 2;                              /// 2x price

    return uint32(cost);
}

void Player::InitGlyphsForLevel()
{
    uint32 slot = 0;
    // Hack fix to reorder glyphs
    if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(22))
        SetGlyphSlot(slot++, gs->Id);
    if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(21))
        SetGlyphSlot(slot++, gs->Id);
    for (uint32 i = 23; i < sGlyphSlotStore.GetNumRows() && slot < MAX_GLYPH_SLOT_INDEX; ++i)
        if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(i))
            SetGlyphSlot(slot++, gs->Id);

    uint8 level = getLevel();
    uint32 slotMask = 0;

    if (level >= 25)
        slotMask |= 0x01 | 0x02 | 0x40;
    if (level >= 50)
        slotMask |= 0x04 | 0x08 | 0x80;
    if (level >= 75)
        slotMask |= 0x10 | 0x20 | 0x100;

    SetUInt32Value(PLAYER_FIELD_GLYPH_SLOTS_ENABLED, slotMask);
}

bool Player::isTotalImmune()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    uint32 immuneMask = 0;
    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        immuneMask |= (*itr)->GetMiscValue();
        if (immuneMask & SPELL_SCHOOL_MASK_ALL)            // total immunity
            return true;
    }
    return false;
}

bool Player::HasTitle(uint32 bitIndex)
{
    if (bitIndex > MAX_TITLE_INDEX)
        return false;

    uint32 fieldIndexOffset = bitIndex / 32;
    uint32 flag = 1 << (bitIndex % 32);
    return HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
}

void Player::SetTitle(CharTitlesEntry const* title, bool lost)
{
    uint32 fieldIndexOffset = title->MaskID / 32;
    uint32 flag = 1 << (title->MaskID % 32);

    if (lost)
    {
        if (!HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        RemoveFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        SetFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
    }

    if (lost)
    {
        WorldPacket data(SMSG_TITLE_LOST, 4);
        data << uint32(title->MaskID);
        GetSession()->SendPacket(&data);
    }
    else
    {
        WorldPacket data(SMSG_TITLE_EARNED, 4);
        data << uint32(title->MaskID);
        GetSession()->SendPacket(&data);
    }
}

bool Player::isTotalImmunity()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_ALL) !=0)   // total immunity
        {
            return true;
        }
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) !=0)   // physical damage immunity
        {
            for (AuraEffectList::const_iterator i = immune.begin(); i != immune.end(); ++i)
            {
                if (((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_MAGIC) !=0)   // magic immunity
                {
                    return true;
                }
            }
        }
    }
    return false;
}
/// @todo DO SOMETHING WITH THIS SHIT
                                   // Heurtoir,            Frappe héro,        Coup traumatisant
#define SPELL_WAR_ATTACK_LIST   47475,                  47450,              12809


                                // Consecration,       Repentir
#define SPELL_PAL_ATTACK_LIST   26573,              20066
                                // Eclair Lumineux,     Lumiere sacree
#define SPELL_PAL_FRIEND_LIST   48785,                  48782,              48785


                                // Tir des arcanes,     Morsure de serpent, Morsure de la mangouste
#define SPELL_HUNT_ATTACK_LIST  49045,                  49001,              53339


                                // pied,                Hemoragie           suriner         Eventail de couteaux
#define SPELL_ROG_ATTACK_LIST   1766,                   48660,              1776,           51723


                                // Douleur,             Chatiment,          Flammes sacrees
#define SPELL_PRI_ATTACK_LIST   48125,                  48123,              48135
                                // Soins rapides,       Rénovation,         Priere de guérison
#define SPELL_PRI_FRIEND_LIST   48071,                  48068,              48113


                                // frappe au coeur,     Toucher de glace,   Mort et decompo
#define SPELL_DK_ATTACK_LIST    55262,                  49909,              49938


                                // Chaine d'éclairs,    Horion de flammes,  Orage
#define SPELL_CHA_ATTACK_LIST   49271,                  49233,              59159
                                // Salve de guerison    Vague de soin       Bouclier de terre
#define SPELL_CHA_FRIEND_LIST   55459,                  49273,              49284


                                // Boule de feu,        Nova de givre,      Eclair de givrefeu
#define SPELL_MAG_ATTACK_LIST   42833,                  42917,              44614


                                // Immolation,          Drain de vie,       Hurlement de terreur
#define SPELL_DEM_ATTACK_LIST   47811,                  47857,              17928


                                // Colère,              Eclat Lunaire,      Lucioles
#define SPELL_DRU_ATTACK_LIST   48461,                  48463,              770
                                // Recuperation,        Toucher guerriseur, Tranquillité
#define SPELL_DRU_FRIEND_LIST   48441,                  48378,              48447
                                // Breath of fire       //Blackout kick     //Chi burst
#define SPELL_MONK_ATTACK_LIST  123725,                 128531,             130651

uint32 rand_number(uint32 value1, uint32 value2, uint32 value3 = 0, uint32 value4 = 0)
{
    switch (rand() % 4)
    {
        case 0:     return value1;
        case 1:     return value2;
        case 2:     return value3;
        case 3:     return value4;
        default:    return 0;
    }
}

void Player::UpdateCharmedAI()
{
    //This should only called in Player::Update
    Creature* charmer = GetCharmer()->ToCreature();

    //kill self if charm aura has infinite duration
    if (charmer->IsInEvadeMode())
    {
        AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOD_CHARM);
        for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
            if ((*iter)->GetCasterGUID() == charmer->GetGUID() && (*iter)->GetBase()->IsPermanent())
            {
                charmer->DealDamage(this, GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                return;
            }
    }

    if (!charmer->isInCombat())
        GetMotionMaster()->MoveFollow(charmer, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);

    Unit* target = getVictim();
    if (!target || !charmer->IsValidAttackTarget(target))
    {
        target = charmer->SelectNearestPlayerNotGM();
        if (!target)
            return;

        GetMotionMaster()->MoveChase(target);
        Attack(target, true);
    }
    else
    {
        if (HasUnitState(UNIT_STATE_CASTING))
            return;
        else if (target && GetMotionMaster()->GetCurrentMovementGeneratorType() != CHASE_MOTION_TYPE)
            GetMotionMaster()->MoveChase(target);

        // On laisse quelques attaques en melée deux fois sur trois
        if (urand(0, 2))
            return;

        // On s'arrete pour cast le spell
        GetMotionMaster()->MoveIdle();

        // 0 : Friendly, 1-2-3 : attack
        bool attack = urand(0 , 3);

        switch (getClass())
        {
            case CLASS_WARRIOR:
            {
                CastSpell(target, rand_number(SPELL_WAR_ATTACK_LIST));
                break;
            }
            case CLASS_PALADIN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PAL_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PAL_FRIEND_LIST));
                break;
            }
            case CLASS_HUNTER:
            {
                CastSpell(target, rand_number(SPELL_HUNT_ATTACK_LIST));
                break;
            }
            case CLASS_ROGUE:
            {
                CastSpell(target, rand_number(SPELL_ROG_ATTACK_LIST));
                break;
            }
            case CLASS_PRIEST:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PRI_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PRI_FRIEND_LIST));
                break;
            }
            case CLASS_DEATH_KNIGHT:
            {
                CastSpell(target, rand_number(SPELL_DK_ATTACK_LIST));
                break;
            }
            case CLASS_SHAMAN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_CHA_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_CHA_FRIEND_LIST));
                break;
            }
            case CLASS_MAGE:
            {
                CastSpell(target, rand_number(SPELL_MAG_ATTACK_LIST));
                break;
            }
            case CLASS_WARLOCK:
            {
                CastSpell(target, rand_number(SPELL_DEM_ATTACK_LIST));
                break;
            }
            case CLASS_DRUID:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_DRU_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_DRU_FRIEND_LIST));
                break;
            }
            case CLASS_MONK:
            {
                CastSpell(target, rand_number(SPELL_MONK_ATTACK_LIST));
                break;
            }
            default:
                break;
        }
    }
}

uint32 Player::GetRuneTypeBaseCooldown(RuneType /*runeType*/) const
{
    float l_Cooldown = RUNE_BASE_COOLDOWN * GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);
    float l_Modifier = 1.0f;

    AuraEffectList const& l_RegenAura = GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
    for (AuraEffectList::const_iterator l_Idx = l_RegenAura.begin(); l_Idx != l_RegenAura.end(); ++l_Idx)
    {
        if ((*l_Idx)->GetMiscValue() == POWER_RUNES)
            l_Modifier += (float)(*l_Idx)->GetAmount() / 100.0f;
    }

    return l_Cooldown / l_Modifier;
}

void Player::RemoveRunesBySpell(uint32 spell_id)
{
    for (uint8 i = 0; i < MAX_RUNES; ++i)
    {
        if (m_runes.runes[i].spell_id == spell_id)
        {
            ConvertRune(i, GetBaseRune(i));
            SetRuneConvertSpell(i, 0);
        }
    }
}

void Player::RestoreBaseRune(uint8 index)
{
    ConvertRune(index, GetBaseRune(index));
    SetRuneConvertSpell(index, 0);
}

void Player::ConvertRune(uint8 p_Index, RuneType p_NewType)
{
    SetCurrentRune(p_Index, p_NewType);

    WorldPacket l_Data(SMSG_CONVERT_RUNE, 2);
    l_Data << uint8(p_Index);
    l_Data << uint8(p_NewType);

    GetSession()->SendPacket(&l_Data);
}

void Player::ResyncRunes(uint8 p_Count)
{
    WorldPacket l_Data(SMSG_RESYNC_RUNES, 4 + p_Count * 2);
    l_Data << uint32(p_Count);

    for (uint32 l_I = 0; l_I < p_Count; ++l_I)
    {
        l_Data << uint8(GetCurrentRune(l_I));                   // rune type
        l_Data << uint8(255 - (GetRuneCooldown(l_I) * 51));     // passed cooldown time (0-255)
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::SendDeathRuneUpdate()
{
    if (getClass() != CLASS_DEATH_KNIGHT)
        return;

    for (uint8 l_I = 0; l_I < MAX_RUNES; ++l_I)
    {
        if (m_runes.runes[l_I].CurrentRune != RUNE_DEATH)
            continue;

        WorldPacket l_Data(SMSG_CONVERT_RUNE, 2);
        l_Data << uint8(l_I);
        l_Data << uint8(RUNE_DEATH);

        GetSession()->SendPacket(&l_Data);
    }
}

void Player::AddRunePower(uint8 index)
{
    WorldPacket data(SMSG_ADD_RUNE_POWER, 4);
    data << uint32(1 << index);                             // mask (0x00-0x3F probably)
    GetSession()->SendPacket(&data);
}

static RuneType runeSlotTypes[MAX_RUNES] =
{
    /*0*/ RUNE_BLOOD,
    /*1*/ RUNE_BLOOD,
    /*2*/ RUNE_UNHOLY,
    /*3*/ RUNE_UNHOLY,
    /*4*/ RUNE_FROST,
    /*5*/ RUNE_FROST
};

void Player::InitRunes()
{
    if (getClass() != CLASS_DEATH_KNIGHT)
        return;

    m_runes.runeState = 0;

    for (uint8 i = 0; i < MAX_RUNES; ++i)
    {
        SetBaseRune(i, runeSlotTypes[i]);                              // init base types
        SetCurrentRune(i, runeSlotTypes[i]);                           // init current types
        SetRuneCooldown(i, 0);                                         // reset cooldowns
        SetRuneConvertSpell(i, 0);
        m_runes.SetRuneState(i);
        SetDeathRuneUsed(i, false);
    }

    UpdateAllRunesRegen();
    SetCurrentRuneForBloodTap(NUM_RUNE_TYPES);
}

bool Player::IsBaseRuneSlotsOnCooldown(RuneType runeType) const
{
    for (uint8 i = 0; i < MAX_RUNES; ++i)
        if (GetBaseRune(i) == runeType && GetRuneCooldown(i) == 0)
            return false;

    return true;
}

void Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, bool broadcast)
{
    Loot loot;
    loot.FillLoot (loot_id, store, this, true, true);

    uint32 max_slot = loot.GetMaxSlotInLootFor(this);
    for (uint32 i = 0; i < max_slot; ++i)
    {
        LootItem* lootItem = loot.LootItemInSlot(i, this);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(bag, slot, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && slot != NULL_SLOT)
            msg = CanStoreNewItem(bag, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && bag != NULL_BAG)
            msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, NULL, NULL, lootItem->itemid);
            continue;
        }

        Item* pItem = StoreNewItem(dest, lootItem->itemid, true, lootItem->randomPropertyId);
        SendNewItem(pItem, lootItem->count, false, false, broadcast);
    }
}

void Player::StoreLootItem(uint8 lootSlot, Loot* loot, uint8 linkedLootSlot)
{
    QuestItem* qitem = NULL;
    QuestItem* ffaitem = NULL;
    QuestItem* conditem = NULL;
    QuestItem* currency = NULL;

    LootItem* item = loot->LootItemInSlot(lootSlot, this, &qitem, &ffaitem, &conditem, &currency);

    if (!item)
    {
        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
        return;
    }

    if (item->alreadyAskedForRoll)
    {
        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
        return;
    }

    // questitems use the blocked field for other purposes
    if (!qitem && item->is_blocked)
    {
        SendLootRelease(GetLootGUID());
        return;
    }

    if (currency)
    {
        if (CurrencyTypesEntry const * currencyEntry = sCurrencyTypesStore.LookupEntry(item->itemid))
            ModifyCurrency(item->itemid, int32(item->count * currencyEntry->GetPrecision()));

        SendNotifyLootItemRemoved(lootSlot);
        currency->is_looted = true;
        --loot->UnlootedCount;
        return;
    }

    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count);
    if (msg == EQUIP_ERR_OK)
    {
        AllowedLooterSet looters = item->GetAllowedLooters();
        Item* newitem = StoreNewItem(dest, item->itemid, true, item->randomPropertyId, looters);

        if (qitem)
        {
            qitem->is_looted = true;
            //freeforall is 1 if everyone's supposed to get the quest item.
            if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
                SendNotifyLootItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot);
            else
                loot->NotifyQuestItemRemoved(qitem->index);
        }
        else
        {
            if (ffaitem)
            {
                //freeforall case, notify only one player of the removal
                ffaitem->is_looted = true;
                SendNotifyLootItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot);
            }
            else
            {
                //not freeforall, notify everyone
                if (conditem)
                    conditem->is_looted = true;
                loot->NotifyItemRemoved(linkedLootSlot == 0xFF ? lootSlot : linkedLootSlot, item->PersonalLooter);
            }
        }

        //if only one person is supposed to loot the item, then set it to looted
        if (!item->freeforall)
            item->is_looted = true;

        --loot->UnlootedCount;

        /*if (const ItemTemplate* proto = sObjectMgr->GetItemTemplate(item->itemid))
            if (proto->Quality > ITEM_QUALITY_EPIC || (proto->Quality == ITEM_QUALITY_EPIC && proto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
                if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                    guild->GetNewsLog().AddNewEvent(GUILD_NEWS_ITEM_LOOTED, time(NULL), GetGUID(), 0, item->itemid);*/


        /// Add bonus to item if needed
        if (newitem)
            newitem->AddItemBonuses(item->itemBonuses);

        ItemContext l_Context   = ItemContext::None;
        uint32 l_EncounterID    = 0;
        if (Creature* l_Creature = Creature::GetCreature(*this, loot->source))
        {
            if (InstanceScript* l_InstanceScript = l_Creature->GetInstanceScript())
                l_EncounterID = l_InstanceScript->GetEncounterIDForBoss(l_Creature);

            switch (GetMap()->GetDifficultyID())
            {
                case Difficulty::DifficultyRaidLFR:
                    l_Context = ItemContext::RaidLfr;
                    break;
                case Difficulty::DifficultyRaidNormal:
                    l_Context = ItemContext::RaidNormal;
                    break;
                case Difficulty::DifficultyRaidHeroic:
                    l_Context = ItemContext::RaidHeroic;
                    break;
                case Difficulty::DifficultyRaidMythic:
                    l_Context = ItemContext::RaidMythic;
                    break;
                case Difficulty::DifficultyNormal:
                    l_Context = ItemContext::DungeonNormal;
                    break;
                case Difficulty::DifficultyHeroic:
                    l_Context = ItemContext::DungeonHeroic;
                    break;
                case Difficulty::DifficultyMythic:
                    l_Context = ItemContext::DungeonMythic;
                    break;
                default:
                    break;
            }

            /// If item is not equipable, it doesn't need to be displayed
            /// If item is not from listed difficulties, it doesn't need to be displayed
            if ((newitem && !newitem->IsEquipable()) || l_Context == ItemContext::None)
            {
                l_EncounterID   = 0;
                l_Context       = ItemContext::None;
            }
        }

        SendNewItem(newitem, uint32(item->count), false, false, true, l_EncounterID, l_Context);

        /// Handle achievement criteria related to loot
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_TYPE, loot->Type, item->count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_EPIC_ITEM, item->itemid, item->count);

        /// Complete the tracking quest if needed
        AddTrackingQuestIfNeeded(loot->source);
    }
    else
        SendEquipError(msg, NULL, NULL, item->itemid);
}

void Player::AddTrackingQuestIfNeeded(uint64 p_SourceGuid)
{
    uint32 l_TrackingQuest = 0;

    /// If source is a creature
    if (IS_UNIT_GUID(p_SourceGuid))
    {
        Creature const* l_CreatureSource = sObjectAccessor->FindCreature(p_SourceGuid);
        if (l_CreatureSource == nullptr)
            return;

        l_TrackingQuest = l_CreatureSource->GetCreatureTemplate()->TrackingQuestID;
    }

    /// If source is a gameobject
    if (IS_GAMEOBJECT_GUID(p_SourceGuid))
    {
        GameObject const* l_GameObjectSource = sObjectAccessor->FindGameObject(p_SourceGuid);
        if (l_GameObjectSource == nullptr)
            return;

        l_TrackingQuest = l_GameObjectSource->GetGOInfo()->GetTrackingQuestId();
    }

    /// @TODO: Item can have tracking quest ?
    /// If someone as more informations, please tell me :D

    if (l_TrackingQuest == 0)
        return;

    auto l_Quest = sObjectMgr->GetQuestTemplate(l_TrackingQuest);
    if (l_Quest == nullptr)
        return;

    SetQuestStatus(l_Quest->GetQuestId(), QUEST_STATUS_COMPLETE);
    RewardQuest(l_Quest, 0, nullptr);
}

uint32 Player::CalculateTalentsPoints() const
{
    uint8 l_talentPoints = getLevel() / 15;

    // Should be a hardcoded value
    if (getLevel() == 100)
        ++l_talentPoints;

    return l_talentPoints;
}

bool Player::IsKnowHowFlyIn(uint32 mapid, uint32 zone, uint32 spellId) const
{
    if (isGameMaster())
        return true;
    // Eye of the Storm is always allowed in Throne of the Four Winds
    if (zone == 5638 && spellId == 82724)
        return true;

    // Wings of Flame is always allowed in Firelands
    if (zone == 5723 && spellId == 98619)
        return true;

    // Tol Barad
    if (mapid == 732)
        return false;

    /// Tarren Mill
    if (mapid == 1280)
        return false;

    // continent checked in SpellMgr::GetSpellAllowedInLocationError at cast and area update
    uint32 v_map = GetVirtualMapForMapAndZone(mapid, zone);
    switch (v_map)
    {
        case 0:   // Eastern Kingdoms
            switch(zone)
            {
                // mapid of these zones is 530 but v_map is 0
                case 3430: // Eversong Woods
                case 3433: // Ghostlands
                case 4080: // Isle of Quel'Danas
                    return false;
            }
        // no break here
        case 1:   // Kalimdor
        case 646: // Deepholm
            return HasSpell(90267); // Flight Master's License
        case 571: // Northrend
            return HasSpell(54197); // Cold Weather Flying
        case 530: // Outland
        case 870: // Pandaria
            switch(zone)
            {
                case 6757: // Timeless Isle
                case 6661: // Isle of Giants
                    return false;
            }
            return true;
    }

#ifndef CROSS
    if (mapid == MS::Garrison::Globals::BaseMap || (m_Garrison && (mapid == (m_Garrison->GetGarrisonSiteLevelEntry() ? m_Garrison->GetGarrisonSiteLevelEntry()->MapID : -1) || (mapid == m_Garrison->GetShipyardMapId()))))
        return HasSpell(191645);    ///< Draenor Pathfinder
#endif

    return false;
}

void Player::learnSpellHighRank(uint32 spellid)
{
    learnSpell(spellid, false);

    if (uint32 next = sSpellMgr->GetNextSpellInChain(spellid))
        learnSpellHighRank(next);
}

void Player::_LoadSkills(PreparedQueryResult result)
{
    //                                                           0      1      2
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));

#ifdef CROSS
    /// Clean default values
    mSkillStatus.clear();
    for (uint32 count = 0; count < PLAYER_MAX_SKILLS; ++count)
    {
        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);
    }

#endif /* CROSS */
    uint32 count = 0;
    uint8 professionCount = 0;
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint16 skill    = fields[0].GetUInt16();
            uint16 value    = fields[1].GetUInt16();
            uint16 max      = fields[2].GetUInt16();

            /// Bug fixed in commit ed9e9fafb28bed40118a238849e0332726843cb6
            /// but we need to fix early learning of the last wod profession
            /// palier
            if (max == 675)
                max = 700;

            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(skill);
            if (!pSkill)
            {
                PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);
                l_Stmt->setUInt32(0, GetGUIDLow());
                l_Stmt->setUInt32(1, skill);
                CharacterDatabase.Execute(l_Stmt);

                sLog->outError(LOG_FILTER_PLAYER, "Character %u has skill %u that does not exist, delete it.", GetGUIDLow(), skill);
                continue;
            }

            // set fixed skill ranges
            switch (GetSkillRangeType(pSkill, false))
            {
                case SKILL_RANGE_LANGUAGE:                      // 300..300
                    value = max = 300;
                    break;
                case SKILL_RANGE_MONO:                          // 1..1, grey monolite bar
                    value = max = 1;
                    break;
                default:
                    break;
            }

            if (value == 0)
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);
                PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt16(1, skill);
                RealmDatabase.Execute(stmt);
                continue;
            }

            uint16 field = count / 2;
            uint8 offset = count & 1;

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, skill);
            uint16 step = 0;

            if (pSkill->categoryId == SKILL_CATEGORY_SECONDARY || pSkill->categoryId == SKILL_CATEGORY_PROFESSION)
            {
                if (max <= 600)
                    step = max / 75;
                else
                    step = (600 / 75) + ((max - 600) / 100);
            }

            if (pSkill->categoryId == SKILL_CATEGORY_PROFESSION)
            {
                if (professionCount < DEFAULT_MAX_PRIMARY_TRADE_SKILL)
                    SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + professionCount++, skill);
            }

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, step);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, value);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, max);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);

            mSkillStatus.insert(SkillStatusMap::value_type(skill, SkillStatusData(count, SKILL_UNCHANGED)));
            learnSkillRewardedSpells(skill, value);

            ++count;

            if (count >= PLAYER_MAX_SKILLS)                      // client limit
            {
                sLog->outError(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
                break;
            }
        }
        while (result->NextRow());
    }

    // Initialize unknow profession skill, needed since 5.4
    for (uint32 i = 0; i < sSkillLineStore.GetNumRows(); i++)
    {
        SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(i);
        if (!pSkill || (pSkill->id != 794 && pSkill->m_Flags != 0x1080))
            continue;

        if (HasSkill(i))
            continue;

        uint16 value = 0;
        uint16 max = 0;
        uint16 step = 0;

        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, i);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, step);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, value);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, max);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);

        ++count;

        if (count >= PLAYER_MAX_SKILLS)                      // client limit
        {
            sLog->outError(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
            break;
        }
    }

    for (; count < PLAYER_MAX_SKILLS; ++count)
    {
        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_LINEID + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_STEP + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_RANK + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MAX_RANK + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_MODIFIER + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_OFFSET_TALENT + field, offset, 0);
    }

    // special settings
    if (getClass() == CLASS_DEATH_KNIGHT)
    {
        uint8 base_level = std::min(getLevel(), uint8(sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL)));
        if (base_level < 1)
            base_level = 1;
        uint16 base_skill = (base_level-1)*5;               // 270 at starting level 55
        if (base_skill < 1)
            base_skill = 1;                                 // skill mast be known and then > 0 in any case

        if (GetPureSkillValue(SKILL_FIRST_AID) < base_skill)
            SetSkill(SKILL_FIRST_AID, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_AXES) < base_skill)
            SetSkill(SKILL_AXES, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_DEFENSE) < base_skill)
            SetSkill(SKILL_DEFENSE, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_POLEARMS) < base_skill)
            SetSkill(SKILL_POLEARMS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_SWORDS) < base_skill)
            SetSkill(SKILL_SWORDS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_2H_AXES) < base_skill)
            SetSkill(SKILL_2H_AXES, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_2H_SWORDS) < base_skill)
            SetSkill(SKILL_2H_SWORDS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_UNARMED) < base_skill)
            SetSkill(SKILL_UNARMED, 0, base_skill, base_skill);
    }
}

InventoryResult Player::CanEquipUniqueItem(Item* pItem, uint8 eslot, uint32 limit_count) const
{
    ItemTemplate const* pProto = pItem->GetTemplate();

    // proto based limitations
    if (InventoryResult res = CanEquipUniqueItem(pProto, eslot, limit_count))
        return res;

    // check unique-equipped on gems
    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
    {
        uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
        if (!enchant_id)
            continue;
        SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!enchantEntry)
            continue;

        ItemTemplate const* pGem = sObjectMgr->GetItemTemplate(enchantEntry->GemID);
        if (!pGem)
            continue;

        // include for check equip another gems with same limit category for not equipped item (and then not counted)
        uint32 gem_limit_count = !pItem->IsEquipped() && pGem->ItemLimitCategory
            ? pItem->GetGemCountWithLimitCategory(pGem->ItemLimitCategory) : 1;

        if (InventoryResult res = CanEquipUniqueItem(pGem, eslot, gem_limit_count))
            return res;
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanEquipUniqueItem(ItemTemplate const* itemProto, uint8 except_slot, uint32 limit_count) const
{
    // check unique-equipped on item
    if (itemProto->Flags & ITEM_FLAG_UNIQUE_EQUIPPED)
    {
        // there is an equip limit on this item
        if (HasItemOrGemWithIdEquipped(itemProto->ItemId, 1, except_slot))
            return EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE;
    }

    // check unique-equipped limit
    if (itemProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(itemProto->ItemLimitCategory);
        if (!limitEntry)
            return EQUIP_ERR_NOT_EQUIPPABLE;

        // NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case

        if (limit_count > limitEntry->maxCount)
            return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS;

        // there is an equip limit on this item
        if (HasItemOrGemWithLimitCategoryEquipped(itemProto->ItemLimitCategory, limitEntry->maxCount - limit_count + 1, except_slot))
            return EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED;
    }

    return EQUIP_ERR_OK;
}

void Player::HandleFall(MovementInfo const& movementInfo)
{
    // calculate total z distance of the fall
    float z_diff = m_lastFallZ - movementInfo.pos.GetPositionZ();
    //sLog->outDebug(LOG_FILTER_GENERAL, "zDiff = %f", z_diff);

    //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
    // 14.57 can be calculated by resolving damageperc formula below to 0
    if (z_diff >= 14.57f && !isDead() && !isGameMaster() &&
        !HasAuraType(SPELL_AURA_HOVER) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
        !HasAuraType(SPELL_AURA_FLY) && !IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL) &&
        !(getClass() == CLASS_DEATH_KNIGHT && HasAura(59307) && HasAura(3714)))
    {
        //Safe fall, fall height reduction
        int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);

        // Glyph of Safe Fall
        if (HasAura(58033) && HasAura(1860))
            safe_fall += 10;

        float damageperc = 0.018f*(z_diff-safe_fall)-0.2426f;

        if (damageperc > 0)
        {
            uint32 damage = (uint32)(damageperc * GetMaxHealth()*sWorld->getRate(RATE_DAMAGE_FALL));

            float height = movementInfo.pos.m_positionZ;
            UpdateGroundPositionZ(movementInfo.pos.m_positionX, movementInfo.pos.m_positionY, height);

            if (damage > 0)
            {
                //Prevent fall damage from being more than the player maximum health
                if (damage > GetMaxHealth())
                    damage = GetMaxHealth();

                // Gust of Wind
                if (HasAura(43621))
                    damage = GetMaxHealth()/2;

                uint32 original_health = GetHealth();
                uint32 final_damage = EnvironmentalDamage(DAMAGE_FALL, damage);

                // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
                if (isAlive() && final_damage < original_health)
                    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FALL_WITHOUT_DYING, uint32(z_diff*100));
            }

            //Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
            sLog->outDebug(LOG_FILTER_PLAYER, "FALLDAMAGE z=%f sz=%f pZ=%f FallTime=%d mZ=%f damage=%d SF=%d", movementInfo.pos.GetPositionZ(), height, GetPositionZ(), movementInfo.fallTime, height, damage, safe_fall);
        }
    }
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LANDING); // No fly zone - Parachute

    /// Handler for Disengage, should give Posthaste just after landing
    /// If in future we have some spells with same mechanic, just need to add switch
    if (getClass() == CLASS_HUNTER && GetLastUsedLeapBackSpell() == 56446 && HasAura(109215))
        CastSpell(this, 118922, true);

    ClearLastUsedLeapBackSpell();
}

void Player::UpdateAchievementCriteria(AchievementCriteriaTypes p_Type, uint64 p_MiscValue1 /*= 0*/, uint64 p_MiscValue2 /*= 0*/, uint64 p_MiscValue3 /*= 0*/, Unit* p_Unit /*= nullptr*/, bool p_LoginCheck /*= false*/)
{
    if (sWorld->getBoolConfig(CONFIG_ACHIEVEMENT_DISABLE))
        return;

    AchievementCriteriaUpdateTask l_Task;
    l_Task.PlayerGUID = GetGUID();
    l_Task.UnitGUID   = p_Unit ? p_Unit->GetGUID() : 0;
    l_Task.Task = [p_Type, p_MiscValue1, p_MiscValue2, p_MiscValue3, p_LoginCheck](uint64 const& p_PlayerGuid, uint64 const& p_UnitGUID) -> void
    {
        /// Task will be executed async
        /// We need to ensure the player still exist
        Player* l_Player = HashMapHolder<Player>::Find(p_PlayerGuid);
        if (l_Player == nullptr)
            return;

        /// Same for the unit
        Unit* l_Unit = p_UnitGUID ? Unit::GetUnit(*l_Player, p_UnitGUID) : nullptr;

        l_Player->GetAchievementMgr().UpdateAchievementCriteria(p_Type, p_MiscValue1, p_MiscValue2, p_MiscValue3, l_Unit, l_Player, p_LoginCheck);

        // Update only individual achievement criteria here, otherwise we may get multiple updates
        // from a single boss kill
        if (sAchievementMgr->IsGroupCriteriaType(p_Type))
            return;

#ifndef CROSS
        if (Guild* l_Guild = sGuildMgr->GetGuildById(l_Player->GetGuildId()))
            l_Guild->GetAchievementMgr().UpdateAchievementCriteria(p_Type, p_MiscValue1, p_MiscValue2, p_MiscValue3, l_Unit, l_Player, p_LoginCheck);
#else /* CROSS */
        /// @TODO: Cross sync
        //if (Guild* l_Guild = sGuildMgr->GetGuildById(l_Player->GetGuildId()))
        //    l_Guild->GetAchievementMgr().UpdateAchievementCriteria(p_Type, p_MiscValue1, p_MiscValue2, p_MiscValue3, l_Unit, l_Player, p_LoginCheck);
#endif /* CROSS */
        
    };

    sAchievementMgr->AddCriteriaUpdateTask(l_Task);
}

void Player::CompletedAchievement(AchievementEntry const* entry)
{
    GetAchievementMgr().CompletedAchievement(entry, this);
}

static const uint8 k_LevelPerTier[7] =
{
    15,
    30,
    45,
    60,
    75,
    90,
    100
};

bool Player::LearnTalent(uint32 talentId)
{
    uint32 CurTalentPoints = GetFreeTalentPoints();
    if (CurTalentPoints == 0)
        return false;

    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
    if (!talentInfo)
        return false;

    if (k_LevelPerTier[talentInfo->TierID] > getLevel())
        return false;

    if (talentInfo->ClassID != getClass())
        return false;

    uint32 spellid = talentInfo->SpellID;
    if (spellid == 0)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Talent.dbc have for talent: %uspell id = 0", talentId);
        return false;
    }

    // already known
    if (HasSpell(spellid))
        return false;

    // Check if players has already learn a talent for this rank
    for (uint32 i = 0; i < sTalentStore.GetNumRows(); i++)
    {
        TalentEntry const* tInfo = sTalentStore.LookupEntry(i);
        if (!tInfo)
            continue;

        if (tInfo->ClassID != getClass())
            continue;

        if (tInfo->TierID == talentInfo->TierID && HasSpell(tInfo->SpellID))
            return false;
    }

    // learn! (other talent ranks will unlearned at learning)
    learnSpell(spellid, false);
    AddTalent(spellid, GetActiveSpec(), true);
    CastPassiveTalentSpell(spellid);

    sLog->outInfo(LOG_FILTER_GENERAL, "TalentID: %u Spell: %u Spec: %u\n", talentId, spellid, GetActiveSpec());
    return true;
}

void Player::AddKnownCurrency(uint32 itemId)
{
    if (CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(itemId))
        SetFlag64(0, (1LL << (ctEntry->ID-1)));
}

void Player::UpdateFallInformationIfNeed(MovementInfo const& minfo, uint16 opcode)
{
    if (m_lastFallTime >= minfo.fallTime || m_lastFallZ <= minfo.pos.GetPositionZ() || opcode == CMSG_MOVE_FALL_LAND)
        SetFallInformation(minfo.fallTime, minfo.pos.GetPositionZ());
}

void Player::UnsummonPetTemporaryIfAny()
{
    Pet* pet = GetPet();
    if (!pet)
        return;

    if (!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned())
    {
        m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetRealmPetNumber();
        m_oldpetspell = pet->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL);
    }

    RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, false, pet->m_Stampeded);
}

void Player::ResummonPetTemporaryUnSummonedIfAny()
{
    if (!m_temporaryUnsummonedPetNumber)
        return;

    // not resummon in not appropriate state
    if (IsPetNeedBeTemporaryUnsummoned())
        return;

    if (GetPetGUID())
        return;

    Pet*   l_NewPet     = new Pet(this);
    uint64 l_PlayerGUID = GetGUID();
    uint32 l_PetNumber  = m_temporaryUnsummonedPetNumber;

#ifdef CROSS
    uint32 l_RealmID    = GetSession()->GetInterRealmNumber();
#else
    uint32 l_RealmID    = g_RealmID;
#endif

    PreparedStatement* l_PetStatement = PetQueryHolder::GenerateFirstLoadStatement(0, m_temporaryUnsummonedPetNumber, GetRealGUIDLow(), true, PET_SLOT_UNK_SLOT, l_RealmID);
    AsyncQuery(RealmDatabase, l_PetStatement, [l_NewPet, l_PlayerGUID, l_PetNumber, l_RealmID](PreparedQueryResult p_Result) -> void
    {
        if (!p_Result)
        {
            delete l_NewPet;
            return;
        }

#ifdef CROSS
        InterRealmClient* l_Client = sInterRealmMgr->GetClientByRealmNumber(l_RealmID);
        if (!l_Client || !l_Client->GetDatabase())
        {
            delete l_NewPet;
            return;
        }

        auto l_Database = l_Client->GetDatabase();
#else
        auto l_Database = &CharacterDatabase;
#endif

        PetQueryHolder* l_PetHolder = new PetQueryHolder(p_Result->Fetch()[0].GetUInt32(), l_RealmID, p_Result);
        l_PetHolder->Initialize();

        auto l_QueryHolderResultFuture = l_Database->DelayQueryHolder(l_PetHolder);

        sWorld->AddQueryHolderCallback(QueryHolderCallback(l_QueryHolderResultFuture, [l_NewPet, l_PlayerGUID, l_PetNumber](SQLQueryHolder* p_QueryHolder) -> void
        {
            Player* l_Player = sObjectAccessor->FindPlayer(l_PlayerGUID);
            if (!l_Player || !p_QueryHolder || l_Player != l_NewPet->GetOwner())
            {
                delete l_NewPet;
                return;
            }

            l_NewPet->LoadPetFromDB(l_Player, 0, l_PetNumber, true, PET_SLOT_UNK_SLOT, false, (PetQueryHolder*)p_QueryHolder, [](Pet* p_Pet, bool p_Result)
            {
                if (!p_Result)
                {
                    delete p_Pet;
                    return;
                }

                Player* l_Player = p_Pet->GetOwner();
                if (l_Player == nullptr)
                    return;

                if (l_Player->HasSpell(109212) && !l_Player->HasAura(118694))
                    l_Player->CastSpell(l_Player, 118694, true);
            });
        }));
    });

    m_temporaryUnsummonedPetNumber = 0;
}

bool Player::canSeeSpellClickOn(Creature const* c) const
{
    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(c->GetEntry());
    if (clickPair.first == clickPair.second)
        return true;

    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
    {
        if (!itr->second.IsFitToRequirements(this, c))
            return false;

        if (!sConditionMgr->IsObjectMeetingSpellClickConditions(c->GetEntry(), itr->second.spellId, const_cast<Player*>(this), const_cast<Creature*>(c)))
            return false;
    }

    return true;
}

void Player::BuildPlayerTalentsInfoData(WorldPacket * p_Data)
{
    uint8 l_SpeCount = GetSpecsCount();

    if (l_SpeCount > MAX_TALENT_SPECS)
        SetSpecsCount(MAX_TALENT_SPECS);

    *p_Data << uint8(GetActiveSpec());
    *p_Data << uint32(l_SpeCount);

    for (uint8 l_SpeIT = 0; l_SpeIT < l_SpeCount; ++l_SpeIT)
    {
        PlayerTalentMap & l_PlayerTalent = *GetTalentMap(l_SpeIT);
        ByteBuffer l_Talents(400);
        int l_TalentCount = 0;

        for (PlayerTalentMap::iterator itr = l_PlayerTalent.begin(); itr != l_PlayerTalent.end(); ++itr)
        {
            SpellInfo const* l_SpellInfo = sSpellMgr->GetSpellInfo((*itr).first);

            if (l_SpellInfo && !l_SpellInfo->m_TalentIDs.empty() && itr->second->state != PLAYERSPELL_REMOVED)
            {
                uint32 l_SpecID = GetSpecializationId();
                uint16 l_Talent = 0;

                for (uint32 l_TalentID : l_SpellInfo->m_TalentIDs)
                {
                    if (TalentEntry const* l_TalentEntry = sTalentStore.LookupEntry(l_TalentID))
                    {
                        if (l_TalentEntry->SpecID == l_SpecID)
                        {
                            l_Talent = l_TalentID;
                            break;
                        }

                        l_Talent = l_TalentID;
                    }
                }

                l_Talents << uint16(l_Talent);
                l_TalentCount++;
            }
        }

        *p_Data << uint32(GetSpecializationId(l_SpeIT));
        *p_Data << uint32(l_TalentCount);

        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
            *p_Data << uint16(GetGlyph(l_SpeIT, i));

        p_Data->append(l_Talents);
    }
}

void Player::SendTalentsInfoData(bool pet)
{
    if (pet)
    {
        Pet* pPet = GetPet();
        WorldPacket data(SMSG_SET_PET_SPECIALIZATION);
        data << uint16(pPet ? pPet->GetSpecializationId() : 0);     ///< SpecId
        GetSession()->SendPacket(&data);
        return;
    }

    // Update free talents points client-side
    SetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS, CalculateTalentsPoints());

    WorldPacket data(SMSG_UPDATE_TALENT_DATA);
    BuildPlayerTalentsInfoData(&data);
    GetSession()->SendPacket(&data);
}

void Player::SendTalentsInvoluntarilyReset(bool p_IsPet /*= false*/)
{
    WorldPacket l_Data(Opcodes::SMSG_TALENTS_INVOLUNTARILY_RESET, 1);
    l_Data.WriteBit(p_IsPet);
    l_Data.FlushBits();
    GetSession()->SendPacket(&l_Data);
}

void Player::BuildEnchantmentsInfoData(WorldPacket* data)
{
    uint32 slotUsedMask = 0;
    size_t slotUsedMaskPos = data->wpos();
    *data << uint32(slotUsedMask);                          // slotUsedMask < 0x80000

    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i);

        if (!item)
            continue;

        slotUsedMask |= (1 << i);

        *data << uint32(item->GetEntry());                  // item entry

        uint16 enchantmentMask = 0;
        size_t enchantmentMaskPos = data->wpos();
        *data << uint16(enchantmentMask);                   // enchantmentMask < 0x1000

        for (uint32 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
        {
            uint32 enchId = item->GetEnchantmentId(EnchantmentSlot(j));

            if (!enchId)
                continue;

            enchantmentMask |= (1 << j);

            *data << uint16(enchId);                        // enchantmentId?
        }

        data->put<uint16>(enchantmentMaskPos, enchantmentMask);

        *data << uint16(0);                                 // unknown
        data->appendPackGUID(item->GetGuidValue(ITEM_FIELD_CREATOR)); // item creator
        *data << uint32(0);                                 // seed?
    }

    data->put<uint32>(slotUsedMaskPos, slotUsedMask);
}

void Player::SendEquipmentSetList()
{
    /// Clear old equipmentset with local realm guid
    WorldPacket l_Data(SMSG_EQUIPMENT_SET_LIST);
    l_Data << uint32(0);
    GetSession()->SendPacket(&l_Data);

    uint32 l_EquipmentSetCount = 0;

    l_Data.Initialize(SMSG_EQUIPMENT_SET_LIST, 4 * 1024);

    for (EquipmentSets::iterator l_Itr = m_EquipmentSets.begin(); l_Itr != m_EquipmentSets.end(); ++l_Itr)
    {
        if (l_Itr->second.state == EQUIPMENT_SET_DELETED)
            continue;

        ++l_EquipmentSetCount;
    }

    l_Data << uint32(l_EquipmentSetCount);

    for (EquipmentSets::iterator l_Itr = m_EquipmentSets.begin(); l_Itr != m_EquipmentSets.end(); ++l_Itr)
    {
        if (l_Itr->second.state == EQUIPMENT_SET_DELETED)
            continue;

        l_Data << uint64(l_Itr->second.Guid);   ///< Guid
        l_Data << uint32(l_Itr->first);
        l_Data << uint32(0);

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            // ignored slots stored in IgnoreMask, client wants "1" as raw GUID, so no HIGHGUID_ITEM
            if (l_Itr->second.IgnoreMask & (1 << i))
                l_Data.appendPackGUID(0);
            else
                l_Data.appendPackGUID(MAKE_NEW_GUID(l_Itr->second.Items[i], 0, HIGHGUID_ITEM));
        }

        l_Data.WriteBits(l_Itr->second.Name.size(), 8);
        l_Data.WriteBits(l_Itr->second.IconName.size(), 9);
        l_Data.FlushBits();

        l_Data.WriteString(l_Itr->second.Name);
        l_Data.WriteString(l_Itr->second.IconName);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::SetEquipmentSet(uint32 index, EquipmentSet eqset)
{
    if (eqset.Guid != 0)
    {
        bool found = false;

        for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
        {
            if ((itr->second.Guid == eqset.Guid) && (itr->first == index))
            {
                found = true;
                break;
            }
        }

        if (!found)                                          // something wrong...
        {
            sLog->outError(LOG_FILTER_PLAYER, "Player %s tried to save equipment set " UI64FMTD " (index %u), but that equipment set not found!", GetName(), eqset.Guid, index);
            return;
        }
    }

    EquipmentSet& eqslot = m_EquipmentSets[index];

    EquipmentSetUpdateState old_state = eqslot.state;

    eqslot = eqset;

    if (eqset.Guid == 0)
#ifndef CROSS
        eqslot.Guid = sObjectMgr->GenerateEquipmentSetGuid();
#else /* CROSS */
        eqslot.Guid = InterRealmClient::GetIRClient(this)->GenerateLocalRealmLowGuid(HIGHGUID_EQUIPMENT_SET);
#endif /* CROSS */

    eqslot.state = old_state == EQUIPMENT_SET_NEW ? EQUIPMENT_SET_NEW : EQUIPMENT_SET_CHANGED;
}

void Player::_SaveEquipmentSets(SQLTransaction& trans)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end();)
    {
        uint32 index = itr->first;
        EquipmentSet& eqset = itr->second;
        PreparedStatement* stmt = NULL;
        uint8 j = 0;
        switch (eqset.state)
        {
            case EQUIPMENT_SET_UNCHANGED:
                ++itr;
                break;                                      // nothing do
            case EQUIPMENT_SET_CHANGED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_UPD_EQUIP_SET);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                stmt->setUInt32(j++, GetRealGUID());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j, index);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_NEW:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_EQUIP_SET);
                stmt->setUInt32(j++, GetRealGUIDLow());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j++, index);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_DELETED:
                stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_EQUIP_SET);
                stmt->setUInt64(0, eqset.Guid);
                trans->Append(stmt);
                m_EquipmentSets.erase(itr++);
                break;
        }
    }
}

#ifdef CROSS
void Player::SaveArenaData()
{
    InterRealmDatabasePool* conn = NULL;
    if (InterRealmClient* irc = GetSession()->GetInterRealmClient())
        conn = irc->GetDatabase();

    if (!conn)
        return;

    SQLTransaction trans = conn->BeginTransaction();

    _SaveArenaData(trans);

    conn->CommitTransaction(trans);
}
#endif

void Player::_SaveArenaData(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_ARENA_DATA);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);

    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_ARENA_DATA);
    stmt->setUInt32(0, GetRealGUIDLow());

    uint8 j = 1;
    for (uint8 i = 0; i < MAX_PVP_SLOT; ++i)
    {
        stmt->setUInt32(j++, m_ArenaPersonalRating[i]);
        stmt->setUInt32(j++, m_BestRatingOfWeek[i]);
        stmt->setUInt32(j++, m_BestRatingOfSeason[i]);
        stmt->setInt32(j++, m_ArenaMatchMakerRating[i]);
        stmt->setUInt32(j++, m_WeekGames[i]);
        stmt->setUInt32(j++, m_WeekWins[i]);
        stmt->setUInt32(j++, m_PrevWeekWins[i]);
        stmt->setUInt32(j++, m_PrevWeekGames[i]);
        stmt->setUInt32(j++, m_SeasonGames[i]);
        stmt->setUInt32(j++, m_SeasonWins[i]);
    }
    trans->Append(stmt);
}

void Player::_SaveBGData(SQLTransaction& trans)
{
    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
    stmt->setUInt32(0, GetRealGUIDLow());
    trans->Append(stmt);
    /* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell, lastActiveSpec, lastSpecId */
    stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_PLAYER_BGDATA);
    stmt->setUInt32(0, GetRealGUIDLow());
    stmt->setUInt32(1, m_bgData.bgInstanceID);
    stmt->setUInt16(2, m_bgData.bgTeam);
    stmt->setFloat (3, m_bgData.joinPos.GetPositionX());
    stmt->setFloat (4, m_bgData.joinPos.GetPositionY());
    stmt->setFloat (5, m_bgData.joinPos.GetPositionZ());
    stmt->setFloat (6, m_bgData.joinPos.GetOrientation());
    stmt->setUInt16(7, m_bgData.joinPos.GetMapId());
    stmt->setUInt16(8, m_bgData.taxiPath[0]);
    stmt->setUInt16(9, m_bgData.taxiPath[1]);
    stmt->setUInt16(10, m_bgData.mountSpell);
    stmt->setUInt8(11, m_bgData.m_LastActiveSpec);
    stmt->setUInt32(12, m_bgData.bgTypeID);
    trans->Append(stmt);
}

#ifdef CROSS
void Player::SaveCrossServerArenaData()
{
    if (!GetSession() || !GetSession()->GetInterRealmClient())
        return;

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    trans->PAppend("REPLACE INTO character_arena_data (guid, realmId, name, class, rating0, bestRatingOfWeek0, bestRatingOfSeason0, matchMakerRating0, weekGames0, weekWins0, prevWeekWins0, seasonGames0, seasonWins0, rating1, bestRatingOfWeek1, bestRatingOfSeason1, matchMakerRating1, weekGames1, weekWins1, prevWeekWins1, seasonGames1, seasonWins1, rating2, bestRatingOfWeek2, bestRatingOfSeason2, matchMakerRating2, weekGames2, weekWins2, prevWeekWins2, seasonGames2, seasonWins2, rating3, bestRatingOfWeek3, bestRatingOfSeason3, matchMakerRating3, weekGames3, weekWins3, prevWeekWins3, seasonGames3, seasonWins3) VALUES "
        "(%u, %u, '%s', %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u)",
        GetRealGUIDLow(), GetSession()->GetInterRealmClient()->GetRealmId(), GetName(), getClass(),
        m_ArenaPersonalRating[0], m_BestRatingOfWeek[0], m_BestRatingOfSeason[0], m_ArenaMatchMakerRating[0],
        m_WeekGames[0], m_WeekWins[0], m_PrevWeekWins[0], m_SeasonGames[0], m_SeasonWins[0],
        m_ArenaPersonalRating[1], m_BestRatingOfWeek[1], m_BestRatingOfSeason[1], m_ArenaMatchMakerRating[1],
        m_WeekGames[1], m_WeekWins[1], m_PrevWeekWins[1], m_SeasonGames[1], m_SeasonWins[1],
        m_ArenaPersonalRating[2], m_BestRatingOfWeek[2], m_BestRatingOfSeason[2], m_ArenaMatchMakerRating[2],
        m_WeekGames[2], m_WeekWins[2], m_PrevWeekWins[2], m_SeasonGames[2], m_SeasonWins[2],
        m_ArenaPersonalRating[3], m_BestRatingOfWeek[3], m_BestRatingOfSeason[3], m_ArenaMatchMakerRating[3],
        m_WeekGames[3], m_WeekWins[3], m_PrevWeekWins[3], m_SeasonGames[3], m_SeasonWins[3]);

    CharacterDatabase.CommitTransaction(trans);
}
#endif

void Player::DeleteEquipmentSet(uint64 setGuid)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
    {
        if (itr->second.Guid == setGuid)
        {
            if (itr->second.state == EQUIPMENT_SET_NEW)
                m_EquipmentSets.erase(itr);
            else
                itr->second.state = EQUIPMENT_SET_DELETED;
            break;
        }
    }
}

void Player::RemoveAtLoginFlag(AtLoginFlags p_Flags, bool p_Persist /*= false*/)
{
    m_atLoginFlags &= ~p_Flags;

    if (p_Persist)
        Player::RemoveAtLoginFlagFromDB(GetGUIDLow(), p_Flags);
}

void Player::RemoveAtLoginFlagFromDB(uint32 p_Guid, AtLoginFlags p_Flags)
{
    PreparedStatement* l_Stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_REM_AT_LOGIN_FLAG);

    l_Stmt->setUInt16(0, uint16(p_Flags));
    l_Stmt->setUInt32(1, p_Guid);

    CharacterDatabase.Execute(l_Stmt);
}

void Player::SendClearCooldown(uint32 p_SpellID, Unit* p_Target, bool p_ClearOnHold)
{
    WorldPacket l_Data(SMSG_CLEAR_COOLDOWN);

    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(p_ClearOnHold);
    l_Data.WriteBit(p_Target == GetPet());             ///< IsPetCooldown
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::ResetMap()
{
    // this may be called during Map::Update
    // after decrement+unlink, ++m_mapRefIter will continue correctly
    // when the first element of the list is being removed
    // nocheck_prev will return the padding element of the RefManager
    // instead of NULL in the case of prev
    GetMap()->UpdateIteratorBack(this);
    Unit::ResetMap();
    GetMapRef().unlink();
}

void Player::SetMap(Map* map)
{
    Unit::SetMap(map);
    m_mapRef.link(map, this);
}

void Player::_LoadGlyphs(PreparedQueryResult result)
{
    // SELECT spec, glyph1, glyph2, glyph3, glyph4, glyph5, glyph6 FROM character_glyphs WHERE guid = '%u'
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint8 spec = fields[0].GetUInt8();
        if (spec >= GetSpecsCount())
            continue;

        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
            _talentMgr->SpecInfo[spec].Glyphs[i] = fields[i + 1].GetUInt16();
    }
    while (result->NextRow());

    m_glyphsChanged = false;
}

void Player::_SaveGlyphs(SQLTransaction& trans)
{
    if (!m_glyphsChanged)
        return;

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (uint8 spec = 0; spec < GetSpecsCount(); ++spec)
    {
        uint8 index = 0;

        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
        stmt->setUInt32(index++, GetRealGUIDLow());
        stmt->setUInt8(index++, spec);

        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
            stmt->setUInt16(index++, uint16(GetGlyph(spec, i)));

        trans->Append(stmt);
    }

    m_glyphsChanged = false;
}

void Player::_LoadTalents(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS, "SELECT spell, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
            AddTalent((*result)[0].GetUInt32(), (*result)[1].GetUInt8(), false);
        while (result->NextRow());
    }
}

void Player::_SaveTalents(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
    {
        for (PlayerTalentMap::iterator itr = GetTalentMap(i)->begin(); itr != GetTalentMap(i)->end();)
        {
            if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
            {
                stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt32(1, itr->first);
                stmt->setUInt8(2, itr->second->spec);
                trans->Append(stmt);
            }

            if (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED)
            {
                if (itr->second->spec > 1)
                {
                    sLog->outAshran("Invalid spec index (%d > 1) on player %s (%ull), not saving talent to prevent crash at loading", itr->second->spec, m_name.c_str(), GetGUID());
                    continue;
                }

                stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
                stmt->setUInt32(0, GetRealGUIDLow());
                stmt->setUInt32(1, itr->first);
                stmt->setUInt8(2, itr->second->spec);
                trans->Append(stmt);
            }

            if (itr->second->state == PLAYERSPELL_REMOVED)
            {
                delete itr->second;
                GetTalentMap(i)->erase(itr++);
            }
            else
            {
                itr->second->state = PLAYERSPELL_UNCHANGED;
                ++itr;
            }
        }
    }
}

void Player::UpdateSpecCount(uint8 count)
{
    uint32 curCount = GetSpecsCount();
    if (curCount == count)
        return;

    if (GetActiveSpec() >= count)
        ActivateSpec(0);

    SQLTransaction trans = RealmDatabase.BeginTransaction();
    PreparedStatement* stmt = NULL;

    // Copy spec data
    if (count > curCount)
    {
        _SaveActions(trans); // make sure the button list is cleaned up
        for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end(); ++itr)
        {
            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
            stmt->setUInt32(0, GetRealGUIDLow());
            stmt->setUInt8(1, 1);
            stmt->setUInt8(2, itr->first);
            stmt->setUInt32(3, itr->second.GetAction());
            stmt->setUInt8(4, uint8(itr->second.GetType()));
            trans->Append(stmt);
        }
    }
    // Delete spec data for removed spec.
    else if (count < curCount)
    {
        _SaveActions(trans);

        stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC);
        stmt->setUInt8(0, GetActiveSpec());
        stmt->setUInt32(1, GetRealGUIDLow());
        trans->Append(stmt);

    }

    RealmDatabase.CommitTransaction(trans);

    SetSpecsCount(count);

    SendTalentsInfoData(false);
}

void Player::ActivateSpec(uint8 spec)
{
    if (GetActiveSpec() == spec)
        return;

    if (spec > GetSpecsCount())
        return;

    if (IsNonMeleeSpellCasted(false))
        InterruptNonMeleeSpells(false);

    SQLTransaction trans = RealmDatabase.BeginTransaction();
    _SaveActions(trans);
    RealmDatabase.CommitTransaction(trans);

    // TO-DO: We need more research to know what happens with warlock's reagent
    if (Pet* pet = GetPet())
        RemovePet(pet, PET_SLOT_ACTUAL_PET_SLOT, true, pet->m_Stampeded);

    ClearComboPoints();
    ClearAllReactives();
    UnsummonAllTotems();
    RemoveAllControlled();
    RemoveAllAurasOnDeath();
    if (GetPet())
        GetPet()->RemoveAllAurasOnDeath();

    //RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
    //ExitVehicle(); // should be impossible to switch specs from inside a vehicle..

    // Let client clear his current Actions
    SendActionButtons(2);
    // m_actionButtons.clear() is called in the next _LoadActionButtons

    for (auto itr : *GetTalentMap(GetActiveSpec()))
    {
        removeSpell(itr.first, true); // removes the talent, and all dependant, learned, and chained spells..
        if (const SpellInfo* _spellEntry = sSpellMgr->GetSpellInfo(itr.first))
        {
            for (uint8 i = 0; i < _spellEntry->EffectCount; ++i)                  // search through the SpellInfo for valid trigger spells
                if (_spellEntry->Effects[i].TriggerSpell > 0 && _spellEntry->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
                    removeSpell(_spellEntry->Effects[i].TriggerSpell, true); // and remove any spells that the talent teaches

            for (uint8 i = 0; i < _spellEntry->EffectCount; ++i)
                if (_spellEntry->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS || _spellEntry->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2)
                    RemoveAurasDueToSpell(_spellEntry->Effects[i].BasePoints);
        }

    }

    RemoveSpecializationSpells();

    // set glyphs
    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
        // remove secondary glyph
        if (uint32 oldglyph = GetGlyph(GetActiveSpec(), slot))
            if (GlyphPropertiesEntry const* old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
                RemoveAurasDueToSpell(old_gp->SpellId);

    float l_HPPct = GetHealthPct();

    for (uint8 l_I = 0; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            _ApplyItemMods(l_Item, l_I, false);
            RemoveItemsSetItem(this, l_Item->GetTemplate());
        }
    }

    SetActiveSpec(spec);
    SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, GetSpecializationId(spec));

    for (uint8 l_I = 0; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            _ApplyItemMods(l_Item, l_I, true);
            AddItemsSetItem(this, l_Item);
        }
    }

    SetHealth(GetMaxHealth() * l_HPPct / 100.0f);

    uint32 usedTalentPoint = 0;
    for (auto itr : *GetTalentMap(GetActiveSpec()))
    {
        learnSpell(itr.first, false);
        usedTalentPoint++;
    }

    // set glyphs
    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
    {
        uint32 glyph = GetGlyph(GetActiveSpec(), slot);

        // apply primary glyph
        if (glyph)
        {
            bool l_CanApplyGlyph = true;

            if (GlyphPropertiesEntry const* l_GlyphProperties = sGlyphPropertiesStore.LookupEntry(glyph))
            {
                if (l_GlyphProperties->GlyphExclusiveCategoryID)
                {
                    for (uint8 l_GlyphSlotIndex = 0; l_GlyphSlotIndex < MAX_GLYPH_SLOT_INDEX; ++l_GlyphSlotIndex)
                    {
                        uint32 l_GlyphID = GetGlyph(GetActiveSpec(), l_GlyphSlotIndex);
                        if (!l_GlyphID)
                            continue;

                        GlyphPropertiesEntry const* l_GlyphPropertiesCheck = sGlyphPropertiesStore.LookupEntry(l_GlyphID);
                        if (!l_GlyphPropertiesCheck)
                            continue;

                        if (l_GlyphPropertiesCheck->GlyphExclusiveCategoryID == l_GlyphProperties->GlyphExclusiveCategoryID && glyph != l_GlyphID)
                        {
                            l_CanApplyGlyph = false;
                            break;
                        }
                    }

                    if (!l_CanApplyGlyph)
                        continue;
                }

                CastSpell(this, l_GlyphProperties->SpellId, true);
            }
        }

        SetGlyph(slot, glyph);
    }

    for (uint8 i = POWER_MANA; i < MAX_POWERS; ++i)
    {
        SetMaxPower(Powers(i), GetCreatePowers(Powers(i)));
        SetPower(Powers(i), 0);
    }

    SetUsedTalentCount(usedTalentPoint);
    InitTalentForLevel();
    InitSpellForLevel();
    if (Powers l_PowerType = getPowerType())
        UpdateMaxPower(l_PowerType);

    {
        PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC);
        stmt->setUInt32(0, GetRealGUIDLow());
        stmt->setUInt8(1, GetActiveSpec());
        if (PreparedQueryResult result = RealmDatabase.Query(stmt))
            _LoadActions(result);
    }

    /// Boundless Conviction isn't refreshed automatically on respec
    if (getClass() == CLASS_PALADIN && HasAura(115675))
    {
        UpdateMaxPower(POWER_HOLY_POWER);
    }

    SendActionButtons(1);
}

void Player::ResetTimeSync()
{
    m_timeSyncCounter = 0;
    m_timeSyncTimer = 0;
    m_timeSyncClient = 0;
    m_timeSyncServer = getMSTime();
}

void Player::SendTimeSync()
{
    WorldPacket data(SMSG_TIME_SYNC_REQUEST, 4);
    data << uint32(m_timeSyncCounter++);
    GetSession()->SendPacket(&data);

    // Schedule next sync in 10 sec
    m_timeSyncTimer = 10000;
    m_timeSyncServer = getMSTime();
}

void Player::SetReputation(uint32 factionentry, uint32 value)
{
    GetReputationMgr().SetReputation(sFactionStore.LookupEntry(factionentry), value);
}

uint32 Player::GetReputation(uint32 factionentry)
{
    return GetReputationMgr().GetReputation(sFactionStore.LookupEntry(factionentry));
}

std::string Player::GetGuildName()
{
#ifndef CROSS
    return GetGuildId() ? sGuildMgr->GetGuildById(GetGuildId())->GetName() : "";
#else /* CROSS */
    return GetGuild() ? sGuildMgr->GetInterRealmGuild(GetSession()->GetInterRealmNumber(), GetGuildId())->GetName() : "";
#endif /* CROSS */
}

void Player::MountSetFavorite(uint32 p_SpellID, bool p_IsFavorite)
{
    if (m_spells.find(p_SpellID) == m_spells.end())
        return;

    m_spells[p_SpellID]->IsMountFavorite = p_IsFavorite;
#ifndef CROSS
    m_spells[p_SpellID]->state = PLAYERSPELL_CHANGED;
#endif /* CROSS */

    WorldPacket l_Data(SMSG_ACCOUNT_MOUNT_UPDATE, 1 + 4 + 4 + 4 + 1);
    l_Data.WriteBit(false); ///< Is full update
    l_Data.FlushBits();
    l_Data << uint32(1);    ///< One update
    l_Data << uint32(1);    ///< One update

    l_Data << uint32(p_SpellID);
    l_Data.WriteBit(p_IsFavorite);
    l_Data.FlushBits();

    SendDirectMessage(&l_Data);
}

void Player::SendDuelCountdown(uint32 p_Coutdown)
{
    WorldPacket data(SMSG_DUEL_COUNTDOWN, 4);
    data << uint32(p_Coutdown);                 ///< seconds
    GetSession()->SendPacket(&data);
}

void Player::AddRefundReference(uint32 p_Iter)
{
    m_refundableItems.insert(p_Iter);
}

void Player::DeleteRefundReference(uint32 p_Iter)
{
    std::set<uint32>::iterator l_Iter = m_refundableItems.find(p_Iter);
    if (l_Iter != m_refundableItems.end())
        m_refundableItems.erase(l_Iter);
}

void Player::SendRefundInfo(Item* p_Item)
{
    /// This function call unset ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
    p_Item->UpdatePlayedTime(this);

    if (!p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
        return;

    if (GetGUIDLow() != p_Item->GetRefundRecipient()) ///< Formerly refundable item got traded
    {
        p_Item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* l_ExtendedCost = sItemExtendedCostStore.LookupEntry(p_Item->GetPaidExtendedCost());
    if (!l_ExtendedCost)
        return;

    ObjectGuid l_ItemGUID = p_Item->GetGUID();
    WorldPacket l_Data(SMSG_SET_ITEM_PURCHASE_DATA);

    l_Data.appendPackGUID(l_ItemGUID);

    /// Content
    {
        l_Data << uint32(p_Item->GetPaidMoney());                               ///< Money cost

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
        {
            l_Data << uint32(l_ExtendedCost->RequiredItem[l_I]);
            l_Data << uint32(l_ExtendedCost->RequiredItemCount[l_I]);
        }

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
        {
            /// Second field in dbc is season count except one row
            if (l_I == 1 && l_ExtendedCost->ID != 2999)
            {
                l_Data << uint32(0);
                l_Data << uint32(0);
                continue;
            }

            l_Data << uint32(l_ExtendedCost->RequiredCurrency[l_I]);
            l_Data << uint32(l_ExtendedCost->RequiredCurrencyCount[l_I]);
        }
    }

    l_Data << uint32(0);                                                        ///< Flags
    l_Data << uint32(GetTotalPlayedTime() - p_Item->GetPlayedTime());           ///< Time Left

    GetSession()->SendPacket(&l_Data);
}

Item* Player::AddItem(uint32 p_ItemId, uint32 p_Count, std::list<uint32> p_Bonuses, bool p_FromShop)
{
    ItemPosCountVec l_Dest;
    InventoryResult l_Message = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, p_ItemId, p_Count);

    if (l_Message != EQUIP_ERR_OK)
        return nullptr;

    Item* l_Item = StoreNewItem(l_Dest, p_ItemId, true, Item::GenerateItemRandomPropertyId(p_ItemId));
    if (l_Item)
    {
        for (auto l_Bonus : p_Bonuses)
            l_Item->AddItemBonus(l_Bonus);

        std::vector<uint32> l_Bonus;
        Item::GenerateItemBonus(l_Item->GetEntry(), ItemContext::None, l_Bonus);
        l_Item->AddItemBonuses(l_Bonus);

        if (p_FromShop)
            l_Item->ApplyCustomFlags(ItemCustomFlags::FromStore);

        SendNewItem(l_Item, p_Count, true, false);

        return l_Item;
    }

    return nullptr;
}

void Player::SendItemRefundResult(Item* p_Item, ItemExtendedCostEntry const* p_ExtendedCost, uint8 p_Error)
{
    WorldPacket l_Data(Opcodes::SMSG_ITEM_PURCHASE_REFUND_RESULT);
    l_Data.appendPackGUID(p_Item->GetGUID());
    l_Data << uint8(p_Error);
    l_Data.WriteBit(!p_Error);

    if (!p_Error)
    {
        l_Data << uint32(p_Item->GetPaidMoney());

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
        {
            l_Data << uint32(p_ExtendedCost->RequiredItem[l_I]);
            l_Data << uint32(p_ExtendedCost->RequiredItemCount[l_I]);
        }

        for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
        {
            CurrencyTypesEntry const* l_CurrTemplate = sCurrencyTypesStore.LookupEntry(p_ExtendedCost->RequiredCurrency[l_I]);
            if (l_CurrTemplate != nullptr)
            {
                l_Data << uint32(p_ExtendedCost->RequiredCurrency[l_I]);

                if (l_CurrTemplate->Flags & CurrencyFlags::CURRENCY_FLAG_HIGH_PRECISION)
                    l_Data << uint32(p_ExtendedCost->RequiredCurrencyCount[l_I]);
                else
                    l_Data << uint32(p_ExtendedCost->RequiredCurrencyCount[l_I] / 100);
            }
            else
            {
                l_Data << uint32(0);
                l_Data << uint32(0);
            }
        }
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::RefundItem(Item* p_Item)
{
    if (!p_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
        return;

    if (p_Item->IsRefundExpired())    ///< Item refund has expired
    {
        p_Item->SetNotRefundable(this);
        SendItemRefundResult(p_Item, NULL, 10);
        return;
    }

    if (GetGUIDLow() != p_Item->GetRefundRecipient()) ///< Formerly refundable item got traded
    {
        p_Item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* l_ExtendedCost = sItemExtendedCostStore.LookupEntry(p_Item->GetPaidExtendedCost());
    if (!l_ExtendedCost)
        return;

    bool l_StoreError = false;
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_ITEMS; ++l_I)
    {
        uint32 l_Count = l_ExtendedCost->RequiredItemCount[l_I];
        uint32 l_ItemID = l_ExtendedCost->RequiredItem[l_I];

        if (l_Count && l_ItemID)
        {
            ItemPosCountVec l_Dest;
            InventoryResult l_InvResult = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemID, l_Count);
            if (l_InvResult != EQUIP_ERR_OK)
            {
                l_StoreError = true;
                break;
            }
         }
    }

    if (l_StoreError)
    {
        SendItemRefundResult(p_Item, l_ExtendedCost, 10);
        return;
    }

    /// Check total cap
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        /// Second field in dbc is season count except one row
        if (l_I == 1 && l_ExtendedCost->ID != 2999)
            continue;

        uint32 l_CurrencyID = l_ExtendedCost->RequiredCurrency[l_I];
        CurrencyTypesEntry const* l_CurrencyType = sCurrencyTypesStore.LookupEntry(l_CurrencyID);
        if (!l_CurrencyType)
            continue;

        uint32 l_Count = l_ExtendedCost->RequiredCurrencyCount[l_I] / l_CurrencyType->GetPrecision();
        uint32 l_CurrCount = GetCurrency(l_CurrencyID, l_CurrencyType->HasPrecision());

        if (l_CurrencyType->TotalCap && (l_CurrCount + l_Count > (l_CurrencyType->TotalCap / l_CurrencyType->GetPrecision())))
        {
            SendItemRefundResult(p_Item, l_ExtendedCost, 10);
            return;
        }
    }

    SendItemRefundResult(p_Item, l_ExtendedCost, 0);

    uint32 l_MoneyRefund = p_Item->GetPaidMoney();  ///< Item-> will be invalidated in DestroyItem

    /// Save all relevant data to DB to prevent desynchronizing exploits
    SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();

    /// Delete any references to the refund data
    p_Item->SetNotRefundable(this, true, &l_Transaction);

    /// Destroy item
    DestroyItem(p_Item->GetBagSlot(), p_Item->GetSlot(), true);

    /// Grant back extended cost items ...
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        uint32 l_Count = l_ExtendedCost->RequiredItemCount[l_I];
        uint32 l_ItemID = l_ExtendedCost->RequiredItem[l_I];

        if (l_Count && l_ItemID)
        {
            ItemPosCountVec l_Dest;
            InventoryResult l_InvResult = CanStoreNewItem(NULL_BAG, NULL_SLOT, l_Dest, l_ItemID, l_Count);
            ASSERT(l_InvResult == EQUIP_ERR_OK) ///< Already checked before
            Item* l_Item = StoreNewItem(l_Dest, l_ItemID, true);
            SendNewItem(l_Item, l_Count, true, false, true);
        }
    }

    /// ... and currencies
    for (uint8 l_I = 0; l_I < MAX_ITEM_EXT_COST_CURRENCIES; ++l_I)
    {
        /// Second field in dbc is season count except one row
        if (l_I == 1 && l_ExtendedCost->ID != 2999)
            continue;

        uint32 l_CurrencyID = l_ExtendedCost->RequiredCurrency[l_I];
        uint32 l_Count = l_ExtendedCost->RequiredCurrencyCount[l_I];

        if (l_CurrencyID && l_Count)
            ModifyCurrency(l_CurrencyID, l_Count, false, true, true);
    }

    /// Grant back money
    if (l_MoneyRefund)
        ModifyMoney(l_MoneyRefund); ///< Saved in SaveInventoryAndGoldToDB

    /// Grant back Arena and Honor points ?

    SaveInventoryAndGoldToDB(l_Transaction);

    RealmDatabase.CommitTransaction(l_Transaction);
}

void Player::SetRandomWinner(bool p_IsWinner, bool p_DatabaseUpdate)
{
    m_IsBGRandomWinner = p_IsWinner;
    if (m_IsBGRandomWinner && p_DatabaseUpdate)
    {
        PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_BATTLEGROUND_RANDOM);
        stmt->setUInt32(0, GetRealGUIDLow());
        RealmDatabase.Execute(stmt);
    }
}

void Player::_LoadRandomBGStatus(PreparedQueryResult result)
{
    //QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());

    if (result)
        m_IsBGRandomWinner = true;
}

uint32 Player::GetAverageItemLevelEquipped() const
{
    int32 l_Sum = 0;
    uint32 l_Count = 0;
    bool l_HasTwoHanded = false;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged, offhand or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            if (i == EQUIPMENT_SLOT_MAINHAND && l_Item->GetTemplate()->IsTwoHandedWeapon())
                l_HasTwoHanded = true;

            l_Sum += l_Item->GetTemplate()->GetItemLevelIncludingQuality(m_itemScale[i]);
            ++l_Count;
        }
        else if (i == EQUIPMENT_SLOT_OFFHAND && !CanTitanGrip() && (l_HasTwoHanded))
            continue;
        else
            ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}

uint32 Player::GetAverageItemLevelTotal() const
{
    // If player has a 2h ignore offhand if not found (if found fury and count it)
    // If player does not have a 2h check offhand
    int l_EquipItemLevel[EQUIPMENT_SLOT_END];

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            l_EquipItemLevel[i] = 0;
            continue;
        }

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            l_EquipItemLevel[i] = l_Item->GetTemplate()->GetItemLevelIncludingQuality(m_itemScale[i]);

            if (i == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

            if (i == EQUIPMENT_SLOT_OFFHAND && l_Item->GetTemplate()->Class == ITEM_CLASS_WEAPON)
                l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND]);

            continue;
        }

        l_EquipItemLevel[i] = 0;
    }

    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1], l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1], l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (l_Item->IsSuitableForItemLevelCalulcation(true))
            {
                int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(GetEquipItemLevelFor(l_Item->GetTemplate(), l_Item));

                if (slot != NULL_SLOT)
                {
                    if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                        l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* l_Item = pBag->GetItemByPos(j))
                {
                    if (l_Item->IsSuitableForItemLevelCalulcation(true))
                    {
                        int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                        int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(GetEquipItemLevelFor(l_Item->GetTemplate(), l_Item));

                        if (slot != NULL_SLOT)
                        {
                            if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                        }
                    }
                }
            }
        }
    }

    int32 l_Sum = 0;
    uint32 l_Count = 0;
    bool l_HasTwoHanded = false;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged, offhand or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            if (i == EQUIPMENT_SLOT_MAINHAND && l_Item->GetTemplate()->IsTwoHandedWeapon())
                l_HasTwoHanded = true;

            l_Sum += l_EquipItemLevel[i];
            ++l_Count;
        }
        else if (i == EQUIPMENT_SLOT_OFFHAND && !CanTitanGrip() && (l_HasTwoHanded))
            continue;
        else
            ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}


uint32 Player::GetAverageItemLevelTotalWithOrWithoutPvPBonus(bool p_PvP) const
{
    // If player has a 2h ignore offhand if not found (if found fury and count it)
    // If player does not have a 2h check offhand
    int l_EquipItemLevel[EQUIPMENT_SLOT_END];

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            l_EquipItemLevel[i] = 0;
            continue;
        }

        Item* l_Item = m_items[i];
        if (l_Item && l_Item->GetTemplate())
        {
            l_EquipItemLevel[i] = GetEquipItemLevelFor(l_Item->GetTemplate(), l_Item, !p_PvP, p_PvP);

            if (i == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

            if (i == EQUIPMENT_SLOT_OFFHAND && l_Item->GetTemplate()->Class == ITEM_CLASS_WEAPON)
                l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND] = std::max(l_EquipItemLevel[i], l_EquipItemLevel[EQUIPMENT_SLOT_MAINHAND]);

            continue;
        }

        l_EquipItemLevel[i] = 0;
    }

    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1], l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1], l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = l_EquipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (l_Item->IsSuitableForItemLevelCalulcation(true))
            {
                int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(GetEquipItemLevelFor(l_Item->GetTemplate(), l_Item));

                if (slot != NULL_SLOT)
                {
                    if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                        l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* l_Item = pBag->GetItemByPos(j))
                {
                    if (l_Item->IsSuitableForItemLevelCalulcation(true))
                    {
                        int slot = GetGuessedEquipSlot(l_Item->GetTemplate());
                        int l_ThisIlvl = l_Item->GetTemplate()->GetItemLevelIncludingQuality(GetEquipItemLevelFor(l_Item->GetTemplate(), l_Item));

                        if (slot != NULL_SLOT)
                        {
                            if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && l_Item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && l_Item->GetTemplate()->IsTwoHandedWeapon())))
                                l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(l_ThisIlvl, l_EquipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            l_EquipItemLevel[slot] = std::max(l_EquipItemLevel[slot], l_ThisIlvl);
                        }
                    }
                }
            }
        }
    }

    uint32 l_Sum = 0;
    uint32 l_Count = 0;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        if (i == EQUIPMENT_SLOT_OFFHAND && !l_EquipItemLevel[i])
            continue;

        l_Sum += l_EquipItemLevel[i];
        ++l_Count;
    }

    if (!l_Count)
        return 0;

    return uint32(float(((float)l_Sum) / l_Count));
}

void Player::_LoadInstanceTimeRestrictions(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        _instanceResetTimes.insert(InstanceTimeMap::value_type(fields[0].GetUInt32(), fields[1].GetUInt64()));
    }
    while (result->NextRow());
}

void Player::_LoadCUFProfiles(PreparedQueryResult result)
{
    if (result)
    {
        uint32 count = result->GetRowCount();
        if (count > MAX_CUF_PROFILES)
            count = MAX_CUF_PROFILES;

        m_cufProfiles.resize(count);

        uint32 i = 0;
        do
        {
            Field* fields = result->Fetch();

            CUFProfile& profile = m_cufProfiles[i];

            std::string name = fields[0].GetString();
            uint32 lenght = fields[0].GetStringLength();
            if (lenght > MAX_CUF_PROFILE_NAME_LENGTH)
                continue;

            profile.Name = name;
            profile.l_NameLen = lenght;

            UnpackDBBinary(&profile.data, sizeof(profile.data), fields[1].GetCString(), fields[1].GetStringLength());

            ++i;
        }
        while (i < count && result->NextRow());
    }
    else
        m_cufProfiles.clear();
}

void Player::SendCUFProfiles()
{
    WorldPacket l_Data(SMSG_LOAD_CUF_PROFILES);

    l_Data << uint32(m_cufProfiles.size());

    for (uint32 i = 0; i < m_cufProfiles.size(); ++i)
    {
        CUFProfile& l_Profile = m_cufProfiles[i];
        CUFProfileData& l_ProfileData = l_Profile.data;

        l_Data.WriteBits(l_Profile.l_NameLen, 7);
        l_Data.WriteBit(l_ProfileData.KeepGroupsTogether);
        l_Data.WriteBit(l_ProfileData.DisplayPets);
        l_Data.WriteBit(l_ProfileData.DisplayMainTankAndAssist);
        l_Data.WriteBit(l_ProfileData.DisplayHealPrediction);
        l_Data.WriteBit(l_ProfileData.DisplayAggroHighlight);
        l_Data.WriteBit(l_ProfileData.DisplayOnlyDispellableDebuffs);
        l_Data.WriteBit(l_ProfileData.DisplayPowerBar);
        l_Data.WriteBit(l_ProfileData.DisplayBorder);
        l_Data.WriteBit(l_ProfileData.UseClassColors);
        l_Data.WriteBit(l_ProfileData.HorizontalGroups);
        l_Data.WriteBit(l_ProfileData.DisplayNonBossDebuffs);
        l_Data.WriteBit(l_ProfileData.DynamicPosition);
        l_Data.WriteBit(l_ProfileData.Locked);
        l_Data.WriteBit(l_ProfileData.Shown);
        l_Data.WriteBit(l_ProfileData.AutoActivate2Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate3Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate5Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate10Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate15Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate25Players);
        l_Data.WriteBit(l_ProfileData.AutoActivate40Players);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec1);
        l_Data.WriteBit(l_ProfileData.AutoActivateSpec2);
        l_Data.WriteBit(l_ProfileData.AutoActivatePvP);
        l_Data.WriteBit(l_ProfileData.AutoActivatePvE);
        l_Data.FlushBits();

        l_Data << uint16(l_ProfileData.FrameHeight);
        l_Data << uint16(l_ProfileData.FrameWidth);
        l_Data << uint8(l_ProfileData.SortBy);
        l_Data << uint8(l_ProfileData.HealthText);
        l_Data << uint8(l_ProfileData.TopPoint);
        l_Data << uint8(l_ProfileData.BottomPoint);
        l_Data << uint8(l_ProfileData.LeftPoint);
        l_Data << uint16(l_ProfileData.TopOffset);
        l_Data << uint16(l_ProfileData.BottomOffset);
        l_Data << uint16(l_ProfileData.LeftOffset);

        l_Data.append(l_Profile.Name.c_str(), l_Profile.l_NameLen);
    }

    GetSession()->SendPacket(&l_Data);
}

void Player::_SaveInstanceTimeRestrictions(SQLTransaction& trans)
{
    if (_instanceResetTimes.empty())
        return;

    PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    trans->Append(stmt);

    for (InstanceTimeMap::const_iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end(); ++itr)
    {
        stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES);
        stmt->setUInt32(0, GetSession()->GetAccountId());
        stmt->setUInt32(1, itr->first);
        stmt->setUInt64(2, itr->second);
        trans->Append(stmt);
    }
}

bool Player::IsInWhisperWhiteList(uint64 guid)
{
    for (WhisperListContainer::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
    {
        if (*itr == guid)
            return true;
    }
    return false;
}

bool Player::CanSwitch() const
{
    if (getRace() != RACE_WORGEN)
        return false;

    if (isInCombat() || !HasAuraType(SPELL_AURA_ALLOW_WORGEN_TRANSFORM))
        return false;

    return true;
}

void Player::SwitchForm()
{
    if (!CanSwitch())
        return;

    if (IsInWorgenForm())
        SwitchToHumanForm();
    else
        SwitchToWorgenForm();
}

void Player::SendPetTameResult(PetTameResult p_Result)
{
    WorldPacket l_Data(SMSG_PET_TAME_FAILURE, 4);
    l_Data << uint8(p_Result);

    GetSession()->SendPacket(&l_Data);
}

uint8 Player::GetNextVoidStorageFreeSlot() const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i]) // unused item
            return i;

    return VOID_STORAGE_MAX_SLOT;
}

uint8 Player::GetNumOfVoidStorageFreeSlots() const
{
    uint8 count = 0;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i])
            count++;

    return count;
}

uint8 Player::AddVoidStorageItem(const VoidStorageItem& item)
{
    uint8 slot = GetNextVoidStorageFreeSlot();

    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return 255;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemEntry,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.Bonuses);
    return slot;
}

void Player::AddVoidStorageItemAtSlot(uint8 slot, const VoidStorageItem& item)
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return;
    }

    if (_voidStorageItems[slot])
    {
        sLog->outError(LOG_FILTER_GENERAL, "Player::AddVoidStorageItemAtSlot - Player (GUID: %u, name: %s) tried to add an item to an used slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName(), _voidStorageItems[slot]->ItemId, _voidStorageItems[slot]->ItemEntry, slot);
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemId,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.Bonuses);
}

void Player::DeleteVoidStorageItem(uint8 slot)
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    delete _voidStorageItems[slot];
    _voidStorageItems[slot] = NULL;
}

bool Player::SwapVoidStorageItem(uint8 oldSlot, uint8 newSlot)
{
    if (oldSlot >= VOID_STORAGE_MAX_SLOT || newSlot >= VOID_STORAGE_MAX_SLOT || oldSlot == newSlot)
        return false;

    std::swap(_voidStorageItems[newSlot], _voidStorageItems[oldSlot]);
    return true;
}

VoidStorageItem* Player::GetVoidStorageItem(uint8 slot) const
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return NULL;
    }

    return _voidStorageItems[slot];
}

VoidStorageItem* Player::GetVoidStorageItem(uint64 id, uint8& slot) const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemId == id)
        {
            slot = i;
            return _voidStorageItems[i];
        }
    }

    return NULL;
}

void Player::SendMovementSetCanTransitionBetweenSwimAndFly(bool p_Apply)
{
    WorldPacket l_Data;

    if (p_Apply)
    {
        l_Data.Initialize(SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(0);                ///< Movement counter
    }
    else
    {
        l_Data.Initialize(SMSG_MOVE_UNSET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY, 2 + 16 + 4);
        l_Data.appendPackGUID(GetGUID());
        l_Data << uint32(0);                ///< Movement counter
    }

    SendDirectMessage(&l_Data);
}

/// Disable for now, we didn't use good value for scale / height
void Player::SendMovementSetCollisionHeight(float p_Height)
{
    CreatureDisplayInfoEntry const* l_MountDisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID));
    if (!l_MountDisplayInfo)
    {
        WorldPacket l_Data(SMSG_MOVE_SET_COLLISION_HEIGHT, 16 + 2 + 4 + 4 + 4 + 4 + 1);
        l_Data.appendPackGUID(GetGUID());                   ///< MoverGUID
        l_Data << uint32(sWorld->GetGameTime());            ///< SequenceIndex
        l_Data << float(p_Height);                          ///< Height
        l_Data << float(GetFloatValue(OBJECT_FIELD_SCALE)); ///< Scale
        l_Data << uint32(0);                                ///< MountDisplayID
        l_Data.WriteBits(UPDATE_COLLISION_HEIGHT_MOUNT, 2); ///< Reason
        SendDirectMessage(&l_Data);
        return;
    }

    WorldPacket l_Data(SMSG_MOVE_SET_COLLISION_HEIGHT, 16 + 2 + 4 + 4 + 4 + 4 + 1);
    l_Data.appendPackGUID(GetGUID());
    l_Data << uint32(sWorld->GetGameTime());
    l_Data << float(p_Height);
    l_Data << float(GetFloatValue(OBJECT_FIELD_SCALE));
    l_Data << uint32(l_MountDisplayInfo->Displayid);
    l_Data.WriteBits(UPDATE_COLLISION_HEIGHT_MOUNT, 2);
    SendDirectMessage(&l_Data);
}

float Player::GetCollisionHeight(bool p_Mounted)
{
    if (p_Mounted)
    {
        CreatureDisplayInfoEntry const* l_MountDisplayInfos = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(EUnitFields::UNIT_FIELD_MOUNT_DISPLAY_ID));
        if (!l_MountDisplayInfos)
            return GetCollisionHeight(false);

        CreatureModelDataEntry const* l_CreatureModelData = sCreatureModelDataStore.LookupEntry(l_MountDisplayInfos->ModelId);
        if (!l_CreatureModelData)
            return GetCollisionHeight(false);

        CreatureDisplayInfoEntry const* l_DisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT (l_DisplayInfo);

        CreatureModelDataEntry const* l_ModelData = sCreatureModelDataStore.LookupEntry(l_DisplayInfo->ModelId);
        ASSERT (l_ModelData);

        float l_ScaleMod = GetFloatValue(EObjectFields::OBJECT_FIELD_SCALE); ///< 99% sure about this

        return l_ScaleMod * l_CreatureModelData->MountHeight + l_ModelData->CollisionHeight * 0.5f;
    }
    else
    {
        /// Dismounting case - use basic default model data
        CreatureDisplayInfoEntry const* l_DisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT (l_DisplayInfo);

        CreatureModelDataEntry const* l_ModelData = sCreatureModelDataStore.LookupEntry(l_DisplayInfo->ModelId);
        ASSERT (l_ModelData);

        return l_ModelData->CollisionHeight;
    }
}

void Player::SetMover(Unit* target)
{
    m_mover->m_movedPlayer = NULL;
    m_mover = target;
    m_mover->m_movedPlayer = this;

    if (m_mover)
    {
        WorldPacket data(SMSG_MOVE_SET_ACTIVE_MOVER);
        data.appendPackGUID(target->GetGUID());

        GetSession()->SendPacket(&data);
    }
}

void Player::ShowNeutralPlayerFactionSelectUI()
{
    WorldPacket data(SMSG_SHOW_NEUTRAL_PLAYER_FACTION_SELECT_UI);
    GetSession()->SendPacket(&data);
}

void Player::SetPersonnalXpRate(float p_PersonnalXPRate)
{
    m_PersonnalXpRate = p_PersonnalXPRate;

    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_UPD_XP_RATE);
    l_Statement->setFloat(0, p_PersonnalXPRate);
    l_Statement->setUInt32(1, GetRealGUIDLow());
    RealmDatabase.Execute(l_Statement);
}

void Player::HandleStoreGoldCallback(PreparedQueryResult result)
{
    // Load des golds
    if (result)
    {
        uint64 goldCount = 0;
        do
        {
            Field* fieldGold    = result->Fetch();
            uint64 gold         = uint64(fieldGold[0].GetUInt32()) * GOLD;
            uint32 transaction  = fieldGold[1].GetUInt32();

            if ((GetMoney() + gold) > MAX_MONEY_AMOUNT)
            {
                GetSession()->SendNotification(LANG_GOLD_ERROR1);
                GetSession()->SendNotification(LANG_GOLD_ERROR2);
                break;
            }

            goldCount+= gold;
            ModifyMoney(gold);

            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_GOLD);
            stmt->setInt32(0, transaction);
            RealmDatabase.Execute(stmt);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_BOUTIQUE_GOLD_LOG);
            stmt->setInt32(0, transaction);
            stmt->setInt32(1, GetRealGUIDLow());
            stmt->setInt64(2, gold);
            RealmDatabase.Execute(stmt);
        }
        while(result->NextRow());

        if (goldCount)
            GetSession()->SendNotification(LANG_GOLD_CONFIRM, (goldCount/GOLD));
    }
}

void Player::HandleStoreTitleCallback(PreparedQueryResult p_Result)
{
    // Load titles
    if (p_Result)
    {
        do
        {
            Field* l_TitleField = p_Result->Fetch();
            uint32 l_Title = l_TitleField[0].GetUInt32();
            uint32 l_Transaction = l_TitleField[1].GetUInt32();

            PreparedStatement* stmt = RealmDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_TITLE);
            stmt->setInt32(0, l_Transaction);
            RealmDatabase.Execute(stmt);

            stmt = RealmDatabase.GetPreparedStatement(CHAR_INS_BOUTIQUE_TITLE_LOG);
            stmt->setInt32(0, l_Transaction);
            stmt->setInt32(1, GetRealGUIDLow());
            stmt->setInt32(2, l_Title);
            RealmDatabase.Execute(stmt);

            CharTitlesEntry const* l_TitleInfo = sCharTitlesStore.LookupEntry(l_Title);
            if (!l_TitleInfo)
                continue;

            SetTitle(l_TitleInfo);
        }
        while (p_Result->NextRow());
    }
}

#ifndef CROSS
void Player::HandleStoreItemCallback(PreparedQueryResult /*result*/)
{
}

void Player::HandleStoreLevelCallback(PreparedQueryResult result)
{
    PreparedStatement* stmt;

    // Load powerlevels
    if (result)
    {
        Field* fields = result->Fetch();
        uint32 level = fields[0].GetUInt32();

        if (level < getLevel() || level > DEFAULT_MAX_LEVEL)
        {
            GetSession()->SendNotification("Tentative de powerlevel vers un niveau inferieur ou vers un niveau plus eleve que le niveau maximum, veuillez contactez le support boutique si ce message apparait.");  // translate me
        }
        else
        {
            GiveLevel(level);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BOUTIQUE_LEVEL);
            stmt->setInt32(0, GetGUIDLow());
            CharacterDatabase.Execute(stmt);
        }
    }
}

#endif /* not CROSS */
namespace ProfessionBookSpells
{
    enum
    {
        Alchemy        = 156614,
        Blacksmithing  = 169923,
        Enchanting     = 161788,
        Engineering    = 161787,
        Inscription    = 161789,
        JewelCrafting  = 169926,
        LeatherWorking = 169925,
        Tailoring      = 169924,
        FirstAid       = 160329,
        Cooking        = 160360,
        Herbalism      = 158745,
        Mining         = 158754,
        Skinning       = 158756,
        Archaeology    = 158762,
        Fishing        = 160326
    };
}

namespace ProfessionAdditionalSpells
{
    enum
    {
        Prospecting = 31252,
    };
}

void Player::HandleStoreProfessionCallback(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    std::map<uint32, uint32> l_SkillLearningSpells =
    {
        { SkillType::SKILL_ALCHEMY,        ProfessionBookSpells::Alchemy        },
        { SkillType::SKILL_BLACKSMITHING,  ProfessionBookSpells::Blacksmithing  },
        { SkillType::SKILL_ENCHANTING,     ProfessionBookSpells::Enchanting     },
        { SkillType::SKILL_ENGINEERING,    ProfessionBookSpells::Engineering    },
        { SkillType::SKILL_INSCRIPTION,    ProfessionBookSpells::Inscription    },
        { SkillType::SKILL_JEWELCRAFTING,  ProfessionBookSpells::JewelCrafting  },
        { SkillType::SKILL_LEATHERWORKING, ProfessionBookSpells::LeatherWorking },
        { SkillType::SKILL_TAILORING,      ProfessionBookSpells::Tailoring      },
        { SkillType::SKILL_FIRST_AID,      ProfessionBookSpells::FirstAid       },
        { SkillType::SKILL_COOKING,        ProfessionBookSpells::Cooking        },
        { SkillType::SKILL_HERBALISM,      ProfessionBookSpells::Herbalism      },
        { SkillType::SKILL_MINING,         ProfessionBookSpells::Mining         },
        { SkillType::SKILL_SKINNING,       ProfessionBookSpells::Skinning       },
        { SkillType::SKILL_ARCHAEOLOGY,    ProfessionBookSpells::Archaeology    },
        { SkillType::SKILL_FISHING,        ProfessionBookSpells::Fishing        }
    };

    do
    {
        Field* l_Fields     = p_Result->Fetch();
        uint32 l_SkillID    = l_Fields[0].GetUInt32();
        bool   l_Recipe     = l_Fields[1].GetBool();

        auto it = l_SkillLearningSpells.find(l_SkillID);
        if (it == l_SkillLearningSpells.end())
            continue;

        uint32 l_SpellID = it->second;

        if (getLevel() < 90)
            continue;
        
        if (IsPrimaryProfessionSkill(l_SkillID) && !HasSkill(l_SkillID) && GetFreePrimaryProfessionPoints() == 0)
            continue;

        /// Learn the skill to dreanor rank
        CastSpell(this, l_SpellID, true);

        /// Up skill to 700
        SetSkill(l_SkillID, GetSkillStep(l_SkillID), 700, 700);

        if (l_Recipe)
        {
            const std::list<SkillLineAbilityEntry const*>& l_Abilities = sSpellMgr->GetTradeSpellFromSkill(l_SkillID);
            for (auto l_Abilitie : l_Abilities)
            {
                if (l_Abilitie->spellId > 155748)   ///< last 5.4.7 spellid
                    continue;

                learnSpell(l_Abilitie->spellId, false);
            }
        }

        if (l_SkillID == SkillType::SKILL_JEWELCRAFTING)
            learnSpell(ProfessionAdditionalSpells::Prospecting, false);             ///< Prospecting

        /// We also need to learn it for herbalism
        if (l_SkillID == SkillType::SKILL_HERBALISM)
            learnSpell(l_SpellID, false);

        PreparedStatement* l_Statement = CharacterDatabase.GetPreparedStatement(CHAR_DEL_STORE_PROFESSION);
        l_Statement->setUInt32(0, GetGUIDLow());
        l_Statement->setUInt32(1, l_SkillID);
        CharacterDatabase.Execute(l_Statement);
    }
    while (p_Result->NextRow());
}

void Player::CheckSpellAreaOnQuestStatusChange(uint32 quest_id)
{
    uint32 zone = 0, area = 0;

    SpellAreaForQuestMapBounds saBounds = sSpellMgr->GetSpellAreaForQuestMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                RemoveAurasDueToSpell(itr->second->spellId);
        }
    }

    saBounds = sSpellMgr->GetSpellAreaForQuestEndMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        if (!zone || !area)
            GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                RemoveAurasDueToSpell(itr->second->spellId);
        }
    }
}

void Player::CastPassiveTalentSpell(uint32 spellId)
{
    switch (spellId)
    {
        case 16188: // Ancestral Swiftness
            if (!HasAura(51470))
                CastSpell(this, 121617, true); ///< +5% melee/spell haste since 6.0.1 (Tue Oct 14 2014) Build 18537
            break;
        case 96268: // Death's Advance
            if (!HasAura(124285))
                CastSpell(this, 124285, true); // +10% speed
            break;
        case 108415:// Soul Link
            RemoveAura(108503); // Remove Grimoire of sacrifice
            break;
        case 108499:// Grimoire of Supremacy
            if (!HasAura(108499))
                AddAura(108499, this);
            if (HasAura(152107)) ///< Demonic Servitude
                learnSpell(157901, false);  ///< WARLOCK_GRIMOIRE_INFERNAL
            break;
        case 108501:// Grimoire of Service
            learnSpell(111859, false);  ///< WARLOCK_GRIMOIRE_IMP
            learnSpell(111895, false);  ///< WARLOCK_GRIMOIRE_VOIDWALKER
            learnSpell(111896, false);  ///< WARLOCK_GRIMOIRE_SUCCUBUS
            learnSpell(111897, false);  ///< WARLOCK_GRIMOIRE_FELHUNTER

            if (GetSpecializationId() == SPEC_WARLOCK_DEMONOLOGY)
            {
                learnSpell(111898, false);  ///< WARLOCK_GRIMOIRE_FELGUARD
                if (HasAura(152107)) ///< Demonic Servitude
                {
                    learnSpell(157900, false);  ///< WARLOCK_GRIMOIRE_DOOMGUARD
                    learnSpell(157899, false);  ///< WARLOCK_GRIMOIRE_ABYSSAL
                }
            }
            break;
        default:
            break;
    }
}

void Player::RemovePassiveTalentSpell(SpellInfo const* info)
{
    if (!info)
        return;

    switch (info->Id)
    {
        case 46584: // Raise dead
            if (Pet* l_Pet = this->GetPet())
            {
                if (l_Pet->GetEntry() == 26125)
                    l_Pet->UnSummon();
            }
            break;
        case 16188: // Ancestral Swiftness
            RemoveAura(121617);
            break;
        case 108415:// Soul Link
            RemoveAura(108446);
            RemoveAura(108503); // Remove Grimoire of sacrifice
            break;
        case 108499:// Grimoire of Supremacy
            RemoveAura(108499);
            if (HasSpell(157899))
                removeSpell(157899, false, false);  // WARLOCK_GRIMOIRE_ABYSSAL
            break;
        case 108501:// Grimoire of Service
            if (HasSpell(111859))
                removeSpell(111859, false, false);  // WARLOCK_GRIMOIRE_IMP
            if (HasSpell(111895))
                removeSpell(111895, false, false);  // WARLOCK_GRIMOIRE_VOIDWALKER
            if (HasSpell(111896))
                removeSpell(111896, false, false);  // WARLOCK_GRIMOIRE_SUCCUBUS
            if (HasSpell(111897))
                removeSpell(111897, false, false);  // WARLOCK_GRIMOIRE_FELHUNTER
            if (HasSpell(111898))
                removeSpell(111898, false, false);  // WARLOCK_GRIMOIRE_FELGUARD
            if (HasSpell(157900))
                removeSpell(157900, false, false);  // WARLOCK_GRIMOIRE_DOOMGUARD
            if (HasSpell(157901))
                removeSpell(157901, false, false);  // WARLOCK_GRIMOIRE_INFERNAL
            break;
        default:
            break;
    }
}

#ifndef CROSS
Guild* Player::GetGuild()
#else /* CROSS */
InterRealmGuild* Player::GetGuild()
#endif /* CROSS */
{
    uint32 guildId = GetGuildId();
#ifndef CROSS
    return guildId ? sGuildMgr->GetGuildById(guildId) : 0;
#else /* CROSS */
    return guildId ? sGuildMgr->GetInterRealmGuild(GetSession()->GetInterRealmNumber(), guildId) : nullptr;
#endif /* CROSS */
}

void Player::FinishWeek()
{
    for (int slot = 0; slot < MAX_ARENA_SLOT; ++slot)
    {
        m_BestRatingOfWeek[slot] = 0;
        m_PrevWeekWins[slot] = m_WeekWins[slot];
        m_PrevWeekGames[slot] = m_WeekGames[slot];
        m_WeekGames[slot] = 0;
        m_WeekWins[slot] = 0;
    }
}

void Player::SetEmoteState(uint32 anim_id)
{
    HandleEmoteCommand(anim_id);
    m_emote = anim_id;
}

void Player::SendApplyMovementForce(uint64 p_Source, bool p_Apply, Position p_Direction, float p_Magnitude /*= 0.0f*/, uint8 p_Type /*= 0*/, G3D::Vector3 p_TransportPos /*= G3D::Vector3(0.0f, 0.0f, 0.0f)*/)
{
    if (p_Apply)
    {
        uint32 l_TransportID = GetTransport() ? GetTransport()->GetEntry() : 0;

        WorldPacket l_Data(SMSG_APPLY_MOVEMENT_FORCE, 2 + 16 + 4 + 2 + 16 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1);
        l_Data.appendPackGUID(GetGUID());               ///< Mover GUID
        l_Data << uint32(0);                            ///< Sequence Index

        l_Data.appendPackGUID(p_Source);                ///< Movement ForceID
        l_Data << float(p_Direction.GetPositionX());    ///< Direction X
        l_Data << float(p_Direction.GetPositionY());    ///< Direction Y
        l_Data << float(p_Direction.GetPositionZ());    ///< Direction Z
        l_Data.WriteVector3(p_TransportPos);            ///< TransportPosition
        l_Data << uint32(l_TransportID);                ///< Transport ID
        l_Data << float(p_Magnitude);                   ///< Magnitude

        l_Data.WriteBits(p_Type, 2);                    ///< Force type, still one yet
        l_Data.FlushBits();

        SendMessageToSet(&l_Data, true);

        m_ActiveMovementForces.insert(p_Source);
    }
    else
    {
        WorldPacket l_Data(SMSG_UNAPPLY_MOVEMENT_FORCE, (2 * (2 + 16)) + 4);
        l_Data.appendPackGUID(GetGUID()); ///< Mover GUID
        l_Data << uint32(0);              ///< Sequence Index
        l_Data.appendPackGUID(p_Source);  ///< Movement ForceID

        SendMessageToSet(&l_Data, true);

        m_ActiveMovementForces.erase(p_Source);
    }
}

void Player::RemoveAllMovementForces(uint32 p_Entry /*=0*/)
{
    std::set<uint64> l_ActiveMovementForces;

    if (!p_Entry)
        l_ActiveMovementForces = m_ActiveMovementForces;
    else
    {
        for (std::set<uint64>::iterator l_Itr = m_ActiveMovementForces.begin(); l_Itr != m_ActiveMovementForces.end(); ++l_Itr)
        {
            if (WorldObject* l_Obj = ObjectAccessor::GetWorldObject(*this, *l_Itr))
            {
                if (l_Obj->GetEntry() == p_Entry)
                    l_ActiveMovementForces.insert(l_Obj->GetGUID());
            }
        }
    }

    for (uint64 l_ForceID : l_ActiveMovementForces)
        SendApplyMovementForce(l_ForceID, false, Position());
}

bool Player::HasMovementForce(uint64 p_Source /*= 0*/, bool p_IsEntry /*=false*/)
{
/* Removed because some Unit* can also be source of movement force
    if (sAreaTriggerStore.LookupEntry(GUID_ENPART(p_Source)) || GUID_HIPART(p_Source) != HIGHGUID_AREATRIGGER)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Invalid source for movement force. (GUID: 0x" UI64FMTD " AreaTrigger entry not found in DBC)", p_Source);
        return false;
    }
*/
    /// No Guid? Just returns if player has at least one movement force applied
    if (!p_Source)
        return !m_ActiveMovementForces.empty();

    /// Entry?
    if (p_IsEntry)
    {
        if (uint32(p_Source) == p_Source)
        {
            for (std::set<uint64>::iterator l_Itr = m_ActiveMovementForces.begin(); l_Itr != m_ActiveMovementForces.end(); ++l_Itr)
            {
                if (WorldObject* l_Object = ObjectAccessor::GetWorldObject(*this, *l_Itr))
                {
                    if (l_Object->GetEntry() == p_Source)
                        return true;
                }
            }

            return false;
        }
        /// Not a valid entry
        return false;
    }

    /// Guid?
    return m_ActiveMovementForces.find(p_Source) != m_ActiveMovementForces.end();
}

void Player::SendResumeToken(uint32 token)
{
    WorldPacket data(SMSG_RESUME_TOKEN, 5);
    data << uint32(token);
    data.WriteBit(token == m_tokenCounter);
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendRefreshSpellMods()
{
    flag128 l_Mask = 0;
    uint32 l_PctModifierTypeCount;
    uint32 l_FlatModifierTypeCount;
    uint32 l_PctModifiersCount = 0;
    uint32 l_FlatModifiersCount = 0;
    uint32 l_MaskIndex;
    ByteBuffer l_PctBuffer;
    ByteBuffer l_FlatBuffer;

    for (int l_SpellModOp = 0; l_SpellModOp < MAX_SPELLMOD; ++l_SpellModOp)
    {
        if (!m_spellMods[l_SpellModOp].size())
            continue;

        l_PctModifierTypeCount = 0;
        l_FlatModifierTypeCount = 0;
        l_MaskIndex = 0;

        ByteBuffer l_SubFlatBuffer(1024);
        ByteBuffer l_SubPctBuffer(1024);

        for (int l_EffectIndex = 0; l_EffectIndex < 128; ++l_EffectIndex)
        {
            if (l_EffectIndex != 0 && (l_EffectIndex % 32) == 0)
                l_Mask[l_MaskIndex++] = 0;

            l_Mask[l_MaskIndex] = uint32(1) << (l_EffectIndex - (32 * l_MaskIndex));

            float l_PctValue = 1.0f;
            for (SpellModList::iterator l_It = m_spellMods[l_SpellModOp].begin(); l_It != m_spellMods[l_SpellModOp].end(); ++l_It)
                if ((*l_It)->type == SPELLMOD_PCT && (*l_It)->mask & l_Mask)
                    l_PctValue += float((*l_It)->value) / 100.0f;

            if (l_PctValue != 1.0f)
            {
                l_SubPctBuffer << float(l_PctValue);
                l_SubPctBuffer << uint8(l_EffectIndex);

                ++l_PctModifierTypeCount;
            }

            float l_FlatValue = 0.0f;
            for (SpellModList::iterator itr = m_spellMods[l_SpellModOp].begin(); itr != m_spellMods[l_SpellModOp].end(); ++itr)
                if ((*itr)->type == SPELLMOD_FLAT && (*itr)->mask & l_Mask)
                    l_FlatValue += float((*itr)->value);

            if (l_FlatValue)
            {
                l_SubFlatBuffer << float(l_FlatValue);
                l_SubFlatBuffer << uint8(l_EffectIndex);

                ++l_FlatModifierTypeCount;
            }
        }

        if (l_PctModifierTypeCount)
        {
            ++l_PctModifiersCount;

            l_PctBuffer << uint8(l_SpellModOp);
            l_PctBuffer << uint32(l_PctModifierTypeCount);
            l_PctBuffer.append(l_SubPctBuffer);
        }

        if (l_FlatModifierTypeCount)
        {
            ++l_FlatModifiersCount;

            l_FlatBuffer << uint8(l_SpellModOp);
            l_FlatBuffer << uint32(l_FlatModifierTypeCount);
            l_FlatBuffer.append(l_SubFlatBuffer);
        }

    }

    if (l_PctModifiersCount)
    {
        WorldPacket l_Packet(SMSG_SET_PCT_SPELL_MODIFIER, 4 + l_PctBuffer.size());
        l_Packet << uint32(l_PctModifiersCount);
        l_Packet.append(l_PctBuffer);
        SendDirectMessage(&l_Packet);
    }

    if (l_FlatModifiersCount)
    {
        WorldPacket l_Packet(SMSG_SET_FLAT_SPELL_MODIFIER, 4 + l_FlatBuffer.size());
        l_Packet << uint32(l_FlatModifiersCount);
        l_Packet.append(l_FlatBuffer);
        SendDirectMessage(&l_Packet);
    }
}

void Player::PlayScene(uint32 sceneId, WorldObject* spectator)
{
    if (m_LastPlayedScene)
    {
        m_LastPlayedScene->DestroyForPlayer(this);
        delete m_LastPlayedScene;
        m_LastPlayedScene = NULL;
    }

    m_LastPlayedScene = SceneObject::CreateSceneObject(sceneId, spectator);

    if (m_LastPlayedScene)
        m_LastPlayedScene->SendUpdateToPlayer(this);
}

/// Play standalone scene script on client size
/// @p_ScenePackageID : Scene package ID @ScenePackage.db2
/// @p_PlaybackFlags  : Playback flags (@TODO make some reverse on it)
/// @p_Location       : Scene script start location
/// Return generated Scene instance ID
uint32 Player::PlayStandaloneScene(uint32 p_ScenePackageID, uint32 p_PlaybackFlags, Position p_Location)
{
    SceneScriptPackageEntry const* l_Entry = sSceneScriptPackageStore.LookupEntry(p_ScenePackageID);

    if (!l_Entry)
    {
        sLog->outError(LOG_FILTER_PLAYER, "Player::PlayStandaloneScene => ScenePackage %u doesn't exist", p_ScenePackageID);
        return -1;
    }

    uint64 l_TransportGUID      = 0;
    uint32 l_SceneInstanceID    = sObjectMgr->GetNewStandaloneSceneInstanceID();

    WorldPacket l_PlayScenePacket(SMSG_PLAY_SCENE, 4 + 4 + 4 + 4 + 2 + 16 + 4 + 4 + 4 + 4);
    l_PlayScenePacket << uint32(0);                 ///< SceneID
    l_PlayScenePacket << uint32(p_PlaybackFlags);
    l_PlayScenePacket << uint32(l_SceneInstanceID);
    l_PlayScenePacket << uint32(p_ScenePackageID);
    l_PlayScenePacket.appendPackGUID(l_TransportGUID);
    l_PlayScenePacket << float(p_Location.m_positionX);
    l_PlayScenePacket << float(p_Location.m_positionY);
    l_PlayScenePacket << float(p_Location.m_positionZ);
    l_PlayScenePacket << float(p_Location.m_orientation);

    SendDirectMessage(&l_PlayScenePacket);

    return l_SceneInstanceID;
}

/// Cancel a client-side played standalone scene
/// @p_SceneInstanceID : Scene instance ID
void Player::CancelStandaloneScene(uint32 p_SceneInstanceID)
{
    WorldPacket l_Data(SMSG_CANCEL_SCENE, 4);
    l_Data << uint32(p_SceneInstanceID);
    SendDirectMessage(&l_Data);
}

/// Has battle pet training
bool Player::HasBattlePetTraining()
{
    return HasSpell(119467);
}

/// Get battle pet trap level
uint32 Player::GetBattlePetTrapLevel()
{
    /// Pro Pet Crew
    if (GetAchievementMgr().HasAccountAchieved(6581))
        return 3;     ///< Pristine Pet Trap

    /// Going to Need More Traps
    if (GetAchievementMgr().HasAccountAchieved(6556))
        return 2;      ///< Strong Pet Trap

    return 1; ///< Pet trap
}

/// Compute the unlocked pet battle slot
uint32 Player::GetUnlockedPetBattleSlot()
{
    /// Just a Pup
    if (GetAchievementMgr().HasAccountAchieved(6566))
        return 3;

    /// Newbie
    if (GetAchievementMgr().HasAccountAchieved(7433))
        return 2;

    /// battle pet training
    if (HasBattlePetTraining())
        return 1;

    return 0;
}

/// Summon current pet if any active
void Player::UnsummonCurrentBattlePetIfAny(bool p_Unvolontary)
{
    if (!m_BattlePetSummon)
        return;

    if (!p_Unvolontary)
        m_LastSummonedBattlePet = 0;

    Creature * l_Pet = GetSummonedBattlePet();

    if (l_Pet)
    {
        l_Pet->DespawnOrUnsummon();
        l_Pet->AddObjectToRemoveList();
    }

    m_BattlePetSummon = 0;

    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID, 0);
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL, 0);
}

/// Summon new pet
void Player::SummonBattlePet(uint64 p_JournalID)
{
    if (!IsInWorld())
        return;

    std::vector<BattlePet::Ptr>::iterator l_It = std::find_if(m_BattlePets.begin(), m_BattlePets.end(), [p_JournalID](BattlePet::Ptr & p_Ptr)
    {
        if (p_Ptr && p_Ptr->JournalID == p_JournalID)
            return true;

        return false;
    });

    if (l_It == m_BattlePets.end())
        return;

    BattlePet::Ptr l_BattlePet = (*l_It);

    if (l_BattlePet->Health <= 0)
    {
        UnsummonCurrentBattlePetIfAny(false);
        return;
    }

    BattlePetSpeciesEntry const* l_SpeciesInfo      = sBattlePetSpeciesStore.LookupEntry(l_BattlePet->Species);
    SummonPropertiesEntry const* l_SummonProperties = sSummonPropertiesStore.LookupEntry(3221);

    if (!l_SpeciesInfo || !l_SummonProperties)
        return;

    uint32 l_Team   = GetTeam();
    uint32 l_Phase  = GetPhaseMask();

    WorldLocation l_Position;
    GetClosePoint(l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, DEFAULT_WORLD_OBJECT_SIZE);

    TempSummon * l_CurrentPet = new Minion(l_SummonProperties, this, false);

    if (!l_CurrentPet->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_UNIT), GetMap(), l_Phase, l_SpeciesInfo->entry, 0, l_Team, l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, GetOrientation()))
    {
        delete l_CurrentPet;
        l_CurrentPet = 0;
        return;
    }

    l_CurrentPet->SetHomePosition(l_Position);
    l_CurrentPet->SetTempSummonType(TEMPSUMMON_MANUAL_DESPAWN);
    l_CurrentPet->InitStats(0);
    l_CurrentPet->SetOwnerGUID(GetGUID());

    m_LastSummonedBattlePet = GUID_LOPART(l_BattlePet->JournalID);

    SetGuidValue(UNIT_FIELD_CRITTER,                                l_CurrentPet->GetGUID());
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL,                l_BattlePet->Level);
    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID,             l_BattlePet->JournalID);
    SetUInt32Value(PLAYER_FIELD_CURRENT_BATTLE_PET_BREED_QUALITY,   l_BattlePet->Breed);

    l_CurrentPet->SetGuidValue(UNIT_FIELD_BATTLE_PET_COMPANION_GUID,    l_BattlePet->JournalID);
    l_CurrentPet->SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL,      l_BattlePet->Level);

    if (!l_BattlePet->Name.empty())
    {
        l_CurrentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, l_BattlePet->NameTimeStamp);
        l_CurrentPet->SetName(l_BattlePet->Name);
    }
    else
        l_CurrentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, 0);

    l_CurrentPet->SetUInt32Value(UNIT_FIELD_SHAPESHIFT_FORM, !l_BattlePet->Name.empty());
    l_CurrentPet->SetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL, l_SpeciesInfo->spellId);

    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
    l_CurrentPet->SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    l_CurrentPet->RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_PETBATTLE);

    GetMap()->AddToMap(l_CurrentPet->ToCreature());

    l_CurrentPet->InitSummon();
    l_CurrentPet->GetMotionMaster()->MoveFollow(this, PET_FOLLOW_DIST, (3 * M_PI) / 2);
    l_CurrentPet->SetSpeed(MOVE_WALK, GetSpeedRate(MOVE_WALK), true);
    l_CurrentPet->SetSpeed(MOVE_RUN, GetSpeedRate(MOVE_RUN), true);

    m_BattlePetSummon = l_CurrentPet->GetGUID();

    /// Glyph of shadowy friend
    if (l_CurrentPet->GetOwner())
    {
        Player* l_Owner = l_CurrentPet->GetOwner()->ToPlayer();
        if (l_Owner && l_Owner->getClass() == CLASS_PRIEST && l_Owner->GetSpecializationId() == SPEC_PRIEST_SHADOW && l_Owner->HasAura(126745))
        {
            if (l_Owner->HasAura(107903))
                l_CurrentPet->CastSpell(l_CurrentPet, 107903, true);
            if (l_Owner->HasAura(107904))
                l_CurrentPet->CastSpell(l_CurrentPet, 107904, true);
        }
    }
}

/// Get current summoned battle pet
Creature* Player::GetSummonedBattlePet()
{
    Unit * l_Pet = sObjectAccessor->FindUnit(m_BattlePetSummon);

    return l_Pet ? l_Pet->ToCreature() : NULL;
}

/// Summon last summoned battle pet
void Player::SummonLastSummonedBattlePet()
{
    SummonBattlePet(MAKE_NEW_GUID(m_LastSummonedBattlePet, 0, HIGHGUID_BATTLE_PET));
}

/// Get pet battles
std::vector<std::shared_ptr<BattlePet>> Player::GetBattlePets()
{
    return m_BattlePets;
}

/// Get pet battles
std::shared_ptr<BattlePet> Player::GetBattlePet(uint64 p_JournalID)
{
    std::vector<BattlePet::Ptr>::iterator l_It = std::find_if(m_BattlePets.begin(), m_BattlePets.end(), [p_JournalID](BattlePet::Ptr & p_Ptr)
    {
        if (p_Ptr && p_Ptr->JournalID == p_JournalID)
            return true;

        return false;
    });

    if (l_It == m_BattlePets.end())
        return BattlePet::Ptr();

    return (*l_It);
}

/// Get pet battle combat team
std::shared_ptr<BattlePet> * Player::GetBattlePetCombatTeam()
{
    return m_BattlePetCombatTeam;
}

/// Reload pet battles
void Player::ReloadPetBattles()
{
    SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();

    for (std::vector<BattlePet::Ptr>::iterator l_It = m_BattlePets.begin(); l_It != m_BattlePets.end(); ++l_It)
    {
        BattlePet::Ptr l_Pet = (*l_It);
        l_Pet->Save(l_Transaction);
    }
    
    uint64 l_ThisGUID = GetGUID();
    MS::Utilities::CallBackPtr l_CallBack = std::make_shared<MS::Utilities::Callback>([l_ThisGUID](bool p_Success) -> void ///< p_Success is unused
    {
        if (Player* l_This = HashMapHolder<Player>::Find(l_ThisGUID))
        {
            PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_PETBATTLE_ACCOUNT);
            stmt->setUInt32(0, l_This->GetSession()->GetAccountId());
            l_This->_petBattleJournalCallback = LoginDatabase.AsyncQuery(stmt);
        }
    });

    CommitTransaction(LoginDatabase, l_Transaction, l_CallBack);
}

/// PetBattleCountBattleSpecies
void Player::PetBattleCountBattleSpecies()
{
    PetBattle * l_Battle = sPetBattleSystem->GetBattle(_petBattleId);

    if (!l_Battle)
        return;

    uint32 l_ThisTeamID = l_Battle->Teams[PETBATTLE_TEAM_1]->PlayerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

    std::for_each(m_BattlePets.begin(), m_BattlePets.end(), [l_Battle, l_ThisTeamID](BattlePet::Ptr & p_PetBattle)
    {
        if (!p_PetBattle)
            return;

        if (l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount.find(p_PetBattle->Species) == l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount.end())
            l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount[p_PetBattle->Species] = 0;

        l_Battle->Teams[l_ThisTeamID]->CapturedSpeciesCount[p_PetBattle->Species]++;
    });
}

/// Update battle pet combat team
void Player::UpdateBattlePetCombatTeam()
{
    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    uint32 l_UnlockedSlotCount = GetUnlockedPetBattleSlot();

    std::for_each(m_BattlePets.begin(), m_BattlePets.end(), [this, l_UnlockedSlotCount](BattlePet::Ptr & p_BattlePet)
    {
        if (!p_BattlePet)
            return;

        if (p_BattlePet->Slot >= 0 && p_BattlePet->Slot < (int32)l_UnlockedSlotCount)
            m_BattlePetCombatTeam[p_BattlePet->Slot] = p_BattlePet;
    });
}

//////////////////////////////////////////////////////////////////////////
/// Calc Monk Melee Attacks
enum ExpelHarmSpells
{
    SPELL_MONK_STANCE_OF_THE_FIERCE_TIGER = 103985,
    SPELL_MONK_2H_STAFF_OVERRIDE = 108561,
    SPELL_MONK_EXPEL_HARM_DAMAGE = 115129,
    SPELL_MONK_2H_POLEARM_OVERRIDE = 115697,
    SPELL_MONK_MANA_MEDITATION = 121278
};

void Player::CalculateMonkMeleeAttacks(float &p_Low, float &p_High)
{
    Item* l_MainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
    Item* l_OffItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);

    float l_MainWeaponMinDamage = 0.0f;
    float l_MainWeaponMaxDamage = 0.0f;
    float l_MainWeaponSpeed = 1.0f;
    float l_OffhandWeaponMinDamage = 0.0f;
    float l_OffhandWeaponMaxDamage = 0.0f;
    float l_OffhandWeaponSpeed = 1.0f;

    if (l_MainItem && l_MainItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && !HasAuraType(SPELL_AURA_MOD_DISARM))
    {
        l_MainWeaponMinDamage = GetWeaponDamageRange(BaseAttack, MINDAMAGE);
        l_MainWeaponMaxDamage = GetWeaponDamageRange(BaseAttack, MAXDAMAGE);
        l_MainWeaponSpeed = float(GetAttackTime(BaseAttack) / 1000.0f) * m_modAttackSpeedPct[BaseAttack];
    }
    if (l_OffItem && l_OffItem->GetTemplate()->Class == ITEM_CLASS_WEAPON && !HasAuraType(SPELL_AURA_MOD_DISARM))
    {
        l_OffhandWeaponMinDamage = GetWeaponDamageRange(OffAttack, MINDAMAGE);
        l_OffhandWeaponMaxDamage = GetWeaponDamageRange(OffAttack, MAXDAMAGE);
        l_OffhandWeaponSpeed = float(GetAttackTime(OffAttack) / 1000.0f) * m_modAttackSpeedPct[OffAttack];
    }

    float l_Dwm = (HasAura(SPELL_MONK_2H_STAFF_OVERRIDE) || HasAura(SPELL_MONK_2H_POLEARM_OVERRIDE)) ? 1.0f : 0.857143f;
    float l_Offm = (HasAura(SPELL_MONK_2H_STAFF_OVERRIDE) || HasAura(SPELL_MONK_2H_POLEARM_OVERRIDE)) ? 0.0f : 1.0f;

    float l_Offlow = (HasSpell(SPELL_MONK_MANA_MEDITATION)) ? l_MainWeaponMinDamage / 2 / l_MainWeaponSpeed : l_OffhandWeaponMinDamage / 2 / l_OffhandWeaponSpeed;
    float l_Offhigh = (HasSpell(SPELL_MONK_MANA_MEDITATION)) ? l_MainWeaponMaxDamage / 2 / l_MainWeaponSpeed : l_OffhandWeaponMaxDamage / 2 / l_OffhandWeaponSpeed;

    p_Low = (l_Dwm * (l_MainWeaponMinDamage / l_MainWeaponSpeed + l_Offm * l_Offlow) + GetTotalAttackPowerValue(WeaponAttackType::BaseAttack) / 3.5f - 1);
    p_High = (l_Dwm * (l_MainWeaponMaxDamage / l_MainWeaponSpeed + l_Offm * l_Offhigh) + GetTotalAttackPowerValue(WeaponAttackType::BaseAttack) / 3.5f + 1);
}

//////////////////////////////////////////////////////////////////////////
/// ToyBox
void Player::_LoadToyBox(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();
        uint32 l_ItemID = l_Fields[0].GetUInt32();
        bool l_IsFavorite = l_Fields[1].GetBool();

        if (!HasToy(l_ItemID))
        {
            PlayerToy l_PlayerToy = PlayerToy(l_ItemID, l_IsFavorite);
            m_PlayerToys.insert(std::make_pair(l_ItemID, l_PlayerToy));
        }
    }
    while (p_Result->NextRow());

    uint32 l_Count = 0;
    for (PlayerToys::iterator l_Toy = m_PlayerToys.begin(); l_Toy != m_PlayerToys.end(); ++l_Toy)
    {
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_TOYS, l_Count, l_Toy->second.m_ItemID);
        ++l_Count;
    }
}

void Player::SendToyBox()
{
    uint32 l_ToyCount = m_PlayerToys.size();

    WorldPacket l_Data(SMSG_ACCOUNT_TOYS_UPDATE, 2 * 1024);
    l_Data.WriteBit(true);      // IsFullUpdate

    l_Data << uint32(l_ToyCount);
    l_Data << uint32(l_ToyCount);

    for (auto l_Toy : m_PlayerToys)
        l_Data << uint32(l_Toy.second.m_ItemID);

    for (auto l_Toy : m_PlayerToys)
        l_Data.WriteBit(l_Toy.second.m_IsFavorite);

    SendDirectMessage(&l_Data);
}

void Player::AddNewToyToBox(uint32 p_ItemID)
{
    /// Save toys to database only for live realms
    if (sWorld->CanBeSaveInLoginDatabase())
    {
        PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_TOYS);
        l_Statement->setUInt32(0, GetSession()->GetAccountId());
        l_Statement->setUInt32(1, p_ItemID);
        l_Statement->setBool(2, false);
        LoginDatabase.Execute(l_Statement);
    }

    if (!HasToy(p_ItemID))
    {
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COLLECT_TOYS, 1, 0, 0, nullptr);

        PlayerToy l_PlayerToy = PlayerToy(p_ItemID, false);
        m_PlayerToys.insert(std::make_pair(p_ItemID, l_PlayerToy));

        uint32 l_ToySize = m_PlayerToys.size();
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_TOYS, l_ToySize, p_ItemID);
    }
}

void Player::SetFavoriteToy(bool p_Apply, uint32 p_ItemID)
{
    PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_UPD_TOY_FAVORITE);
    l_Statement->setBool(0, p_Apply);
    l_Statement->setUInt32(1, GetSession()->GetAccountId());
    l_Statement->setUInt32(2, p_ItemID);
    LoginDatabase.Execute(l_Statement);

    WorldPacket l_Data(SMSG_ACCOUNT_TOYS_UPDATE);
    l_Data.WriteBit(false);     // IsFullUpdate

    l_Data << uint32(1);
    l_Data << uint32(1);
    l_Data << uint32(p_ItemID);
    l_Data.WriteBit(p_Apply);   // IsFavorite

    SendDirectMessage(&l_Data);

    if (PlayerToy* l_PlayerToy = GetToy(p_ItemID))
        l_PlayerToy->m_IsFavorite = p_Apply;
}
//////////////////////////////////////////////////////////////////////////

void Player::_LoadBossLooted(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    m_BossLooted.clear();

    do
    {
        Field* l_Fields = p_Result->Fetch();
        uint32 l_BossEntry = l_Fields[0].GetUInt32();
        uint32 l_DisplayID = l_Fields[1].GetUInt32();

        uint64 l_Value = l_BossEntry | ((uint64)l_DisplayID << 32);

        if (m_BossLooted.find(l_Value) != m_BossLooted.end())
            continue;

        m_BossLooted.insert(l_Value);
    }
    while (p_Result->NextRow());
}

bool Player::BossAlreadyLooted(Creature* p_Creature) const
{
    if (p_Creature == nullptr)
        return false;

    uint64 l_Value = p_Creature->GetEntry() | ((uint64)p_Creature->GetNativeDisplayId() << 32);

    if (m_BossLooted.find(l_Value) == m_BossLooted.end())
        return false;

    return true;
}

void Player::AddBossLooted(Creature* p_Creature)
{
    if (p_Creature == nullptr)
        return;

    uint64 l_Value = p_Creature->GetEntry() | ((uint64)p_Creature->GetNativeDisplayId() << 32);

    if (m_BossLooted.find(l_Value) != m_BossLooted.end())
        return;

    m_BossLooted.insert(l_Value);

    PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_BOSS_LOOTED);
    l_Statement->setUInt32(0, GetRealGUIDLow());
    l_Statement->setUInt32(1, p_Creature->GetEntry());
    l_Statement->setUInt32(2, p_Creature->GetNativeDisplayId());
    RealmDatabase.Execute(l_Statement);
}

bool Player::HasUnlockedReagentBank()
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS_EX, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED);
}

void Player::UnlockReagentBank()
{
    SetFlag(PLAYER_FIELD_PLAYER_FLAGS_EX, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED);
}

uint32 Player::GetFreeReagentBankSlot() const
{
    for (uint8 l_I = REAGENT_BANK_SLOT_BAG_START; l_I < REAGENT_BANK_SLOT_BAG_END; ++l_I)
    {
        if (!GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            return l_I;
    }

    return REAGENT_BANK_SLOT_BAG_END;
}

#ifndef CROSS
MS::Garrison::Manager * Player::GetGarrison() const
{
    return m_Garrison;
}

void Player::CreateGarrison()
{
    if (m_Garrison)
        return;

    m_Garrison = new MS::Garrison::Manager(this);
    m_Garrison->Create();
}

bool Player::IsInGarrison() const
{
    if (!m_Garrison || !m_Garrison->GetGarrisonSiteLevelEntry())
        return false;

    if (GetMapId() == m_Garrison->GetGarrisonSiteLevelEntry()->MapID)
        return true;

    return false;
}

bool Player::IsInShipyard() const
{
    return GetShipyardMapID() == GetMapId(); ///< Comparison of integers of different signs: 'int32' (aka 'int') and 'uint32' (aka 'unsigned int')
}

int32 Player::GetGarrisonMapID() const
{
    if (!m_Garrison)
        return -1;

    return m_Garrison->GetGarrisonSiteLevelEntry()->MapID;
}

int32 Player::GetShipyardMapID() const
{
    if (!m_Garrison)
        return -1;

    return m_Garrison->GetShipyardMapId();
}

void Player::DeleteGarrison()
{
    if (!m_Garrison)
        return;

    SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
    m_Garrison->DeleteFromDB(GetGUID(), l_Transaction);
    CharacterDatabase.CommitTransaction(l_Transaction);

    if (IsInGarrison())
    {
        if (GetTeamId() == TEAM_ALLIANCE)
            TeleportTo(0, -8866.55f, 671.93f, 97.90f, 5.31f);
        else if (GetTeamId() == TEAM_HORDE)
            TeleportTo(1, 1577.30f, -4453.64f, 15.68f, 1.84f);
    }

    delete m_Garrison;
    m_Garrison = nullptr;
}

uint32 Player::GetPlotInstanceID() const
{
    if (m_Garrison == nullptr)
        return 0;

    return m_Garrison->GetPlot(m_positionX, m_positionY, m_positionZ).PlotInstanceID;
}

#endif /* not CROSS */
Stats Player::GetPrimaryStat() const
{
    int8 magicNumber = -1;
    if (ChrSpecializationsEntry const* spec = sChrSpecializationsStore.LookupEntry(GetSpecializationId()))
        magicNumber = spec->MainStat;
    else if (ChrClassesEntry const* playerClass = sChrClassesStore.LookupEntry(getClass()))
        magicNumber = playerClass->MainStat;

    // WTF is Blizzard doing ????
    switch (magicNumber)
    {
        case 0:
        case 1:
            return STAT_INTELLECT;
        case 2:
        case 3:
            return STAT_AGILITY;
        case 4:
        case 5:
        default:
            return STAT_STRENGTH;
    }
}

/*
 *          WARNING !!!!!!
 *
 *
 *
 *  Never use _ApplyItemBonuses for rescaling, use those the functions below, unless you know how it works and trust me you dont
 *
 */

ScalingStatDistributionEntry const* Player::GetSSDForItem(Item const* p_Item) const
{
    if (!p_Item)
        return nullptr;

    uint32 l_SSDID = p_Item->GetTemplate()->ScalingStatDistribution;

    std::vector<uint32> const& l_ItemBonuses = p_Item->GetAllItemBonuses();
    for (auto l_Bonus : l_ItemBonuses)
    {
        if (!l_Bonus)
            continue;

        std::vector<ItemBonusEntry const*> const* l_ItemBonus = GetItemBonusesByID(l_Bonus);
        if (!l_ItemBonus)
            continue;

        for (uint32 i = 0; i < l_ItemBonus->size(); i++)
        {
            ItemBonusEntry const* l_ItemSubBonus = (*l_ItemBonus)[i];
            if (!l_ItemSubBonus)
                break;

            if (l_ItemSubBonus->Type == ITEM_BONUS_MODIFY_SSD_ID)
            {
                l_SSDID = l_ItemSubBonus->Value[0];
                break;
            }
        }
    }

    return sScalingStatDistributionStore.LookupEntry(l_SSDID);
}

uint32 Player::GetEquipItemLevelFor(ItemTemplate const* itemProto, Item const* item, bool p_IgnorePvPModifiers /* = false */, bool p_ForcePvPItemLevel /* = false */) const
{
    uint32 ilvl = itemProto->ItemLevel;

    if (itemProto->Quality == ITEM_QUALITY_HEIRLOOM)
        if (ScalingStatDistributionEntry const* ssd = GetSSDForItem(item))
            if (uint32 heirloomIlvl = GetHeirloomItemLevel(ssd->CurveProperties, std::max(std::min(ssd->MaxLevel, (uint32)getLevel()), ssd->MinLevel)))
                ilvl = heirloomIlvl;

    if (item)
        ilvl += item->GetItemLevelBonusFromItemBonuses();

    if (itemProto->PvPScalingLevel && !p_IgnorePvPModifiers)
        if (p_ForcePvPItemLevel || (GetMap() && GetMap()->IsBattlegroundOrArena()) || GetMapId() == 1280 || (IsInPvPCombat() && m_deathState != JUST_DIED))
            ilvl += itemProto->PvPScalingLevel;

    if (uint32 minItemLevel = GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL))
        if (ilvl < minItemLevel && ilvl > GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL_CUTOFF))
            ilvl = minItemLevel;

    if (uint32 maxItemLevel = GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL))
        ilvl = std::min(ilvl, maxItemLevel);

    if (!(GetMap()->IsBattlegroundOrArena() && GetBattleground() && GetBattleground()->IsWargame()))
    {
        if (itemProto->Flags3 & ItemFlags3::ITEM_FLAG3_WARGAME_ONLY)
            ilvl = 1;
    }

    return ilvl;
}

void Player::RescaleItemTo(uint8 slot, uint32 ilvl)
{
    if (slot >= EQUIPMENT_SLOT_END)
        return;

    Item* item = m_items[slot];

    if (!item)
        return;

    ItemTemplate const* proto = item->GetTemplate();

    if(!proto)
        return;

    _ApplyItemModifications(item, slot, true, proto->ItemLevel);
    _ApplyItemBonuses(item, slot, true, proto->ItemLevel);
    m_itemScale[slot] = proto->ItemLevel;
    _ApplyItemModifications(item, slot, true, ilvl);
    _ApplyItemBonuses(item, slot, true, ilvl);
    m_itemScale[slot] = ilvl;
}

void Player::RescaleAllItemsIfNeeded(bool p_KeepHPPct /* = false */)
{
    float l_HealthPct = GetHealthPct();
    bool l_HasAnythingChanged = false;

    for (uint8 l_I = 0; l_I < EQUIPMENT_SLOT_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            if (l_Item->CantBeUse() || !CanUseAttackType(GetAttackBySlot(l_I)) || l_Item->GetTemplate() == nullptr)
                continue;

            uint32 ilvl = GetEquipItemLevelFor(l_Item->GetTemplate(), m_items[l_I]);
            if (m_itemScale[l_I] != ilvl)
            {
                RescaleItemTo(l_I, ilvl);
                l_HasAnythingChanged = true;
            }
        }
    }

    if (l_HasAnythingChanged)
    {
        if (p_KeepHPPct)
        {
            int32 l_Health = std::max(1, int32(l_HealthPct * (float)GetMaxHealth() / 100.0f));
            SetHealth(l_Health);
        }

        UpdateItemLevel();
    }
}

void Player::CutOffItemLevel(bool p_RescaleItems)
{
    Map* l_Map = GetMap();
    if (!l_Map)
        return;

    uint32 l_StartsWith = 0, l_MinLevel = 0, l_MaxLevel = 0;

    if (l_Map->IsBattlegroundOrArena())
    {
        l_StartsWith = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_CUTOFF);
        l_MinLevel = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_MIN);
        l_MaxLevel = sWorld->getIntConfig(CONFIG_PVP_ITEM_LEVEL_MAX);
    }
    else if (l_Map->GetDifficultyID() == DifficultyChallenge && l_Map->IsDungeon())
    {
        l_MaxLevel = sWorld->getIntConfig(CONFIG_CHALLENGE_MODE_ITEM_LEVEL_MAX);
    }

    UpdateItemLevelCutOff(l_StartsWith, l_MinLevel, l_MaxLevel, p_RescaleItems);
}

bool Player::UpdateItemLevelCutOff(uint32 p_StartsWith, uint32 p_MinLevel, uint32 p_MaxLevel, bool p_RescaleItems)
{
    if ((!p_MaxLevel && p_MinLevel > p_MaxLevel) || p_StartsWith > p_MaxLevel)
        return false;

    SetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL_CUTOFF, p_StartsWith);
    SetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL, p_MinLevel);
    SetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL, p_MaxLevel);

    if (p_RescaleItems)
        RescaleAllItemsIfNeeded(true);

    return true;
}

/// Set current interaction status
/// NOTE : This will fire all pending callback
/// @p_GUID   : Interacted GUID
/// @p_Status : New interaction status
void Player::SetInteractionStatus(uint64 p_GUID, InteractionStatus::Type p_Status)
{
    /// @TODO temp disable
    return;
    m_InteractionStatusMutex.lock();

    if (m_InteractionStatus.find(p_GUID) == m_InteractionStatus.end())
        m_InteractionStatus[p_GUID] = std::queue<InteractionStatus::Type>();

    auto & l_Queue = m_InteractionStatus[p_GUID];
    InteractionStatus::Type l_Old = InteractionStatus::None;

    if (!l_Queue.empty() && p_Status == InteractionStatus::None)
    {
        l_Old = l_Queue.front();
        l_Queue.pop();
    }

    l_Queue.push(p_Status);

    std::vector<Player::InteractionStatusCallback> l_Callbacks = m_InteractionStatusCallbacks[p_GUID];
    m_InteractionStatusCallbacks[p_GUID].clear();

    m_InteractionStatusMutex.unlock();

    for (const auto& l_Callback : l_Callbacks)
    {
        if (!l_Callback(this, p_GUID, l_Old, p_Status))
            AddInteractionStatusChangeCallback(p_GUID, l_Callback);
    }
}

/// Get current interaction status
Player::InteractionStatusMap Player::GetInteractionStatus()
{
    std::lock_guard<std::mutex> l_LockGuard(m_InteractionStatusMutex);
    return m_InteractionStatus;
}

/// Register a "fire once" callback for interaction status change
/// @p_GUID     : Interacted GUID
/// @p_Callback : Callback method
void Player::AddInteractionStatusChangeCallback(uint64 p_GUID, const Player::InteractionStatusCallback& p_Callback)
{
    /// @TODO temp disable
    return;
    m_InteractionStatusMutex.lock();
    m_InteractionStatusCallbacks[p_GUID].push_back(p_Callback);
    m_InteractionStatusMutex.unlock();
}

void Player::SetInPvPCombat(bool set)
{
    if (m_pvpCombat == set)
        return;

    m_pvpCombat = set;

    if (m_pvpCombat)
        OnEnterPvPCombat();
}

void Player::OnEnterPvPCombat()
{
    RescaleAllItemsIfNeeded(true);
}

void Player::UpdatePvP(uint32 diff)
{
    if (!m_PvPCombatTimer || !IsInPvPCombat())
        return;

    if (m_PvPCombatTimer <= diff)
    {
        SetInPvPCombat(false);
        OnLeavePvPCombat();
        m_PvPCombatTimer = 0;
    }
    else
        m_PvPCombatTimer -= diff;
}

void Player::OnLeavePvPCombat()
{
    RescaleAllItemsIfNeeded(true);
}

/// Get pet battle combat team size
uint32 Player::GetBattlePetCombatSize()
{
    uint32 l_Count = 0;

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        if (m_BattlePetCombatTeam[l_CurrentPetSlot])
            l_Count++;

    return l_Count;
}

/// Load pet battle async callback
bool Player::_LoadPetBattles(PreparedQueryResult&& p_Result)
{
    m_BattlePets.clear();

    uint64 l_PlayerGUID = GetGUID();
    MS::Utilities::CallBackPtr l_CallBack = std::make_shared<MS::Utilities::Callback>([l_PlayerGUID](bool p_Success) -> void
    {
        if (Player* l_Player = HashMapHolder<Player>::Find(l_PlayerGUID))
            l_Player->ReloadPetBattles();
    });

    if (!p_Result)
    {
        bool l_Add = false;

        SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();

        for (uint32 l_I = 0; l_I < m_OldPetBattleSpellToMerge.size(); l_I++)
        {
            BattlePet l_BattlePet;
            l_BattlePet.Slot            = PETBATTLE_NULL_SLOT;
            l_BattlePet.NameTimeStamp   = 0;
            l_BattlePet.Species         = m_OldPetBattleSpellToMerge[l_I].second;
            l_BattlePet.DisplayModelID  = 0;
            l_BattlePet.Flags           = 0;

            if (BattlePetTemplate const* l_Template = sObjectMgr->GetBattlePetTemplate(m_OldPetBattleSpellToMerge[l_I].second))
            {
                l_BattlePet.Breed   = l_Template->Breed;
                l_BattlePet.Quality = l_Template->Quality;
                l_BattlePet.Level   = l_Template->Level;
            }
            else
            {
                l_BattlePet.Breed   = 3;
                l_BattlePet.Quality = BATTLEPET_QUALITY_COMMON;
                l_BattlePet.Level   = 1;
            }

            /// Calculate XP for level
            l_BattlePet.XP = 0;

            if (l_BattlePet.Level > 1 && l_BattlePet.Level < 100)
                l_BattlePet.XP = sGtBattlePetXPStore.LookupEntry(l_BattlePet.Level - 2)->value * sGtBattlePetXPStore.LookupEntry(100 + l_BattlePet.Level - 2)->value;

            /// Calculate stats
            l_BattlePet.UpdateStats();
            l_BattlePet.Health = l_BattlePet.InfoMaxHealth;
            l_BattlePet.AddToPlayer(this, l_Transaction);

            l_Add = true;
        }

        m_OldPetBattleSpellToMerge.clear();

        if (l_Add)
        {
            CommitTransaction(LoginDatabase, l_Transaction, l_CallBack);
            return true;
        }
    }

    for (size_t l_CurrentPetSlot = 0; l_CurrentPetSlot < MAX_PETBATTLE_SLOTS; ++l_CurrentPetSlot)
        m_BattlePetCombatTeam[l_CurrentPetSlot] = BattlePet::Ptr();

    m_BattlePets.resize(p_Result ? p_Result->GetRowCount() : 0);
    uint32 l_UnlockedSlotCount = GetUnlockedPetBattleSlot();

    if (l_UnlockedSlotCount > 0)
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HAS_BATTLE_PET_TRAINING);

    std::vector<uint32> l_AlreadyKnownPet;

    if (p_Result && p_Result->GetRowCount())
    {
        size_t l_PetID = 0;

        do
        {
            if (l_PetID > m_BattlePets.size())
                continue;

            m_BattlePets[l_PetID] = BattlePet::Ptr(new BattlePet());
            m_BattlePets[l_PetID]->Load(p_Result->Fetch());

            if (m_BattlePets[l_PetID]->Slot >= 0 && m_BattlePets[l_PetID]->Slot < (int32)l_UnlockedSlotCount)
                m_BattlePetCombatTeam[m_BattlePets[l_PetID]->Slot] = m_BattlePets[l_PetID];

            l_AlreadyKnownPet.push_back(m_BattlePets[l_PetID]->Species);

            BattlePetSpeciesEntry const* l_SpeciesEntry = sBattlePetSpeciesStore.LookupEntry(m_BattlePets[l_PetID]->Species);
            if (l_SpeciesEntry != nullptr && !HasSpell(l_SpeciesEntry->spellId))
                addSpell(l_SpeciesEntry->spellId, true, true, false, false, false, false, false);

            ++l_PetID;
        } while (p_Result->NextRow());
    }

    bool l_OldPetAdded = false;
    SQLTransaction l_Transaction = LoginDatabase.BeginTransaction();
    for (uint32 l_I = 0; l_I < m_OldPetBattleSpellToMerge.size(); l_I++)
    {
        if (std::find(l_AlreadyKnownPet.begin(), l_AlreadyKnownPet.end(), m_OldPetBattleSpellToMerge[l_I].second) != l_AlreadyKnownPet.end())
            continue;

        l_OldPetAdded = true;

        BattlePet l_BattlePet;
        l_BattlePet.Slot            = PETBATTLE_NULL_SLOT;
        l_BattlePet.NameTimeStamp   = 0;
        l_BattlePet.Species         = m_OldPetBattleSpellToMerge[l_I].second;
        l_BattlePet.DisplayModelID  = 0;
        l_BattlePet.Flags           = 0;

        if (BattlePetTemplate const* temp = sObjectMgr->GetBattlePetTemplate(m_OldPetBattleSpellToMerge[l_I].second))
        {
            l_BattlePet.Breed   = temp->Breed;
            l_BattlePet.Quality = temp->Quality;
            l_BattlePet.Level   = temp->Level;
        }
        else
        {
            l_BattlePet.Breed   = 3;
            l_BattlePet.Quality = BATTLEPET_QUALITY_COMMON;
            l_BattlePet.Level   = 1;
        }

        /// Calculate XP for level
        l_BattlePet.XP = 0;

        if (l_BattlePet.Level > 1 && l_BattlePet.Level < 100)
            l_BattlePet.XP = sGtBattlePetXPStore.LookupEntry(l_BattlePet.Level - 2)->value * sGtBattlePetXPStore.LookupEntry(100 + l_BattlePet.Level - 2)->value;

        /// Calculate stats
        l_BattlePet.UpdateStats();
        l_BattlePet.Health = l_BattlePet.InfoMaxHealth;

        l_BattlePet.AddToPlayer(this, l_Transaction);
    }

    m_OldPetBattleSpellToMerge.clear();

    if (l_OldPetAdded)
    {
        CommitTransaction(LoginDatabase, l_Transaction, l_CallBack);
        return true;
    }

    GetSession()->SendBattlePetJournal();

    return true;
}

//////////////////////////////////////////////////////////////////////////
/// SpellCharges
void Player::SendSpellCharges()
{
    WorldPacket l_Data(SMSG_SEND_SPELL_CHARGES, 4 + m_CategoryCharges.size() * 9);

    l_Data << uint32(m_CategoryCharges.size());

    Clock::time_point l_Now = Clock::now();
    for (auto l_CategoryCharge : m_CategoryCharges)
    {
        if (!l_CategoryCharge.second.empty())
        {
            std::chrono::milliseconds l_CooldownDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_CategoryCharge.second.front().RechargeEnd - l_Now);
            if (l_CooldownDuration.count() <= 0)
                continue;

            l_Data << uint32(l_CategoryCharge.first);
            l_Data << uint32(l_CooldownDuration.count());
            l_Data << uint8(l_CategoryCharge.second.size());
        }
    }
    SendDirectMessage(&l_Data);
}

void Player::SendSpellCharge(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    WorldPacket l_Data(SMSG_SEND_SPELL_CHARGES, 4 + 1 * 9);

    l_Data << uint32(1);

    Clock::time_point l_Now = Clock::now();
    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end())
    {
        if (!l_Itr->second.empty())
        {
            std::chrono::milliseconds l_CooldownDuration = std::chrono::duration_cast<std::chrono::milliseconds>(l_Itr->second.front().RechargeEnd - l_Now);
            if (l_CooldownDuration.count() > 0)
            {
                l_Data << uint32(l_Itr->first);
                l_Data << uint32(l_CooldownDuration.count());
                l_Data << uint8(l_Itr->second.size());
            }
        }
    }
    SendDirectMessage(&l_Data);
}

void Player::SendSetSpellCharges(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    if (!p_ChargeCategoryEntry)
        return;

    Clock::time_point l_Now = Clock::now(); ///< l_Now is unused
    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end())
    {
        uint32 l_ConsumedCharges = l_Itr->second.size();
        bool   l_IsPet = false;

        WorldPacket l_Data(SMSG_SET_SPELL_CHARGES);
        l_Data << uint32(p_ChargeCategoryEntry->Id);
        l_Data << uint32(p_ChargeCategoryEntry->ChargeRecoveryTime);
        l_Data << uint8(l_ConsumedCharges);
        l_Data.WriteBit(l_IsPet);
        l_Data.FlushBits();


        if (l_IsPet)
        {
            l_Data << uint32(0);    ///< unk
            l_Data << uint32(0);    ///< unk
        }

        SendDirectMessage(&l_Data);
    }
}

void Player::UpdateCharges()
{
    Clock::time_point l_Now = Clock::now();

    for (auto& l_CategoryCharge : m_CategoryCharges)
    {
        std::deque<ChargeEntry>& l_ChargeRefreshTimes = l_CategoryCharge.second;

        while (!l_ChargeRefreshTimes.empty() && l_ChargeRefreshTimes.front().RechargeEnd <= l_Now)
        {
            l_ChargeRefreshTimes.pop_front();

            SpellCategoryEntry const* l_CategoryEntry = sSpellCategoryStore.LookupEntry(l_CategoryCharge.first);
            if (l_CategoryEntry != nullptr)
                SendSetSpellCharges(l_CategoryEntry);
        }
    }
}

void Player::UpdateCharge(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    Clock::time_point l_Now = Clock::now();

    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];

    while (!l_Charges.empty() && l_Charges.front().RechargeEnd <= l_Now)
    {
        l_Charges.pop_front();
        SendSetSpellCharges(p_ChargeCategoryEntry);
    }
}

bool Player::ConsumeCharge(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    if (!p_ChargeCategoryEntry)
        return false;

    int32 l_ChargeRecovery = GetChargeRecoveryTime(p_ChargeCategoryEntry);
    if (l_ChargeRecovery > 0 && GetMaxCharges(p_ChargeCategoryEntry) > 0)
    {
        Clock::time_point l_RecoveryStart;
        std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];

        if (l_Charges.empty())
            l_RecoveryStart = Clock::now();
        else
            l_RecoveryStart = l_Charges.back().RechargeEnd;

        l_Charges.emplace_back(l_RecoveryStart, std::chrono::milliseconds(l_ChargeRecovery));

        return true;
    }

    return false;
}

void Player::ReduceChargeCooldown(SpellCategoryEntry const* p_ChargeCategoryEntry, uint64 p_Reductiontime)
{
    if (!p_ChargeCategoryEntry)
        return;

    Clock::time_point l_Now = Clock::now();

    std::deque<ChargeEntry>& l_Charges = m_CategoryCharges[p_ChargeCategoryEntry->Id];
    for (ChargeEntry& l_Entry : l_Charges)
    {
        l_Entry.RechargeStart -= std::chrono::milliseconds(p_Reductiontime);
        l_Entry.RechargeEnd -= std::chrono::milliseconds(p_Reductiontime);
    }
    UpdateCharge(p_ChargeCategoryEntry);
    SendSpellCharge(p_ChargeCategoryEntry);
}

void Player::RestoreCharge(SpellCategoryEntry const* p_ChargeCategoryEntry)
{
    if (!p_ChargeCategoryEntry)
        return;

    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    if (l_Itr != m_CategoryCharges.end() && !l_Itr->second.empty())
    {
        l_Itr->second.pop_back();

        uint32 l_ConsumedCharges = l_Itr->second.size();

        bool l_IsPet = false;

        WorldPacket l_Data(SMSG_SET_SPELL_CHARGES);
        l_Data << uint32(p_ChargeCategoryEntry->Id);
        l_Data << uint32(p_ChargeCategoryEntry->ChargeRecoveryTime);
        l_Data << uint8(l_ConsumedCharges);
        l_Data.WriteBit(l_IsPet);
        l_Data.FlushBits();

        if (l_IsPet)
        {
            l_Data << uint32(0);    ///< unk
            l_Data << uint32(0);    ///< unk
        }

        SendDirectMessage(&l_Data);
    }
}

void Player::ResetAllCharges()
{
    m_CategoryCharges.clear();

    WorldPacket l_Data(SMSG_CLEAR_ALL_SPELL_CHARGES);
    l_Data.appendPackGUID(GetGUID());
    SendDirectMessage(&l_Data);
}

bool Player::HasCharge(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return true;

    // Check if the spell is currently using charges (untalented warlock Dark Soul)
    int32 l_MaxCharges = GetMaxCharges(p_ChargeCategoryEntry);
    if (l_MaxCharges <= 0)
        return true;

    auto l_Itr = m_CategoryCharges.find(p_ChargeCategoryEntry->Id);
    return l_Itr == m_CategoryCharges.end() || int32(l_Itr->second.size()) < l_MaxCharges;
}

uint32 Player::GetMaxCharges(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return 0;

    uint32 l_MaxCharge = p_ChargeCategoryEntry->MaxCharges;

    l_MaxCharge += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MAX_CHARGES, p_ChargeCategoryEntry->Id);

    return l_MaxCharge;
}

int32 Player::GetChargeRecoveryTime(SpellCategoryEntry const* p_ChargeCategoryEntry) const
{
    if (!p_ChargeCategoryEntry)
        return 0;

    float l_RecoveryTime = p_ChargeCategoryEntry->ChargeRecoveryTime;

    l_RecoveryTime += float(GetTotalAuraModifierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MOD, p_ChargeCategoryEntry->Id));
    l_RecoveryTime *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MULTIPLIER, p_ChargeCategoryEntry->Id);

    if (HasAuraType(SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE))
        l_RecoveryTime *= GetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED);

    if (HasAuraType(SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE_REGEN))
        l_RecoveryTime *= GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);

    return int32(std::floor(l_RecoveryTime));
}
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
/// ChallengesMode
void Player::_LoadCompletedChallenges(PreparedQueryResult&& p_Result)
{
    if (!p_Result)
        return;

    do
    {
        CompletedChallenge l_Challenge;

        Field* l_Field = p_Result->Fetch();
        uint32 l_MapID = l_Field[0].GetUInt32();
        l_Challenge.m_BestTime = l_Field[1].GetUInt32();
        l_Challenge.m_LastTime = l_Field[2].GetUInt32();
        l_Challenge.m_BestMedal = l_Field[3].GetUInt8();
        l_Challenge.m_BestMedalDate = l_Field[4].GetUInt32();

        m_CompletedChallenges.insert(std::make_pair(l_MapID, l_Challenge));

        RealmCompletedChallenge* l_GroupChallenge = sObjectMgr->GetGroupCompletedChallengeForMap(l_MapID);

        /// Check if player has realm best-time rewards, and if he has the realm best-time
        /// If not, and if he already has the rewards, remove them
        if (l_GroupChallenge == nullptr || l_Challenge.m_BestTime > l_GroupChallenge->m_CompletionTime)
        {
            ChallengeReward* l_Reward = sObjectMgr->GetChallengeRewardsForMap(l_MapID);
            if (l_Reward == nullptr)
                continue;

            CharTitlesEntry const* l_Title = sCharTitlesStore.LookupEntry(l_Reward->TitleID);
            if (l_Title == nullptr)
                continue;

            if (HasTitle(l_Title))
                SetTitle(l_Title, true);

            /// Remove active title if set
            if (GetUInt32Value(EPlayerFields::PLAYER_FIELD_PLAYER_TITLE) == l_Title->MaskID)
                SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);
        }
        /// If he has the realm best-time, check if he was rewarded
        /// If not, reward him
        else if (l_GroupChallenge->HasPlayer(this))
        {
            ChallengeReward* l_Reward = sObjectMgr->GetChallengeRewardsForMap(l_MapID);
            if (l_Reward == nullptr)
                continue;

            CharTitlesEntry const* l_Title = sCharTitlesStore.LookupEntry(l_Reward->TitleID);
            if (l_Title == nullptr)
                continue;

            if (!HasTitle(l_Title))
                SetTitle(l_Title, false);

            AchievementEntry const* l_Achievement = sAchievementStore.LookupEntry(l_Reward->AchievementID);
            if (l_Achievement == nullptr)
                return;

            if (!GetAchievementMgr().HasAchieved(l_Reward->AchievementID))
                CompletedAchievement(l_Achievement);
        }
    }
    while (p_Result->NextRow());
}

bool Player::HasChallengeCompleted(uint32 p_MapID) const
{
    if (m_CompletedChallenges.find(p_MapID) == m_CompletedChallenges.end())
        return false;

    return true;
}

CompletedChallenge* Player::GetCompletedChallenge(uint32 p_MapID)
{
    if (m_CompletedChallenges.find(p_MapID) == m_CompletedChallenges.end())
        return nullptr;

    return &m_CompletedChallenges[p_MapID];
}

void Player::AddCompletedChallenge(uint32 p_MapID, CompletedChallenge p_Challenge)
{
    /// Already completed
    if (m_CompletedChallenges.find(p_MapID) != m_CompletedChallenges.end())
        return;

    m_CompletedChallenges.insert(std::make_pair(p_MapID, p_Challenge));
}
//////////////////////////////////////////////////////////////////////////

void Player::ApplyOnBagsItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }

    for (uint32 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; ++l_I)
    {
        if (Bag* l_Bag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            for (uint32 l_J = 0; l_J < l_Bag->GetBagSize(); ++l_J)
            {
                if (Item* l_Item = GetItemByPos(l_I, l_J))
                {
                    if (!p_Function(this, l_Item, l_I, l_J))
                        return;
                }
            }
        }
    }
}

void Player::ApplyOnBankItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = BANK_SLOT_ITEM_START; l_I < BANK_SLOT_ITEM_END; l_I++)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }

    for (uint32 l_I = BANK_SLOT_BAG_START; l_I < BANK_SLOT_BAG_END; ++l_I)
    {
        if (Bag* l_Bag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            for (uint32 l_J = 0; l_J < l_Bag->GetBagSize(); ++l_J)
            {
                if (Item* l_Item = GetItemByPos(l_I, l_J))
                {
                    if (!p_Function(this, l_Item, l_I, l_J))
                        return;
                }
            }
        }
    }
}

void Player::ApplyOnReagentBankItems(std::function<bool(Player*, Item*, uint8, uint8)>&& p_Function)
{
    for (uint32 l_I = REAGENT_BANK_SLOT_BAG_START; l_I < REAGENT_BANK_SLOT_BAG_END; ++l_I)
    {
        if (Item* l_Item = GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
        {
            if (!p_Function(this, l_Item, INVENTORY_SLOT_BAG_0, l_I))
                return;
        }
    }
}

void Player::_LoadDailyLootsCooldowns(PreparedQueryResult&& p_Result)
{
    if (!p_Result)
        return;

    do
    {
        CompletedChallenge l_Challenge;

        Field* l_Field = p_Result->Fetch();
        uint32 l_ID = l_Field[0].GetUInt32();

        if (!m_DailyLootsCooldowns.count(l_ID))
            m_DailyLootsCooldowns.insert(l_ID);
    }
    while (p_Result->NextRow());
}

void Player::ResetDailyLoots()
{
    m_DailyLootsCooldowns.clear();
}

void Player::AddDailyLootCooldown(uint32 p_Entry)
{
    /// If not, already in database
    if (!m_DailyLootsCooldowns.count(p_Entry))
    {
        m_DailyLootsCooldowns.insert(p_Entry);

        PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_INS_DAILY_LOOT_COOLDOWNS);
        l_Statement->setUInt32(0, GetRealGUIDLow());
        l_Statement->setUInt32(1, p_Entry);
        RealmDatabase.Execute(l_Statement);
    }
}

bool Player::AddHeirloom(HeirloomEntry const* p_HeirloomEntry, uint8 p_UpgradeLevel, bool p_UseShopGroupRealmMask)
{
    if (HasHeirloom(p_HeirloomEntry))
        return false;

    uint32 l_Index = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size();
    p_UpgradeLevel = std::min(p_UpgradeLevel, (uint8)p_HeirloomEntry->MaxHeirloomUpgrade);
    uint32 l_HeirloomFlags = (1 << p_UpgradeLevel) - 1;

    SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, l_Index, p_HeirloomEntry->ItemID);
    SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, l_Index, l_HeirloomFlags);

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COLLECT_HEIRLOOMS, l_Index + 1);

    if (!sWorld->CanBeSaveInLoginDatabase())
        return true;

#ifndef CROSS
    uint32 l_GroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_GROUP_MASK);
#else /* CROSS */
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());

    uint32 l_GroupRealmMask = l_Config->groupRealmMask;
#endif /* CROSS */
    if (p_UseShopGroupRealmMask)
        l_GroupRealmMask = sWorld->getIntConfig(WorldIntConfigs::CONFIG_ACCOUNT_BIND_SHOP_GROUP_MASK);

    PreparedStatement* l_Statement = LoginDatabase.GetPreparedStatement(LOGIN_INS_HEIRLOOM);
    l_Statement->setUInt32(0, GetSession()->GetAccountId());
    l_Statement->setUInt32(1, p_HeirloomEntry->ID);
    l_Statement->setUInt32(2, l_HeirloomFlags);
    l_Statement->setUInt32(3, l_GroupRealmMask);
    l_Statement->setUInt32(4, l_GroupRealmMask);
    LoginDatabase.Execute(l_Statement);

    return true;
}

bool Player::HasHeirloom(uint32 p_ItemID) const
{
    HeirloomEntry const* l_Heirloom = GetHeirloomEntryByItemID(p_ItemID);
    return HasHeirloom(l_Heirloom);
}

bool Player::HasHeirloom(HeirloomEntry const* p_HeirloomEntry) const
{
    if (!p_HeirloomEntry)
        return false;

    std::vector<uint32> const& l_Heirlooms = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS);

    for (uint32 l_I = 0; l_I < l_Heirlooms.size(); ++l_I)
        if (l_Heirlooms[l_I] == p_HeirloomEntry->ItemID)
            return true;

    return false;
}

void Player::_LoadHeirloomCollection(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

#ifndef CROSS
    uint32 l_AllowedGroupRealmMask = sWorld->getIntConfig(CONFIG_ACCOUNT_BIND_ALLOWED_GROUP_MASK);
#else /* CROSS */
    InterRealmDatabaseConfig const* l_Config = sInterRealmMgr->GetConfig(GetSession()->GetInterRealmNumber());
    uint32 l_AllowedGroupRealmMask = l_Config->allowedGroupRealmMask;
#endif /* CROSS */

    do
    {
        Field* l_Fields = p_Result->Fetch();

        uint32 l_HeirloomID     = l_Fields[0].GetUInt32();
        uint32 l_HeirloomFlags  = l_Fields[1].GetUInt32();
        uint32 l_GroupRealmMask = l_Fields[2].GetUInt32();

        if ((l_GroupRealmMask & l_AllowedGroupRealmMask) == 0)
            continue;

        HeirloomEntry const* l_HeirloomEntry = sHeirloomStore.LookupEntry(l_HeirloomID);

        if (!l_HeirloomEntry)
            continue;

        if (HasHeirloom(l_HeirloomEntry))
            continue;

        l_HeirloomFlags = std::min(l_HeirloomFlags, (uint32)(1 << l_HeirloomEntry->MaxHeirloomUpgrade) - 1);

        uint32 l_Index = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size();
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOMS, l_Index, l_HeirloomEntry->ItemID);
        SetDynamicValue(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS, l_Index, l_HeirloomFlags);
    }
    while (p_Result->NextRow());

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COLLECT_HEIRLOOMS, GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS).size());
}

uint32 Player::GetHeirloomUpgradeLevel(HeirloomEntry const* p_HeirloomEntry) const
{
    if (!p_HeirloomEntry)
        return 0;

    std::vector<uint32> const& l_Heirlooms = GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOMS);

    for (uint32 l_I = 0; l_I < l_Heirlooms.size(); ++l_I)
    {
        if (l_Heirlooms[l_I] == p_HeirloomEntry->ItemID)
        {
            for (int l_X = p_HeirloomEntry->MaxHeirloomUpgrade + 1; l_X != 0; --l_X)
                if (GetDynamicValues(PLAYER_DYNAMIC_FIELD_HEIRLOOM_FLAGS)[l_I] & (1 << (l_X - 1)))
                    return l_X;
            return 0;
        }
    }

    return 0;
}

bool Player::CanUpgradeHeirloomWith(HeirloomEntry const* p_HeirloomEntry, uint32 p_ItemId) const
{
    if (!p_HeirloomEntry)
        return false;

    if (!HasHeirloom(p_HeirloomEntry))
        return false;

    uint32 l_CurrentUpgradeLevel = GetHeirloomUpgradeLevel(p_HeirloomEntry);
    if (p_HeirloomEntry->MaxHeirloomUpgrade <= l_CurrentUpgradeLevel || l_CurrentUpgradeLevel >= MAX_HEIRLOOM_UPGRADE_LEVEL)
        return false;

    if (!p_HeirloomEntry->UpgradeIemBonusID[l_CurrentUpgradeLevel])
        return false;

    if (p_HeirloomEntry->UpgradableByItemID[l_CurrentUpgradeLevel] != p_ItemId)
        return false;

    return HasItemCount(p_ItemId);
}

void Player::SetQuestBit(uint32 p_BitIndex, bool p_Completed)
{
    if (!p_BitIndex)
        return;

    uint32 l_FlagValue  = 1 <<  ((p_BitIndex - 1) % 32);
    uint32 l_FieldIndex = (p_BitIndex - 1) / 32;

    if (p_Completed)
        SetFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
    else
        RemoveFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
}

bool Player::IsQuestBitFlaged(uint32 p_BitIndex) const
{
    if (!p_BitIndex)
        return false;

    uint32 l_FlagValue  = 1 << ((p_BitIndex - 1) % 32);
    uint32 l_FieldIndex = (p_BitIndex - 1) / 32;

    return HasFlag(PLAYER_FIELD_QUEST_COMPLETED + l_FieldIndex, l_FlagValue);
}

void Player::ClearQuestBits(std::vector<uint32> const& p_QuestBits)
{
    for (auto l_Bit : p_QuestBits)
        SetQuestBit(l_Bit, false);
}

Difficulty Player::GetDifficultyID(MapEntry const* p_MapEntry) const
{
    if (!p_MapEntry->IsRaid())
        return m_dungeonDifficulty;

    MapDifficulty const* l_DefaultDifficulty = GetDefaultMapDifficulty(p_MapEntry->MapID);
    if (!l_DefaultDifficulty)
        return m_LegacyRaidDifficulty;

    DifficultyEntry const* l_Difficulty = sDifficultyStore.LookupEntry(l_DefaultDifficulty->DifficultyID);
    if (!l_Difficulty || l_Difficulty->Flags & DIFFICULTY_FLAG_LEGACY)
        return m_LegacyRaidDifficulty;

    return m_raidDifficulty;
}

Difficulty Player::CheckLoadedDungeonDifficultyID(Difficulty difficulty)
{
    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(difficulty);
    if (!l_DifficultyEntry)
        return DifficultyNormal;

    if (l_DifficultyEntry->InstanceType != MAP_INSTANCE)
        return DifficultyNormal;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT))
        return DifficultyNormal;

    return difficulty;
}

Difficulty Player::CheckLoadedRaidDifficultyID(Difficulty p_Difficulty)
{
    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(p_Difficulty);
    if (!l_DifficultyEntry)
        return DifficultyRaidNormal;

    if (l_DifficultyEntry->InstanceType != MAP_RAID)
        return DifficultyRaidNormal;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || (l_DifficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return DifficultyRaidNormal;

    return p_Difficulty;
}

Difficulty Player::CheckLoadedLegacyRaidDifficultyID(Difficulty p_Difficulty)
{
    DifficultyEntry const* l_DifficultyEntry = sDifficultyStore.LookupEntry(p_Difficulty);
    if (!l_DifficultyEntry)
        return Difficulty10N;

    if (l_DifficultyEntry->InstanceType != MAP_RAID)
        return Difficulty10N;

    if (!(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || !(l_DifficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return Difficulty10N;

    return p_Difficulty;
}

void Player::ApplyWargameItemModifications()
{
    bool l_InWargame       = GetBattleground() && GetBattleground()->IsWargame();
    bool l_TournamentRules = GetBattleground() && GetBattleground()->UseTournamentRules();

    for (uint8 l_I = 0; l_I < EQUIPMENT_SLOT_END; ++l_I)
    {
        if (Item* l_Item = m_items[l_I])
        {
            bool l_UpdateItemMods = false;

            if (l_InWargame)
            {
                if (l_Item->GetTemplate()->Flags3 & ItemFlags3::ITEM_FLAG3_WARGAME_ONLY)
                {
                    if (l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                    {
                        l_Item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                        l_UpdateItemMods = true;
                    }
                }
                else if (l_TournamentRules && !l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                {
                    l_Item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                    l_UpdateItemMods = true;
                }
            }
            else
            {
                if (l_Item->GetTemplate()->Flags3 & ItemFlags3::ITEM_FLAG3_WARGAME_ONLY)
                {
                    if (!l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                    {
                        l_Item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                        l_UpdateItemMods = true;
                    }
                }
                else if (l_Item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE))
                {
                    l_Item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FIELD_FLAG_DISABLE);
                    l_UpdateItemMods = true;
                }
            }

            if (l_UpdateItemMods)
            {
                _ApplyItemMods(l_Item, l_I, false);
                _ApplyItemMods(l_Item, l_I, true);
            }
        }
    }
}

#ifndef CROSS
void Player::RewardCompletedAchievementsIfNeeded()
{
    GetAchievementMgr().GetCompletedAchievementLock().acquire();
    for (auto l_Iterator : GetAchievementMgr().GetCompletedAchivements())
    {
        AchievementEntry const* l_Achievement = sAchievementMgr->GetAchievement(l_Iterator.first);
        if (l_Achievement == nullptr)
            continue;

        /// Make sure the achievement is for the right faction
        if ((GetTeamId() == TeamId::TEAM_HORDE && l_Achievement->Faction == 1)
            || (GetTeamId() == TeamId::TEAM_ALLIANCE && l_Achievement->Faction == 0))
            continue;

        AchievementReward const* l_Reward = sAchievementMgr->GetAchievementReward(l_Achievement);
        if (l_Reward == nullptr)
            continue;

        /// Titles are already handle at achievement loading
        /// So we just handle item case here
        if (l_Reward->itemId == 0)
            continue;

        ItemTemplate const* l_ItemTemplate = sObjectMgr->GetItemTemplate(l_Reward->itemId);
        if (l_ItemTemplate == nullptr)
            continue;

        uint32 l_SpellLearned = 0;
        for (uint8 l_Index = 0; l_Index < MAX_ITEM_PROTO_SPELLS; ++l_Index)
        {
            if (l_ItemTemplate->Spells[l_Index].SpellTrigger == ItemSpelltriggerType::ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
            {
                l_SpellLearned = l_ItemTemplate->Spells[l_Index].SpellId;
                break;
            }
        }

        /// Hack fix for Chauffeured Chopper, item sent is a gift box, containing Horde or Alliance chopper, so no learned spell
        if (l_ItemTemplate->ItemId == 122718)
        {
            switch (GetTeamId())
            {
                case TeamId::TEAM_ALLIANCE:
                {
                    l_SpellLearned = 179245;
                    break;
                }
                case TeamId::TEAM_HORDE:
                {
                    l_SpellLearned = 179244;
                    break;
                }
                default:
                    break;
            }
        }

        /// - Only support mount / pet items
        /// - Because we have not way to know if the player have already get the reward otherwise
        if (!l_SpellLearned)
            continue;

        /// Check if the player have already get the reward
        /// 1 - Check if player already have learned the spell
        if (HasSpell(l_SpellLearned))
            continue;

        /// 2 - Check his bags / bank
        if (GetItemCount(l_ItemTemplate->ItemId, true) != 0)
            continue;

        /// 3 - Check in mail (achievements rewards are sended by mails)
        {
            bool l_FoundInMail = false;
            for (auto l_Item : mMitems)
            {
                if (l_Item.second->GetEntry() == l_ItemTemplate->ItemId)
                {
                    l_FoundInMail = true;
                    break;
                }
            }

            if (l_FoundInMail)
                continue;
        }

        /// We are now sure the player didn't get the reward, send it to him with mail!
        // Mail
        if (l_Reward->sender)
        {
            Item* l_Item = l_Reward->itemId ? Item::CreateItem(l_Reward->itemId, 1, this) : nullptr;

            int l_LocIDX = GetSession()->GetSessionDbLocaleIndex();

            // Subject and text
            std::string l_Subject = l_Reward->subject;
            std::string l_Text = l_Reward->text;
            if (l_LocIDX >= 0)
            {
                if (AchievementRewardLocale const* l_Locale = sAchievementMgr->GetAchievementRewardLocale(l_Achievement))
                {
                    ObjectMgr::GetLocaleString(l_Locale->subject, l_LocIDX, l_Subject);
                    ObjectMgr::GetLocaleString(l_Locale->text, l_LocIDX, l_Text);
                }
            }

            MailDraft l_Draft(l_Subject, l_Text);

            SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();
            if (l_Item)
            {
                // Save new item before send
                l_Item->SaveToDB(l_Transaction);                               // Save for prevent lost at next mail load, if send fail then item will deleted

                // Item
                l_Draft.AddItem(l_Item);
            }

            l_Draft.SendMailTo(l_Transaction, this, MailSender(MAIL_CREATURE, l_Reward->sender));
            CharacterDatabase.CommitTransaction(l_Transaction);
        }
    }
    
    GetAchievementMgr().GetCompletedAchievementLock().release();
}

#endif /* not CROSS */
void Player::DeleteInvalidSpells()
{
    PlayerSpellMap l_SpellMap = GetSpellMap();
    for (PlayerSpellMap::const_iterator l_Iterator = l_SpellMap.begin(); l_Iterator != l_SpellMap.end(); ++l_Iterator)
    {
        if (sObjectMgr->IsInvalidSpell(l_Iterator->first))
            removeSpell(l_Iterator->first, false, false);
    }
}

uint32 Player::GetDefaultSpecId() const
{
    ChrClassesEntry const* l_CharClasseEntry = sChrClassesStore.LookupEntry(getClass());
    if (l_CharClasseEntry)
        return l_CharClasseEntry->m_DefaultSpec;
    return 0;
}

void Player::_LoadWorldStates(PreparedQueryResult p_Result)
{
    if (!p_Result)
        return;

    do
    {
        Field* l_Fields = p_Result->Fetch();
        CharacterWorldState l_WorldState;
        l_WorldState.Value   = l_Fields[1].GetUInt64();
        l_WorldState.Changed = false;

        m_CharacterWorldStates.insert(std::make_pair(l_Fields[0].GetUInt32(), l_WorldState));
    }
    while (p_Result->NextRow());
}

void Player::_SaveCharacterWorldStates(SQLTransaction& p_Transaction)
{
    for (auto l_Iterator : m_CharacterWorldStates)
    {
        CharacterWorldState& l_WorldState = l_Iterator.second;
        if (!l_WorldState.Changed)
            continue;

        PreparedStatement* l_Statement = RealmDatabase.GetPreparedStatement(CHAR_REP_WORLD_STATES);
        l_Statement->setUInt32(0, GetRealGUIDLow());
        l_Statement->setUInt32(1, l_Iterator.first);
        l_Statement->setUInt64(2, l_WorldState.Value);

        p_Transaction->Append(l_Statement);
    }
}

void Player::SendCustomMessage(std::string const& p_Opcode)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|" << " " << "|";
    ChatHandler(this).SendSysMessage(l_Message.str().c_str());
}
void Player::SendCustomMessage(std::string const& p_Opcode, std::ostringstream const& p_Message)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|" << p_Message.str() << "|";
    ChatHandler(this).SendSysMessage(l_Message.str().c_str());
}
void Player::SendCustomMessage(std::string const& p_Opcode, std::vector<std::string> const& p_Data)
{
    std::ostringstream l_Message;
    l_Message << p_Opcode << "|";

    if (!p_Data.empty())
    {
        for (auto const& l_Elem : p_Data)
            l_Message << l_Elem << "| ";
    }
    else
        l_Message << " " << "|";

    ChatHandler(this).SendSysMessage(l_Message.str().c_str());
}

uint32 Player::GetBagsFreeSlots() const
{
    uint32 l_FreeBagSlots = 0;

    for (uint8 l_I = INVENTORY_SLOT_BAG_START; l_I < INVENTORY_SLOT_BAG_END; l_I++)
    {
        if (Bag * l_Bag = GetBagByPos(l_I))
            l_FreeBagSlots += l_Bag->GetFreeSlots();
    }

    for (uint8 l_I = INVENTORY_SLOT_ITEM_START; l_I < INVENTORY_SLOT_ITEM_END; l_I++)
    {
        if (!GetItemByPos(INVENTORY_SLOT_BAG_0, l_I))
            ++l_FreeBagSlots;
    }

    return l_FreeBagSlots;
}

void Player::CheckTalentSpells()
{
    std::set<uint32> l_Talents;
    uint8 l_SpeCount = std::min(GetSpecsCount(), (uint8)MAX_TALENT_SPECS);

    for (uint8 l_SpecIdx = 0; l_SpecIdx < l_SpeCount; l_SpecIdx++)
    {
        PlayerTalentMap& l_PlayerTalent = *GetTalentMap(l_SpecIdx);
        for (PlayerTalentMap::iterator l_TalentItr = l_PlayerTalent.begin(); l_TalentItr != l_PlayerTalent.end(); ++l_TalentItr)
            l_Talents.insert(l_TalentItr->first);
    }

    for (PlayerSpellMap::iterator l_Itr = m_spells.begin(); l_Itr != m_spells.end();)
    {
        if (!l_Itr->second)
            continue;

        if (l_Itr->second->state != PlayerSpellState::PLAYERSPELL_REMOVED
            && sSpellMgr->IsTalent(l_Itr->first)
            && l_Talents.find(l_Itr->first) == l_Talents.end())
        {
            removeSpell(l_Itr->first);
            l_Itr = m_spells.begin();
            continue;
        }

        ++l_Itr;
    }
}

void Player::HandleWarlockWodPvpBonus()
{
    if (getClass() != CLASS_WARLOCK || getLevel() != 100)
        return;

    uint32 l_SpellBonusId = 0;
    uint32 l_TriggerSpell = 0;

    /// Check what's specialization bonus we need
    if (GetSpecializationId() == SPEC_WARLOCK_AFFLICTION)
    {
        l_SpellBonusId = 171377;
        l_TriggerSpell = 171378;
    }
    else if (GetSpecializationId() == SPEC_WARLOCK_DESTRUCTION)
    {
        l_SpellBonusId = 171383;
        l_TriggerSpell = 188168;
    }

    if (HasAura(l_SpellBonusId) && !HasSpellCooldown(l_TriggerSpell))
    {
        CastSpell(this, l_TriggerSpell, true);
        AddSpellCooldown(l_TriggerSpell, 0, 15 * IN_MILLISECONDS);
    }
}

#ifdef CROSS
void Player::RemovePlayer()
{
    sAnticheatMgr->HandlePlayerLogout(this);

    if (InBattleground())
    {
        if (Battleground* bg = GetBattleground())
            bg->RemovePlayerAtLeave(GetGUID(), true, false);
    }
    else if (InBattlegroundQueue())
    {
        for (int i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        {
            MS::Battlegrounds::BattlegroundType::Type l_BgQueueTypeId = GetBattlegroundQueueTypeId(i);

            if (l_BgQueueTypeId != MS::Battlegrounds::BattlegroundType::None)
            {
                RemoveBattlegroundQueueId(l_BgQueueTypeId);
                sBattlegroundMgr->RemovePlayer(GetGUID(), true, l_BgQueueTypeId);
            }
        }
    }

    /// Make sure every invitation are removed to avoid future bug (they should be already removed ...)
    sBattlegroundMgr->GetInvitationsMgr().ClearPlayerInvitation(GetGUID());

    WorldSession* pSession = GetSession();

    uint64 realguid = GetRealGUID();
    uint64 newguid = GetGUID();

    CleanupsBeforeDelete();

    if (pSession)
    {
        if (InterRealmClient* client = pSession->GetInterRealmClient())
            pSession->GetInterRealmClient()->RemovePlayer(GetRealGUID());

        pSession->SetInterRealmClient(NULL);
        pSession->setInInterRealmBG(false);
        pSession->SetIRClosing(true);
        pSession->SetPlayer(NULL);

        delete pSession;
    }

    if (IsInGrid())
        RemoveFromGrid();

    sObjectAccessor->RemoveObject(this);
    sObjectAccessor->RemoveUpdateObject(this);

    ResetMap();
}

InterRealmDatabasePool* Player::GetRealmDatabase()
{
    return GetSession()->GetInterRealmClient()->GetDatabase();
}

#endif /* CROSS */
uint32 Player::GetRandomWeaponFromPrimaryBag(ItemTemplate const* p_Transmogrified) const
{
    uint32 l_AllItemsInPrimaryBag[16];
    uint8 l_ArrayCapacity = 0;

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        if (Item* l_FoundItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (ItemTemplate const* l_FoundItemTemplate = l_FoundItem->GetTemplate())
            {
                if (l_FoundItemTemplate->Class != ITEM_CLASS_WEAPON)
                    continue;

                if (!Item::CanTransmogrifyIntoRandomWeapon(l_FoundItemTemplate, p_Transmogrified))
                    continue;

                if (l_FoundItemTemplate->ItemId != 0)
                {
                    l_AllItemsInPrimaryBag[l_ArrayCapacity] = l_FoundItemTemplate->ItemId;
                    l_ArrayCapacity++;
                }
            }
        }
    }

    /// If we have just one item, we should take it
    if (l_ArrayCapacity == 1)
        return l_AllItemsInPrimaryBag[0];

    /// Select random weapon id from primary bag if we have many items
    if (l_ArrayCapacity > 1)
    {
        int32 l_RandomWeapon = urand(0, l_ArrayCapacity - 1);
        return l_AllItemsInPrimaryBag[l_RandomWeapon];
    }

    return 0;
#ifdef CROSS
}

void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    if (Battleground* bg = GetBattleground())
    {
        bg->RemovePlayerAtLeave(GetGUID(), true, false);

        // call after remove to be sure that player resurrected for correct cast
        if (bg->isBattleground() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                //lets check if player was teleported from BG and schedule delayed Deserter spell cast
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                CastSpell(this, 26013, true); ///< Deserter
            }
        }
        bg->RemoveFromInterRealm(GetGUID());
    }
#endif /* CROSS */
}

uint32 Player::GetZoneId(bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
        *(const_cast<uint32*>(&m_LastZoneId)) = WorldObject::GetZoneId();

    return m_LastZoneId;
}

uint32 Player::GetAreaId(bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
        *(const_cast<uint32*>(&m_LastAreaId)) = WorldObject::GetAreaId();

    return m_LastAreaId;
}

void Player::GetZoneAndAreaId(uint32& p_ZoneId, uint32& p_AreaId, bool p_ForceRecalc) const
{
    if (p_ForceRecalc)
    {
        WorldObject::GetZoneAndAreaId(p_ZoneId, p_AreaId);
        *(const_cast<uint32*>(&m_LastZoneId)) = p_ZoneId;
        *(const_cast<uint32*>(&m_LastAreaId)) = p_AreaId;
        return;
    }

    p_ZoneId = m_LastZoneId;
    p_AreaId = m_LastAreaId;
}

void Player::HandleFactionChangeActions(char const* p_KnownTitle, uint64 p_GUID, uint8 p_Race, bool p_AtFactionChange)
{
    SQLTransaction l_Transaction = CharacterDatabase.BeginTransaction();

    uint32 l_GUIDLow = GUID_LOPART(p_GUID);
    uint32 l_Team = TeamForRace(p_Race);
    uint32 l_TeamID = l_Team == ALLIANCE ? TEAM_ALLIANCE : l_Team == HORDE ? TEAM_HORDE : TEAM_NEUTRAL;

    /// Quest conversion
    for (std::map<uint32, uint32>::const_iterator l_Itr = sObjectMgr->FactionChange_Quests.begin(); l_Itr != sObjectMgr->FactionChange_Quests.end(); ++l_Itr)
    {
        uint32 l_Quest_alliance = l_Itr->first;
        uint32 l_Quest_horde = l_Itr->second;

        uint32 l_OldQuest = l_TeamID == TEAM_ALLIANCE ? l_Quest_horde : l_Quest_alliance;
        uint32 l_NewQuest = l_TeamID == TEAM_ALLIANCE ? l_Quest_alliance : l_Quest_horde;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
        stmt->setUInt32(0, l_NewQuest);
        stmt->setUInt32(1, l_OldQuest);
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);
    }

    /// Achievement conversion
    for (std::map<uint32, uint32>::const_iterator l_Itr = sObjectMgr->FactionChange_Achievements.begin(); l_Itr != sObjectMgr->FactionChange_Achievements.end(); ++l_Itr)
    {
        uint32 l_Achiev_alliance = l_Itr->first;
        uint32 l_Achiev_horde = l_Itr->second;

        PreparedStatement* stmt;

        if (p_AtFactionChange)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_BY_ACHIEVEMENT);
            stmt->setUInt16(0, uint16(l_TeamID == TEAM_ALLIANCE ? l_Achiev_alliance : l_Achiev_horde));
            stmt->setUInt32(1, l_GUIDLow);
            l_Transaction->Append(stmt);
        }

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACHIEVEMENT);
        stmt->setUInt16(0, uint16(l_TeamID == TEAM_ALLIANCE ? l_Achiev_alliance : l_Achiev_horde));
        stmt->setUInt16(1, uint16(l_TeamID == TEAM_ALLIANCE ? l_Achiev_horde : l_Achiev_alliance));
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);
    }

    /// Item conversion
    for (std::map<uint32, uint32>::const_iterator l_Itr = sObjectMgr->FactionChange_Items.begin(); l_Itr != sObjectMgr->FactionChange_Items.end(); ++l_Itr)
    {
        uint32 l_Item_alliance = l_Itr->first;
        uint32 l_Item_horde = l_Itr->second;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INVENTORY_FACTION_CHANGE);
        stmt->setUInt32(0, (l_TeamID == TEAM_ALLIANCE ? l_Item_alliance : l_Item_horde));
        stmt->setUInt32(1, (l_TeamID == TEAM_ALLIANCE ? l_Item_horde : l_Item_alliance));
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_MAIL_ITEM_FACTION_CHANGE);
        stmt->setUInt32(0, (l_TeamID == TEAM_ALLIANCE ? l_Item_alliance : l_Item_horde));
        stmt->setUInt32(1, (l_TeamID == TEAM_ALLIANCE ? l_Item_horde : l_Item_alliance));
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);
    }

    /// Spell conversion
    for (std::map<uint32, uint32>::const_iterator l_Itr = sObjectMgr->FactionChange_Spells.begin(); l_Itr != sObjectMgr->FactionChange_Spells.end(); ++l_Itr)
    {
        uint32 spell_alliance = l_Itr->first;
        uint32 spell_horde = l_Itr->second;

        PreparedStatement* stmt;

        if (p_AtFactionChange)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
            stmt->setUInt32(0, (l_TeamID == TEAM_ALLIANCE ? spell_alliance : spell_horde));
            stmt->setUInt32(1, l_GUIDLow);
            l_Transaction->Append(stmt);
        }

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_SPELL_FACTION_CHANGE);
        stmt->setUInt32(0, (l_TeamID == TEAM_ALLIANCE ? spell_alliance : spell_horde));
        stmt->setUInt32(1, (l_TeamID == TEAM_ALLIANCE ? spell_horde : spell_alliance));
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);
    }

    /// Reputation conversion
    for (std::map<uint32, uint32>::const_iterator l_Itr = sObjectMgr->FactionChange_Reputation.begin(); l_Itr != sObjectMgr->FactionChange_Reputation.end(); ++l_Itr)
    {
        uint32 reputation_alliance = l_Itr->first;
        uint32 reputation_horde = l_Itr->second;
        PreparedStatement* stmt;

        if (p_AtFactionChange)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REP_BY_FACTION);
            stmt->setUInt32(0, uint16(l_TeamID == TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
            stmt->setUInt32(1, l_GUIDLow);
            l_Transaction->Append(stmt);
        }

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_REP_FACTION_CHANGE);
        stmt->setUInt16(0, uint16(l_TeamID == TEAM_ALLIANCE ? reputation_alliance : reputation_horde));
        stmt->setUInt16(1, uint16(l_TeamID == TEAM_ALLIANCE ? reputation_horde : reputation_alliance));
        stmt->setUInt32(2, l_GUIDLow);
        l_Transaction->Append(stmt);
    }

    /// Title conversion
    if (p_KnownTitle)
    {
        const uint32 ktcount = KNOWN_TITLES_SIZE * 2;
        uint32 knownTitles[ktcount];
        Tokenizer tokens(p_KnownTitle, ' ', ktcount);

        if (tokens.size() != ktcount)
            return;

        for (uint32 index = 0; index < ktcount; ++index)
            knownTitles[index] = atol(tokens[index]);

        for (std::map<uint32, uint32>::const_iterator it = sObjectMgr->FactionChange_Titles.begin(); it != sObjectMgr->FactionChange_Titles.end(); ++it)
        {
            uint32 title_alliance = it->first;
            uint32 title_horde = it->second;

            CharTitlesEntry const* atitleInfo = sCharTitlesStore.LookupEntry(title_alliance);
            CharTitlesEntry const* htitleInfo = sCharTitlesStore.LookupEntry(title_horde);
            /// new team
            if (l_Team == TEAM_ALLIANCE)
            {
                uint32 bitIndex = htitleInfo->MaskID;
                uint32 index = bitIndex / 32;
                uint32 old_flag = 1 << (bitIndex % 32);
                uint32 new_flag = 1 << (atitleInfo->MaskID % 32);
                if (knownTitles[index] & old_flag)
                {
                    knownTitles[index] &= ~old_flag;
                    /// use index of the new title
                    knownTitles[atitleInfo->MaskID / 32] |= new_flag;
                }
            }
            else
            {
                uint32 bitIndex = atitleInfo->MaskID;
                uint32 index = bitIndex / 32;
                uint32 old_flag = 1 << (bitIndex % 32);
                uint32 new_flag = 1 << (htitleInfo->MaskID % 32);
                if (knownTitles[index] & old_flag)
                {
                    knownTitles[index] &= ~old_flag;
                    /// use index of the new title
                    knownTitles[htitleInfo->MaskID / 32] |= new_flag;
                }
            }

            std::ostringstream ss;
            for (uint32 index = 0; index < ktcount; ++index)
                ss << knownTitles[index] << ' ';

            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_TITLES_FACTION_CHANGE);
            stmt->setString(0, ss.str().c_str());
            stmt->setUInt32(1, l_GUIDLow);
            l_Transaction->Append(stmt);

            /// unset any currently chosen title
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_RES_CHAR_TITLES_FACTION_CHANGE);
            stmt->setUInt32(0, l_GUIDLow);
            l_Transaction->Append(stmt);
        }
    }

    CharacterDatabase.CommitTransaction(l_Transaction);
}
